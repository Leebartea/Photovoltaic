<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Advanced Photovoltaic System Calculator — professional off-grid solar sizing tool for the Nigerian market. Inverter, battery, PV array, MPPT, and cable sizing in one page.">
    <meta name="author" content="Leebartea">
    <meta name="version" content="1.0.0">
    <meta property="og:title" content="Advanced PV System Calculator">
    <meta property="og:description" content="Professional off-grid solar system design tool with motor surge analysis, compliance-aware inverter sizing, and SVG system overview.">
    <meta property="og:type" content="website">
    <title>Advanced PV System Calculator | Leebartea</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='6' fill='%232563eb'/%3E%3Ctext x='16' y='23' text-anchor='middle' font-size='20' font-weight='bold' fill='white'%3EPV%3C/text%3E%3C/svg%3E">
    <!-- jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
/* =============================================================================
   CSS STYLES
   ============================================================================= */

:root {
    --primary-color: #2563eb;
    --primary-dark: #1d4ed8;
    --success-color: #16a34a;
    --warning-color: #d97706;
    --error-color: #dc2626;
    --bg-color: #f8fafc;
    --card-bg: #ffffff;
    --text-color: #1e293b;
    --text-muted: #64748b;
    --border-color: #e2e8f0;
    --shadow: 0 1px 3px rgba(0,0,0,0.1);
    --shadow-lg: 0 4px 6px rgba(0,0,0,0.1);
    --input-bg: #ffffff;
}

/* =============================================================================
   DARK MODE
   ============================================================================= */
[data-theme="dark"] {
    --primary-color: #3b82f6;
    --primary-dark: #2563eb;
    --success-color: #22c55e;
    --warning-color: #f59e0b;
    --error-color: #ef4444;
    --bg-color: #0f172a;
    --card-bg: #1e293b;
    --text-color: #f1f5f9;
    --text-muted: #94a3b8;
    --border-color: #334155;
    --shadow: 0 1px 3px rgba(0,0,0,0.3);
    --shadow-lg: 0 4px 6px rgba(0,0,0,0.4);
    --input-bg: #334155;
}

[data-theme="dark"] input,
[data-theme="dark"] select {
    background-color: var(--input-bg);
    color: var(--text-color);
    border-color: var(--border-color);
}

[data-theme="dark"] .appliance-table th {
    background: var(--bg-color);
}

[data-theme="dark"] .summary-card {
    background: var(--card-bg);
}

[data-theme="dark"] header {
    background: linear-gradient(135deg, #1e40af, #1e3a8a);
}

[data-theme="dark"] .results-section {
    background: var(--card-bg);
}

[data-theme="dark"] .alert-warning {
    background: #422006;
    color: #fef3c7;
}

[data-theme="dark"] .alert-error {
    background: #450a0a;
    color: #fee2e2;
}

[data-theme="dark"] .alert-success {
    background: #052e16;
    color: #dcfce7;
}

[data-theme="dark"] .alert-info {
    background: #172554;
    color: #dbeafe;
}

/* Theme Toggle Button */
.theme-toggle {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 50%;
    width: 44px;
    height: 44px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.3rem;
    box-shadow: var(--shadow-lg);
    transition: all 0.3s;
}

.theme-toggle:hover {
    transform: scale(1.1);
}

@media print {
    .theme-toggle {
        display: none;
    }
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
    line-height: 1.6;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

header {
    background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
    color: white;
    padding: 30px 20px;
    text-align: center;
    margin-bottom: 30px;
    border-radius: 8px;
    box-shadow: var(--shadow-lg);
}

header h1 {
    font-size: 2rem;
    margin-bottom: 8px;
}

header p {
    opacity: 0.9;
    font-size: 1rem;
}

.main-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
}

@media (max-width: 1024px) {
    .main-grid {
        grid-template-columns: 1fr;
    }
}

.card {
    background: var(--card-bg);
    border-radius: 8px;
    box-shadow: var(--shadow);
    padding: 20px;
    margin-bottom: 20px;
}

.card h2 {
    font-size: 1.25rem;
    margin-bottom: 16px;
    padding-bottom: 10px;
    border-bottom: 2px solid var(--primary-color);
    color: var(--primary-color);
}

.card h3 {
    font-size: 1.1rem;
    margin: 16px 0 12px;
    color: var(--text-color);
}

/* Form Styles */
.form-group {
    margin-bottom: 16px;
}

.form-group label {
    display: block;
    margin-bottom: 6px;
    font-weight: 500;
    color: var(--text-color);
}

.form-group small {
    display: block;
    margin-top: 4px;
    color: var(--text-muted);
    font-size: 0.85rem;
}

input[type="text"],
input[type="number"],
select {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 1rem;
    transition: border-color 0.2s, box-shadow 0.2s;
}

input:focus,
select:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.form-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
}

.form-row.three {
    grid-template-columns: 1fr 1fr 1fr;
}

@media (max-width: 600px) {
    .form-row, .form-row.three {
        grid-template-columns: 1fr;
    }
}

/* Buttons */
.btn {
    display: inline-block;
    padding: 12px 24px;
    font-size: 1rem;
    font-weight: 600;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
}

.btn-primary {
    background: var(--primary-color);
    color: white;
}

.btn-primary:hover {
    background: var(--primary-dark);
}

.btn-success {
    background: var(--success-color);
    color: white;
}

.btn-secondary {
    background: var(--text-muted);
    color: white;
}

.btn-group {
    display: flex;
    gap: 12px;
    margin-top: 20px;
    flex-wrap: wrap;
}

/* Appliance Table */
.appliance-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 16px;
    font-size: 0.9rem;
}

.appliance-table th,
.appliance-table td {
    padding: 10px 8px;
    text-align: left;
    border-bottom: 1px solid var(--border-color);
}

.appliance-table th {
    background: var(--bg-color);
    font-weight: 600;
}

.appliance-table tr:hover {
    background: var(--bg-color);
}

.appliance-table .actions {
    white-space: nowrap;
}

.btn-small {
    padding: 4px 8px;
    font-size: 0.8rem;
    border-radius: 4px;
}

/* Results */
.results-section {
    background: var(--bg-color);
    padding: 16px;
    border-radius: 6px;
    margin-top: 16px;
}

.result-row {
    display: flex;
    justify-content: space-between;
    padding: 8px 0;
    border-bottom: 1px solid var(--border-color);
}

.result-row:last-child {
    border-bottom: none;
}

.result-label {
    color: var(--text-muted);
}

.result-value {
    font-weight: 600;
    text-align: right;
}

/* Warnings and Blocks */
.alert {
    padding: 12px 16px;
    border-radius: 6px;
    margin: 12px 0;
    display: flex;
    align-items: flex-start;
    gap: 12px;
}

.alert-warning {
    background: #fef3c7;
    border-left: 4px solid var(--warning-color);
    color: #92400e;
}

.alert-error {
    background: #fee2e2;
    border-left: 4px solid var(--error-color);
    color: #991b1b;
}

.alert-success {
    background: #dcfce7;
    border-left: 4px solid var(--success-color);
    color: #166534;
}

.alert-info {
    background: #dbeafe;
    border-left: 4px solid var(--primary-color);
    color: #1e40af;
}

.alert-icon {
    font-size: 1.2rem;
    flex-shrink: 0;
}

.alert-content {
    flex: 1;
}

.alert-title {
    font-weight: 600;
    margin-bottom: 4px;
}

/* Summary Cards */
.summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 16px;
    margin-top: 16px;
}

.summary-card {
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 16px;
    text-align: center;
}

.summary-card .value {
    font-size: 1.75rem;
    font-weight: 700;
    color: var(--primary-color);
}

.summary-card .label {
    font-size: 0.9rem;
    color: var(--text-muted);
    margin-top: 4px;
}

/* Tabs */
.tabs {
    display: flex;
    border-bottom: 2px solid var(--border-color);
    margin-bottom: 16px;
    overflow-x: auto;
}

.tab {
    padding: 12px 20px;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    margin-bottom: -2px;
    transition: all 0.2s;
    white-space: nowrap;
}

.tab:hover {
    background: var(--bg-color);
}

.tab.active {
    border-bottom-color: var(--primary-color);
    color: var(--primary-color);
    font-weight: 600;
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

/* Print Styles */
@media print {
    .no-print {
        display: none !important;
    }

    .card {
        break-inside: avoid;
        box-shadow: none;
        border: 1px solid #ccc;
    }

    body {
        background: white;
    }
}

/* Checkbox Styling */
.checkbox-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.checkbox-group input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

/* Equipment List */
.equipment-list {
    list-style: none;
}

.equipment-list li {
    padding: 8px 0;
    border-bottom: 1px solid var(--border-color);
}

.equipment-list li:last-child {
    border-bottom: none;
}

.equipment-name {
    font-weight: 600;
}

.equipment-spec {
    color: var(--text-muted);
    font-size: 0.9rem;
}

/* Hidden utility */
.hidden {
    display: none;
}

/* =============================================================================
   ENHANCED VALIDATION STYLES
   ============================================================================= */

/* Input validation states */
input.invalid,
select.invalid {
    border-color: var(--error-color) !important;
    background-color: #fef2f2;
}

input.valid,
select.valid {
    border-color: var(--success-color) !important;
}

.validation-message {
    font-size: 0.8rem;
    margin-top: 4px;
    padding: 4px 8px;
    border-radius: 4px;
}

.validation-error {
    color: var(--error-color);
    background: #fef2f2;
}

.validation-warning {
    color: var(--warning-color);
    background: #fef3c7;
}

.validation-success {
    color: var(--success-color);
    background: #dcfce7;
}

/* Mode toggle switch */
.mode-toggle {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: var(--bg-color);
    border-radius: 6px;
    margin-bottom: 16px;
}

.mode-toggle label {
    font-weight: 500;
}

.toggle-switch {
    position: relative;
    width: 50px;
    height: 26px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: 0.3s;
    border-radius: 26px;
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 20px;
    width: 20px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.3s;
    border-radius: 50%;
}

input:checked + .toggle-slider {
    background-color: var(--primary-color);
}

input:checked + .toggle-slider:before {
    transform: translateX(24px);
}

/* Collapsible sections */
.collapsible-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    padding: 8px 0;
}

.collapsible-header:hover {
    color: var(--primary-color);
}

.collapsible-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease-out;
}

.collapsible-content.expanded {
    max-height: 2000px;
}

/* Spec comparison badge */
.spec-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 600;
    margin-left: 8px;
}

.spec-badge.match {
    background: #dcfce7;
    color: #166534;
}

.spec-badge.mismatch {
    background: #fee2e2;
    color: #991b1b;
}

.spec-badge.warning {
    background: #fef3c7;
    color: #92400e;
}

/* Manual override indicator */
.manual-indicator {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 0.8rem;
    color: var(--primary-color);
    margin-left: 8px;
}

/* Comparison table */
.comparison-row {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 8px;
    padding: 8px 0;
    border-bottom: 1px solid var(--border-color);
    font-size: 0.9rem;
}

.comparison-row.header {
    font-weight: 600;
    background: var(--bg-color);
    padding: 8px;
    border-radius: 4px;
}

/* ---- Coping Score Tooltip ---- */
.coping-card {
    position: relative;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
}
.coping-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}
.coping-card .coping-tooltip {
    visibility: hidden;
    opacity: 0;
    position: absolute;
    bottom: calc(100% + 8px);
    left: 50%;
    transform: translateX(-50%);
    width: 260px;
    padding: 10px 12px;
    background: var(--card-bg, #fff);
    border: 1px solid var(--border-color, #e2e8f0);
    border-radius: 8px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.18);
    font-size: 0.75rem;
    line-height: 1.5;
    color: var(--text-color, #1e293b);
    z-index: 100;
    transition: opacity 0.2s, visibility 0.2s;
    pointer-events: none;
    text-align: left;
}
.coping-card .coping-tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: var(--border-color, #e2e8f0);
}
.coping-card:hover .coping-tooltip {
    visibility: visible;
    opacity: 1;
}

/* ---- Coping Modal ---- */
.coping-modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 9999;
    justify-content: center;
    align-items: flex-start;
    padding: 40px 16px;
    overflow-y: auto;
}
.coping-modal-overlay.active { display: flex; }
.coping-modal {
    background: var(--card-bg, #fff);
    border-radius: 12px;
    max-width: 720px;
    width: 100%;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    animation: modalSlideIn 0.25s ease-out;
}
@keyframes modalSlideIn {
    from { opacity: 0; transform: translateY(-20px); }
    to { opacity: 1; transform: translateY(0); }
}
/* PDF export spinner overlay */
.pdf-spinner-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.45);
    z-index: 99999;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    gap: 16px;
}
.pdf-spinner-overlay.active { display: flex; }
.pdf-spinner-ring {
    width: 48px; height: 48px;
    border: 5px solid rgba(255,255,255,0.3);
    border-top-color: #fff;
    border-radius: 50%;
    animation: pdfSpin 0.8s linear infinite;
}
@keyframes pdfSpin { to { transform: rotate(360deg); } }
.pdf-spinner-text {
    color: #fff;
    font-size: 1rem;
    font-weight: 600;
    letter-spacing: 0.03em;
}
.coping-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    border-bottom: 1px solid var(--border-color, #e2e8f0);
}
.coping-modal-header h3 { margin: 0; font-size: 1.1rem; }
.coping-modal-close {
    background: none;
    border: none;
    font-size: 1.4rem;
    cursor: pointer;
    color: var(--text-muted, #94a3b8);
    padding: 4px 8px;
    border-radius: 4px;
}
.coping-modal-close:hover { background: var(--bg-color, #f1f5f9); }
.coping-modal-body {
    padding: 16px 20px;
    max-height: 70vh;
    overflow-y: auto;
    font-size: 0.88rem;
    line-height: 1.7;
}
.coping-modal-body h4 {
    margin: 16px 0 6px;
    font-size: 0.95rem;
    color: var(--primary-color, #2563eb);
}
.coping-modal-body h4:first-child { margin-top: 0; }
.coping-modal-body .tier-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    margin-right: 4px;
}
.coping-modal-body .tier-1 { background: #dcfce7; color: #166534; }
.coping-modal-body .tier-2 { background: #fef9c3; color: #854d0e; }
.coping-modal-body .tier-3 { background: #f1f5f9; color: #475569; }
.coping-modal-body .combo-safe { color: #16a34a; font-weight: 600; }
.coping-modal-body .combo-danger { color: #dc2626; font-weight: 600; }
.coping-modal-body .score-bar {
    height: 10px;
    border-radius: 5px;
    background: #e2e8f0;
    margin: 8px 0;
    overflow: hidden;
}
.coping-modal-body .score-bar-fill {
    height: 100%;
    border-radius: 5px;
    transition: width 0.4s ease-out;
}

    </style>
</head>
<body>
    <!-- Theme Toggle -->
    <button class="theme-toggle no-print" onclick="PVCalculator.toggleTheme()" title="Toggle Dark/Light Mode" id="themeToggleBtn">&#9790;</button>

    <div class="container">
        <header>
            <h1>Advanced PV System Calculator</h1>
            <p>Production-ready off-grid solar system design with comprehensive validation</p>
        </header>

        <div class="main-grid">
            <!-- LEFT COLUMN: INPUT FORMS -->
            <div class="input-column">

                <!-- SYSTEM CONFIGURATION -->
                <div class="card">
                    <h2>System Configuration</h2>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="location">Location Profile</label>
                            <select id="location" onchange="PVCalculator.applyLocationDefaults()">
                                <option value="lagos">Lagos, Nigeria</option>
                                <option value="generic">Generic (Global)</option>
                                <option value="temperate">Temperate Climate</option>
                                <option value="desert">Desert/High Solar</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="systemType">System Type</label>
                            <select id="systemType" onchange="PVCalculator.onSystemTypeChange()">
                                <option value="off_grid">Off-Grid</option>
                                <option value="hybrid">Hybrid (Inverter with built-in MPPT)</option>
                                <option value="grid_tie">Grid-Tie</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row three">
                        <div class="form-group">
                            <label for="acVoltage">AC Voltage (V)</label>
                            <input type="number" id="acVoltage" value="230" min="100" max="480">
                        </div>
                        <div class="form-group">
                            <label for="avgPSH">Peak Sun Hours</label>
                            <input type="number" id="avgPSH" value="4.5" step="0.1" min="2" max="8">
                        </div>
                        <div class="form-group">
                            <label for="autonomyDays">Autonomy Days</label>
                            <input type="number" id="autonomyDays" value="2" step="0.5" min="0.5" max="10">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="ambientTempMin">Min Temperature (C)</label>
                            <input type="number" id="ambientTempMin" value="20" min="-40" max="60">
                        </div>
                        <div class="form-group">
                            <label for="ambientTempMax">Max Temperature (C)</label>
                            <input type="number" id="ambientTempMax" value="35" min="-40" max="60">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="designMargin">Design Margin (%)</label>
                            <input type="number" id="designMargin" value="125" min="100" max="200">
                            <small>NEC requires 125% for continuous loads</small>
                        </div>
                        <div class="form-group">
                            <label for="inverterSurgeMultiplier">Inverter Surge Multiplier</label>
                            <input type="number" id="inverterSurgeMultiplier" value="2.0" step="0.1" min="1.5" max="5">
                            <small>Typical: 2.0x rated capacity</small>
                        </div>
                    </div>
                </div>

                <!-- APPLIANCE INPUT -->
                <div class="card">
                    <h2>Add Appliance</h2>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="appName">Appliance Name</label>
                            <input type="text" id="appName" placeholder="e.g., Refrigerator" oninput="PVCalculator.autoDetectAppliance()">
                            <small>Start typing — auto-detects common appliances</small>
                            <div id="appAutoHint" style="display:none; margin-top:6px; padding:8px 12px; background:#eff6ff; border-left:3px solid #3b82f6; border-radius:4px; font-size:0.84rem; color:#1e40af;"></div>
                        </div>
                        <div class="form-group">
                            <label for="appQuantity">Quantity</label>
                            <input type="number" id="appQuantity" value="1" min="1" max="100">
                        </div>
                    </div>

                    <div class="form-row three">
                        <div class="form-group">
                            <label for="appPower">Power (Watts)</label>
                            <input type="number" id="appPower" placeholder="e.g., 150" min="1">
                            <small>Running wattage from nameplate. NOT startup watts.</small>
                        </div>
                        <div class="form-group">
                            <label for="appHours">Daily Hours</label>
                            <input type="number" id="appHours" value="8" step="0.5" min="0" max="24">
                            <small>Total hours appliance runs per day</small>
                        </div>
                        <div class="form-group">
                            <label for="appDutyCycle">Duty Cycle (%)</label>
                            <input type="number" id="appDutyCycle" value="100" min="1" max="100">
                            <small>% of time ON when running. Fridge ~40%, Iron ~50%, Pump 100%</small>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="appLoadType">Load Type</label>
                            <select id="appLoadType" onchange="PVCalculator.updateLoadTypeDefaults()">
                                <option value="resistive">Resistive (Heaters, Lights)</option>
                                <option value="electronic">Electronic (LED, Computers)</option>
                                <option value="motor">Motor (Pumps, AC, Fridge)</option>
                                <option value="mixed">Mixed</option>
                            </select>
                            <small>Auto-detected from name. Motor = pumps/AC/fans. Electronic = TV/PC/LED</small>
                        </div>
                        <div class="form-group" style="display:none;">
                            <label for="appMotorSubType">Motor Sub-Type <span style="color: var(--error-color);">*</span></label>
                            <select id="appMotorSubType" onchange="PVCalculator.onMotorSubTypeChange()">
                                <option value="">— Select motor type —</option>
                                <option value="clutch">Clutch Motor (common, affordable)</option>
                                <option value="servo">Servo Motor (efficient, low surge)</option>
                                <option value="compressor">Compressor (fridge/freezer/AC)</option>
                                <option value="pump">Pump Motor</option>
                                <option value="fan">Fan/Blower</option>
                                <option value="general">General Motor</option>
                            </select>
                            <small id="motorSubTypeHint">Required for motors. Clutch vs Servo directly affects sizing.</small>
                        </div>
                        <div class="form-group" style="display:none;">
                            <label for="appStartMethod">Motor Start Method</label>
                            <select id="appStartMethod" onchange="PVCalculator.onStartMethodChange()">
                                <option value="dol">Direct On Line (DOL)</option>
                                <option value="soft_start">Soft Start</option>
                                <option value="vfd">VFD/Inverter Drive</option>
                            </select>
                            <small>DOL = direct start (high surge). Soft-start = gradual (3x). VFD = inverter drive (1.5x)</small>
                        </div>
                    </div>

                    <div class="form-row three">
                        <div class="form-group">
                            <label for="appSurgeFactor">Surge Factor</label>
                            <input type="number" id="appSurgeFactor" value="1" step="0.5" min="1" max="10">
                            <small>Startup multiplier. DOL motor: 5-6x. Soft-start: 3x. VFD: 1.5x. Resistive: 1x</small>
                        </div>
                        <div class="form-group">
                            <label for="appPowerFactor">Power Factor</label>
                            <input type="number" id="appPowerFactor" value="1.0" step="0.05" min="0.5" max="1">
                            <small>Motor: 0.6-0.8. Electronic: 0.9-0.95. Resistive: 1.0</small>
                        </div>
                        <div class="form-group">
                            <label for="appDaytimeRatio">Daytime Usage (%)</label>
                            <input type="number" id="appDaytimeRatio" value="50" min="0" max="100">
                            <small>% used during sun hours (6am-6pm). Lights: 10%, Office: 80%</small>
                        </div>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="appSimultaneous" checked>
                        <label for="appSimultaneous">Runs simultaneously with other loads</label>
                    </div>

                    <div class="btn-group">
                        <button class="btn btn-primary" id="addApplianceBtn" onclick="PVCalculator.addAppliance()">Add Appliance</button>
                        <button class="btn btn-secondary" onclick="PVCalculator.loadSampleAppliances()">Load Sample Set</button>
                    </div>
                </div>

                <!-- APPLIANCE LIST -->
                <div class="card">
                    <h2>Appliance List</h2>
                    <div id="applianceListContainer">
                        <p class="text-muted">No appliances added yet.</p>
                    </div>
                    <div class="btn-group" style="margin-top: 12px;">
                        <button class="btn btn-secondary btn-small" onclick="PVCalculator.clearAllAppliances()">Clear All</button>
                        <button class="btn btn-secondary btn-small" onclick="PVCalculator.saveToLocalStorage()">Save to Browser</button>
                        <button class="btn btn-secondary btn-small" onclick="PVCalculator.loadFromLocalStorage()">Load Saved</button>
                    </div>
                </div>

                <!-- UPGRADE SIMULATOR (Phase 10) -->
                <div class="card">
                    <h2>Upgrade Simulator</h2>
                    <p style="color: var(--text-muted); margin-bottom: 12px;">Simulate adding a new load to see if current system can handle it.</p>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="simAppName">New Appliance</label>
                            <input type="text" id="simAppName" placeholder="e.g., Air Conditioner">
                        </div>
                        <div class="form-group">
                            <label for="simAppPower">Power (W)</label>
                            <input type="number" id="simAppPower" placeholder="e.g., 1500" min="1">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="simAppHours">Daily Hours</label>
                            <input type="number" id="simAppHours" value="4" min="0.5" max="24" step="0.5">
                        </div>
                        <div class="form-group">
                            <label for="simAppType">Load Type</label>
                            <select id="simAppType">
                                <option value="resistive">Resistive</option>
                                <option value="electronic">Electronic</option>
                                <option value="motor">Motor</option>
                            </select>
                        </div>
                    </div>
                    <button class="btn btn-secondary" onclick="PVCalculator.simulateUpgrade()">Simulate Addition</button>
                    <div id="upgradeSimResults" class="hidden" style="margin-top: 16px;"></div>
                </div>

                <!-- EQUIPMENT SPECS -->
                <div class="card">
                    <h2>Equipment Specifications</h2>

                    <!-- Mode Toggle -->
                    <div class="mode-toggle">
                        <label>Mode:</label>
                        <span>Auto-Suggest</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="manualMode" onchange="PVCalculator.toggleManualMode()">
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Manual Input</span>
                        <small style="margin-left: auto; color: var(--text-muted);">Manual mode validates your equipment against load requirements</small>
                    </div>
                    <div id="expertModeSection" class="hidden" style="margin-top: 8px;">
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input type="checkbox" id="expertMode" onchange="PVCalculator.onExpertModeChange()">
                            <span style="font-size: 0.85rem;"><strong>Expert Mode:</strong> Suppress auto-rec hard blocks (inverter sizing, auto Voc). Your manual specs are validated instead. <span style="color: var(--error-color);">Use at your own risk.</span></span>
                        </label>
                    </div>

                    <h3>Solar Panel <span id="panelValidationBadge"></span></h3>
                    <div class="form-row three">
                        <div class="form-group">
                            <label for="panelWattage">Wattage (Wp)</label>
                            <input type="number" id="panelWattage" value="400" min="50" max="800" oninput="PVCalculator.autoSuggestPanelSpecs()">
                        </div>
                        <div class="form-group">
                            <label for="panelVmp">Vmp (V)</label>
                            <input type="number" id="panelVmp" value="41" step="0.1" min="1" oninput="PVCalculator.validatePanelSpecs()">
                        </div>
                        <div class="form-group">
                            <label for="panelVoc">Voc (V)</label>
                            <input type="number" id="panelVoc" value="49" step="0.1" min="1" oninput="PVCalculator.validatePanelSpecs()">
                        </div>
                    </div>
                    <div class="form-row three">
                        <div class="form-group">
                            <label for="panelImp">Imp (A)</label>
                            <input type="number" id="panelImp" value="9.76" step="0.01" min="0.1" oninput="PVCalculator.validatePanelSpecs()">
                        </div>
                        <div class="form-group">
                            <label for="panelIsc">Isc (A)</label>
                            <input type="number" id="panelIsc" value="10.36" step="0.01" min="0.1" oninput="PVCalculator.validatePanelSpecs()">
                        </div>
                        <div class="form-group">
                            <label for="panelTempCoeffPmax">Temp Coeff Pmax (%/C)</label>
                            <input type="number" id="panelTempCoeffPmax" value="-0.35" step="0.01" max="0">
                            <small>Power derating per degree (typical: -0.35 to -0.45)</small>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="panelTempCoeffVoc">Temp Coeff Voc (%/C)</label>
                            <input type="number" id="panelTempCoeffVoc" value="-0.27" step="0.01" max="0">
                        </div>
                        <div class="form-group">
                            <div id="panelValidationMsg"></div>
                        </div>
                    </div>

                    <!-- MPPT / Inverter PV Input Section - always visible -->
                    <div id="mpptSection">
                        <h3>MPPT / Inverter PV Input Specs <span id="mpptHybridNote" class="hidden" style="font-size: 0.85rem; color: var(--warning-color); font-weight: 500;">(Built-in to Hybrid Inverter - enter its MPPT specs below)</span></h3>
                        <small style="display: block; margin-bottom: 10px; color: var(--text-muted);">Enter from your inverter/MPPT datasheet. These limits determine safe panel configurations.</small>
                        <div class="form-row three">
                            <div class="form-group">
                                <label for="mpptMaxVoltage">Max Open Circuit Voltage - Voc Limit (V)</label>
                                <input type="number" id="mpptMaxVoltage" value="500" min="30" oninput="PVCalculator.validateMPPT()">
                                <small>Absolute max Voc the input can handle</small>
                            </div>
                            <div class="form-group">
                                <label for="mpptMaxCurrent">Max PV Input Current (A)</label>
                                <input type="number" id="mpptMaxCurrent" value="27" min="1" oninput="PVCalculator.validateMPPT()">
                                <small>Max DC current from panels</small>
                            </div>
                            <div class="form-group">
                                <label for="mpptMaxPower">Max PV Input Power (W)</label>
                                <input type="number" id="mpptMaxPower" value="7500" min="100" oninput="PVCalculator.validateMPPT()">
                                <small>Total max watts from array</small>
                            </div>
                        </div>
                        <div class="form-row three">
                            <div class="form-group">
                                <label for="mpptMinVoltage">Min Startup Voltage (V)</label>
                                <input type="number" id="mpptMinVoltage" value="95" min="10" oninput="PVCalculator.validateMPPT()">
                                <small>Min voltage to begin tracking</small>
                            </div>
                            <div class="form-group">
                                <label for="mpptMaxOperatingVoltage">Max MPPT Operating Voltage (V)</label>
                                <input type="number" id="mpptMaxOperatingVoltage" value="450" min="30" oninput="PVCalculator.validateMPPT()">
                                <small>Upper Vmp working range</small>
                            </div>
                            <div class="form-group">
                                <label for="mpptMaxChargeCurrent">Max Solar Charge Current (A)</label>
                                <input type="number" id="mpptMaxChargeCurrent" value="120" min="5">
                                <small>Max amps to battery from PV</small>
                            </div>
                        </div>
                        <div class="form-row three">
                            <div class="form-group">
                                <label for="mpptInputCount">Number of MPPT Inputs</label>
                                <select id="mpptInputCount" onchange="PVCalculator.toggleMultiMPPT()">
                                    <option value="1">1 (Single MPPT)</option>
                                    <option value="2">2 (Dual MPPT)</option>
                                    <option value="3">3 (Triple MPPT)</option>
                                </select>
                                <small>How many independent PV inputs</small>
                            </div>
                        </div>

                        <!-- Additional MPPT Specs (shown when count > 1) -->
                        <div id="mpptAdditionalSection" class="hidden" style="margin-top: 12px; padding: 12px; border: 1px dashed var(--warning-color); border-radius: 8px; background: rgba(245,158,11,0.03);">
                            <div id="mpptAdditionalNote" style="font-size: 0.85rem; color: var(--warning-color); margin-bottom: 10px; font-weight: 500;">
                                The specs above apply to MPPT 1 (primary / built-in). Enter specs for additional MPPT(s) below.
                            </div>

                            <!-- MPPT 2 -->
                            <div id="mppt2Section">
                                <h4 style="margin: 8px 0 6px; color: var(--primary-color);">MPPT 2 <span style="font-weight: normal; font-size: 0.85rem; color: var(--text-muted);">(External or Secondary Input)</span></h4>
                                <div class="form-row three">
                                    <div class="form-group">
                                        <label for="mppt2MaxVoltage">Max Voc Limit (V)</label>
                                        <input type="number" id="mppt2MaxVoltage" value="500" min="30">
                                    </div>
                                    <div class="form-group">
                                        <label for="mppt2MaxCurrent">Max PV Input Current (A)</label>
                                        <input type="number" id="mppt2MaxCurrent" value="18" min="1">
                                    </div>
                                    <div class="form-group">
                                        <label for="mppt2MaxPower">Max PV Input Power (W)</label>
                                        <input type="number" id="mppt2MaxPower" value="3000" min="100">
                                    </div>
                                </div>
                                <div class="form-row three">
                                    <div class="form-group">
                                        <label for="mppt2MinVoltage">Min Startup Voltage (V)</label>
                                        <input type="number" id="mppt2MinVoltage" value="60" min="10">
                                    </div>
                                    <div class="form-group">
                                        <label for="mppt2MaxOperatingVoltage">Max Operating Voltage (V)</label>
                                        <input type="number" id="mppt2MaxOperatingVoltage" value="450" min="30">
                                    </div>
                                    <div class="form-group">
                                        <label for="mppt2MaxChargeCurrent">Max Charge Current (A)</label>
                                        <input type="number" id="mppt2MaxChargeCurrent" value="60" min="5">
                                    </div>
                                </div>
                            </div>

                            <!-- MPPT 3 (shown only when count >= 3) -->
                            <div id="mppt3Section" class="hidden">
                                <h4 style="margin: 12px 0 6px; color: var(--primary-color);">MPPT 3 <span style="font-weight: normal; font-size: 0.85rem; color: var(--text-muted);">(Third Input)</span></h4>
                                <div class="form-row three">
                                    <div class="form-group">
                                        <label for="mppt3MaxVoltage">Max Voc Limit (V)</label>
                                        <input type="number" id="mppt3MaxVoltage" value="500" min="30">
                                    </div>
                                    <div class="form-group">
                                        <label for="mppt3MaxCurrent">Max PV Input Current (A)</label>
                                        <input type="number" id="mppt3MaxCurrent" value="18" min="1">
                                    </div>
                                    <div class="form-group">
                                        <label for="mppt3MaxPower">Max PV Input Power (W)</label>
                                        <input type="number" id="mppt3MaxPower" value="3000" min="100">
                                    </div>
                                </div>
                                <div class="form-row three">
                                    <div class="form-group">
                                        <label for="mppt3MinVoltage">Min Startup Voltage (V)</label>
                                        <input type="number" id="mppt3MinVoltage" value="60" min="10">
                                    </div>
                                    <div class="form-group">
                                        <label for="mppt3MaxOperatingVoltage">Max Operating Voltage (V)</label>
                                        <input type="number" id="mppt3MaxOperatingVoltage" value="450" min="30">
                                    </div>
                                    <div class="form-group">
                                        <label for="mppt3MaxChargeCurrent">Max Charge Current (A)</label>
                                        <input type="number" id="mppt3MaxChargeCurrent" value="60" min="5">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Panel Count (visible in both modes) -->
                    <div id="panelCountSection" style="margin-top: 12px; padding: 10px; border: 1px dashed var(--border-color); border-radius: 8px; background: rgba(37,99,235,0.02);">
                        <div class="form-row three">
                            <div class="form-group">
                                <label for="pvDesiredCount">Number of Panels <span style="color: var(--text-muted); font-weight: normal;">(Optional)</span></label>
                                <input type="number" id="pvDesiredCount" placeholder="Auto-calculate" min="1" max="100">
                                <small>Leave empty to auto-calculate from load, or enter how many panels you have/want</small>
                            </div>
                            <div class="form-group" id="pvDesiredCountInfo" style="padding-top: 22px; font-size: 0.85rem; color: var(--text-muted);"></div>
                        </div>
                    </div>

                    <div id="pvDaytimeLoadSection" style="margin-top: 12px; padding: 10px; border: 1px dashed var(--border-color); border-radius: 8px; background: rgba(37,99,235,0.02);">
                        <div class="form-row">
                            <div class="form-group" style="flex: 1;">
                                <label style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" id="pvAccountForDaytimeLoad" checked style="width: 16px; height: 16px;">
                                    <span>Size PV array to also power daytime loads</span>
                                </label>
                                <small>When enabled, panel count includes power for appliances running during sun hours (recommended).
                                When disabled, panels only charge batteries — heavy daytime use will drain the battery even during sunshine.</small>
                            </div>
                        </div>
                    </div>

                    <!-- Inverter Manual Input (shown in manual mode) -->
                    <div id="inverterManualSection" class="hidden">
                        <h3>Inverter Specifications <span class="manual-indicator">Manual Override</span></h3>
                        <div class="form-row three">
                            <div class="form-group">
                                <label for="inverterManualVA">Inverter Size (VA)</label>
                                <input type="number" id="inverterManualVA" placeholder="e.g., 5000" min="300">
                                <small>Leave empty to auto-calculate</small>
                            </div>
                            <div class="form-group">
                                <label for="inverterManualVoltage">DC Voltage (V)</label>
                                <select id="inverterManualVoltage">
                                    <option value="auto">Auto-select</option>
                                    <option value="12">12V</option>
                                    <option value="24">24V</option>
                                    <option value="48">48V</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="inverterHasBuiltinMPPT">Has Built-in MPPT?</label>
                                <select id="inverterHasBuiltinMPPT" onchange="PVCalculator.toggleMPPTSection()">
                                    <option value="no">No (Separate MPPT)</option>
                                    <option value="yes">Yes (Hybrid Inverter)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <h3>Battery <span id="batteryManualIndicator" class="manual-indicator hidden">Manual Override</span></h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="batteryChemistry">Chemistry</label>
                            <select id="batteryChemistry" onchange="PVCalculator.onBatteryChemistryChange()">
                                <option value="lifepo4">LiFePO4 (Lithium Iron Phosphate)</option>
                                <option value="agm">AGM Lead Acid</option>
                                <option value="gel">Gel Lead Acid</option>
                                <option value="fla">Flooded Lead Acid</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="batteryUnitAh">Battery Unit Capacity (Ah)</label>
                            <div style="display: flex; gap: 6px; align-items: center;">
                                <select id="batteryUnitAh" style="flex: 1;" onchange="PVCalculator.onBatteryUnitAhChange()">
                                    <option value="auto">Auto-select</option>
                                    <option value="100">100 Ah</option>
                                    <option value="200" selected>200 Ah</option>
                                    <option value="220">220 Ah</option>
                                    <option value="230">230 Ah</option>
                                    <option value="custom">Custom...</option>
                                </select>
                                <input type="number" id="batteryUnitAhCustom" placeholder="e.g. 150" min="10" max="1000" step="1" style="flex: 0.7; display: none;" oninput="PVCalculator.onBatteryCustomAhInput()">
                            </div>
                            <small>Select a standard size or enter a custom Ah value</small>
                        </div>
                        <div class="form-group">
                            <label for="batteryUnitVoltage">Battery Unit Voltage (V)</label>
                            <div style="display: flex; gap: 6px; align-items: center;">
                                <select id="batteryUnitVoltage" style="flex: 1;" onchange="PVCalculator.onBatteryUnitVoltageChange()">
                                    <option value="12" selected>12V (Standard)</option>
                                    <option value="6">6V</option>
                                    <option value="2">2V (Cell-level)</option>
                                    <option value="24">24V</option>
                                    <option value="48">48V (Single unit)</option>
                                    <option value="custom">Custom...</option>
                                </select>
                                <input type="number" id="batteryUnitVoltageCustom" placeholder="e.g. 3.2" min="1" max="60" step="0.1" style="flex: 0.7; display: none;" oninput="PVCalculator.onBatteryCustomVoltageInput()">
                            </div>
                            <small>Voltage per battery unit (12V most common)</small>
                        </div>
                    </div>
                    <div class="form-row" style="margin-top: 4px;">
                        <div class="form-group" style="flex: 0.5;">
                            <label for="batteryUnitCount">Number of Battery Units <span style="font-size: 0.8em; color: var(--text-muted);">(optional)</span></label>
                            <input type="number" id="batteryUnitCount" placeholder="Auto" min="1" max="20" step="1">
                            <small>Leave blank to auto-calculate. Enter to override (e.g., 1 for single unit, 2 for two parallel).</small>
                        </div>
                        <div class="form-group" style="flex: 0.5;">
                            <div id="batteryUnitCountNote" style="padding-top: 22px; font-size: 0.82rem; color: var(--text-muted);"></div>
                        </div>
                    </div>
                    <!-- Lithium kWh input — shown when LiFePO4 is selected (optional for auto, useful for manual) -->
                    <div id="lithiumKwhSection" class="form-row" style="margin-top: 4px;">
                        <div class="form-group">
                            <label for="batteryKwhInput">Battery Rating in kWh <span style="font-size: 0.8em; color: var(--text-muted);">(optional)</span></label>
                            <input type="number" id="batteryKwhInput" placeholder="e.g., 5.12" min="0.1" step="0.01" oninput="PVCalculator.onBatteryKwhInput()">
                            <small>Lithium batteries are often rated in kWh. Enter here to auto-calculate Ah based on your selected voltage.</small>
                        </div>
                        <div class="form-group" style="flex: 0.6;">
                            <label>Equivalent Ah</label>
                            <div id="batteryKwhToAhResult" style="padding: 8px 12px; background: var(--bg-color); border: 1px solid var(--border-color); border-radius: 6px; font-weight: 600; min-height: 20px;">&mdash;</div>
                            <small>Auto-calculated from kWh &div; bank voltage</small>
                        </div>
                    </div>
                    <!-- Battery Manual Input (shown in manual mode) -->
                    <div id="batteryManualSection" class="hidden">
                        <div class="form-row three">
                            <div class="form-group">
                                <label for="batteryManualKwh">Capacity (kWh)</label>
                                <input type="number" id="batteryManualKwh" placeholder="e.g., 7.2" min="0.1" step="0.1" oninput="PVCalculator.convertBatteryKwhToAh()">
                                <small>Enter kWh — Ah auto-fills below</small>
                            </div>
                            <div class="form-group">
                                <label for="batteryManualAh">Capacity (Ah)</label>
                                <input type="number" id="batteryManualAh" placeholder="e.g., 200" min="10" oninput="PVCalculator.convertBatteryAhToKwh()">
                                <small>Or enter Ah directly</small>
                            </div>
                            <div class="form-group">
                                <label for="batteryManualVoltage">Bank Voltage (V)</label>
                                <select id="batteryManualVoltage" onchange="PVCalculator.convertBatteryKwhToAh()">
                                    <option value="auto">Auto (match inverter)</option>
                                    <option value="12">12V</option>
                                    <option value="24">24V</option>
                                    <option value="48">48V</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-row three">
                            <div class="form-group">
                                <label for="batteryManualStrings">Parallel Strings</label>
                                <input type="number" id="batteryManualStrings" placeholder="Auto" min="1" max="10">
                            </div>
                            <div class="form-group">
                                <div id="batteryConversionNote" style="font-size: 0.82rem; color: var(--text-muted); padding-top: 22px;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- PV Manual Configuration (shown in manual mode) -->
                    <div id="pvManualSection" class="hidden">
                        <h3>Panel Configuration <span class="manual-indicator">Manual Override</span></h3>
                        <small style="display: block; margin-bottom: 10px; color: var(--text-muted);">Enter your actual panel layout. The calculator will validate voltage, current, and power limits against your MPPT/inverter specs.</small>
                        <div class="form-row three">
                            <div class="form-group">
                                <label for="pvManualCount">Total Number of Panels</label>
                                <input type="number" id="pvManualCount" placeholder="e.g., 8" min="1" max="100">
                                <small>How many panels you have</small>
                            </div>
                            <div class="form-group">
                                <label for="pvManualSeries">Panels in Series (per string)</label>
                                <input type="number" id="pvManualSeries" placeholder="e.g., 8" min="1" max="50">
                                <small>Panels wired + to - in a row</small>
                            </div>
                            <div class="form-group">
                                <label for="pvManualParallel">Strings in Parallel</label>
                                <input type="number" id="pvManualParallel" placeholder="e.g., 1" min="1" max="20">
                                <small>Parallel strings (combined +)</small>
                            </div>
                        </div>
                        <div class="form-row three" style="margin-top: 8px;">
                            <div class="form-group">
                                <label for="pvMismatchEnabled">Mixed Panel Wattages?</label>
                                <select id="pvMismatchEnabled" onchange="PVCalculator.toggleMismatchDetails()">
                                    <option value="no">No — All panels same wattage</option>
                                    <option value="yes">Yes — Mixed wattages in array</option>
                                </select>
                                <small>Select if panels have different Wp ratings</small>
                            </div>
                        </div>
                        <div id="pvMismatchSection" class="hidden" style="margin-top: 8px;">
                            <div class="form-group">
                                <label for="pvMismatchList">Panel Wattages (comma-separated)</label>
                                <input type="text" id="pvMismatchList" placeholder="e.g., 190,190,190,190,190,180,200,200,200" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);" oninput="PVCalculator.analyzePanelMismatch()">
                                <small>List each panel's wattage. Example: 5x190W + 1x180W + 3x200W = "190,190,190,190,190,180,200,200,200"</small>
                            </div>
                            <div id="pvMismatchAnalysis" style="margin-top: 8px;"></div>
                        </div>
                        <div id="pvManualValidation" style="margin-top: 8px;"></div>
                    </div>

                    <!-- Breaker Manual Input (shown in manual mode) -->
                    <div id="breakerManualSection" class="hidden">
                        <h3>Protection Devices <span class="manual-indicator">Manual Override</span></h3>
                        <small style="display: block; margin-bottom: 10px; color: var(--text-muted);">Enter your breaker/MCCB ratings. Leave empty to auto-calculate based on load and equipment specs.</small>
                        <div class="form-row three">
                            <div class="form-group">
                                <label for="breakerPVDC">PV DC Isolator / Breaker (A)</label>
                                <input type="number" id="breakerPVDC" placeholder="Auto" min="1">
                                <small>DC side, PV array</small>
                            </div>
                            <div class="form-group">
                                <label for="breakerBattDC">Battery DC MCCB (A)</label>
                                <input type="number" id="breakerBattDC" placeholder="Auto" min="1">
                                <small>DC side, battery to inverter</small>
                            </div>
                            <div class="form-group">
                                <label for="breakerAC">AC Output MCB (A)</label>
                                <input type="number" id="breakerAC" placeholder="Auto" min="1">
                                <small>AC side, inverter output</small>
                            </div>
                        </div>
                    </div>

                    <!-- Grid/Utility Charging Parameters (Hybrid Only) -->
                    <div id="gridChargingSection" class="hidden">
                        <h3>Grid/Utility Charging <span style="font-size: 0.75rem; color: var(--text-muted);">(Hybrid Mode)</span></h3>
                        <small style="display: block; margin-bottom: 10px; color: var(--text-muted);">Optional: Enter your hybrid inverter's grid charging specs. Affects battery charge time estimates and advisory.</small>
                        <div class="form-row three">
                            <div class="form-group">
                                <label for="gridMaxChargeA">Max Grid Charge Current (A)</label>
                                <input type="number" id="gridMaxChargeA" placeholder="e.g., 100" min="1" max="200">
                                <small>From inverter spec sheet (e.g., 100A for Felicity 6kVA)</small>
                            </div>
                            <div class="form-group">
                                <label for="gridChargeRegMin">Min Adjustable Current (A)</label>
                                <input type="number" id="gridChargeRegMin" placeholder="e.g., 10" min="1" max="100" value="10">
                                <small>Charge current regulation range start</small>
                            </div>
                            <div class="form-group">
                                <label for="gridInputVoltageRange">Input Voltage Range (VAC)</label>
                                <input type="text" id="gridInputVoltageRange" placeholder="e.g., 90-280" value="90-280">
                                <small>Acceptable grid voltage range</small>
                            </div>
                        </div>
                    </div>

                    <h3>Cable Lengths</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="cablePVtoMPPT">PV to MPPT (m)</label>
                            <input type="number" id="cablePVtoMPPT" value="10" min="1">
                        </div>
                        <div class="form-group">
                            <label for="cableMPPTtoBatt">MPPT to Battery (m)</label>
                            <input type="number" id="cableMPPTtoBatt" value="2" min="0.5">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="cableBattToInv">Battery to Inverter (m)</label>
                            <input type="number" id="cableBattToInv" value="1.5" min="0.5">
                        </div>
                        <div class="form-group">
                            <label for="cableInvToLoad">Inverter to Load (m)</label>
                            <input type="number" id="cableInvToLoad" value="10" min="1">
                        </div>
                    </div>
                </div>

                <!-- CALCULATE BUTTON -->
                <div class="card no-print">
                    <button class="btn btn-primary" style="width: 100%; padding: 16px; font-size: 1.1rem;" onclick="PVCalculator.calculate()">
                        Calculate System Design
                    </button>
                </div>
            </div>

            <!-- RIGHT COLUMN: RESULTS -->
            <div class="results-column">
                <div id="resultsContainer">
                    <div class="card">
                        <h2>Results</h2>
                        <p class="text-muted">Add appliances and click "Calculate System Design" to see results.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
/* =============================================================================
   JAVASCRIPT - CENTRALIZED CONSTANTS (DEFAULTS)
   ============================================================================= */

const DEFAULTS = {
    // Location profiles with typical values
    LOCATIONS: {
        lagos: {
            name: 'Lagos, Nigeria',
            avgPSH: 4.5,
            ambientTempMin: 20,
            ambientTempMax: 35,
            acVoltage: 230
        },
        generic: {
            name: 'Generic (Global)',
            avgPSH: 4.5,
            ambientTempMin: -10,
            ambientTempMax: 45,
            acVoltage: 230
        },
        temperate: {
            name: 'Temperate Climate',
            avgPSH: 4.0,
            ambientTempMin: -15,
            ambientTempMax: 35,
            acVoltage: 230
        },
        desert: {
            name: 'Desert/High Solar',
            avgPSH: 6.5,
            ambientTempMin: 5,
            ambientTempMax: 50,
            acVoltage: 230
        }
    },

    // Battery chemistry specifications
    BATTERY_SPECS: {
        lifepo4: {
            name: 'LiFePO4',
            maxDoD: 0.80,
            cycleLife: 3000,
            chargeEfficiency: 0.97,
            dischargeEfficiency: 0.98,
            maxChargeRate: 0.50,
            maxDischargeRate: 1.00,
            selfDischargeDaily: 0.001,
            cellVoltage: 3.2,
            moduleVoltage: 51.2,   // Standard module: 16S × 3.2V
            cellsPerModule: 16
        },
        agm: {
            name: 'AGM Lead Acid',
            maxDoD: 0.50,
            cycleLife: 600,
            chargeEfficiency: 0.88,
            dischargeEfficiency: 0.92,
            maxChargeRate: 0.15,
            maxDischargeRate: 0.25,
            selfDischargeDaily: 0.002,
            cellVoltage: 2.0
        },
        gel: {
            name: 'Gel Lead Acid',
            maxDoD: 0.50,
            cycleLife: 700,
            chargeEfficiency: 0.87,
            dischargeEfficiency: 0.91,
            maxChargeRate: 0.10,
            maxDischargeRate: 0.20,
            selfDischargeDaily: 0.002,
            cellVoltage: 2.0
        },
        fla: {
            name: 'Flooded Lead Acid',
            maxDoD: 0.50,
            cycleLife: 500,
            chargeEfficiency: 0.85,
            dischargeEfficiency: 0.90,
            maxChargeRate: 0.10,
            maxDischargeRate: 0.20,
            selfDischargeDaily: 0.003,
            cellVoltage: 2.0
        }
    },

    // Load type defaults
    LOAD_TYPES: {
        resistive: { surgeFactor: 1.0, powerFactor: 1.0 },
        electronic: { surgeFactor: 1.2, powerFactor: 0.95 },
        motor: { surgeFactor: 6.0, powerFactor: 0.8 },
        mixed: { surgeFactor: 2.0, powerFactor: 0.9 }
    },

    // Motor start methods
    MOTOR_START_SURGE: {
        dol: 6.0,
        soft_start: 3.0,
        vfd: 1.5
    },

    // Motor sub-type characteristics
    MOTOR_SUBTYPES: {
        clutch:     { efficiency: 0.60, surgeFactor: 4.0, powerFactor: 0.70, startMethod: 'dol', hint: 'Clutch motor: affordable, rugged, 3-4x surge. Common in NG tailoring shops. Higher energy use than servo.' },
        servo:      { efficiency: 0.90, surgeFactor: 1.5, powerFactor: 0.85, startMethod: 'vfd', hint: 'Servo motor: 40-60% less energy than clutch, low surge (VFD). Ideal for PV systems. Cost: ~50k+ more.' },
        compressor: { efficiency: 0.85, surgeFactor: 5.0, powerFactor: 0.65, startMethod: 'dol', hint: 'Compressor motor (fridge/freezer/AC): heavy DOL surge 5-7x. Runs in cycles (thermostat). Never start two compressors together.' },
        pump:       { efficiency: 0.80, surgeFactor: 5.0, powerFactor: 0.70, startMethod: 'dol', hint: 'Pump motor: 5x DOL surge. Consider soft-start for pumps >750W to reduce surge by 40%.' },
        fan:        { efficiency: 0.85, surgeFactor: 3.0, powerFactor: 0.65, startMethod: 'dol', hint: 'Fan/blower: moderate surge 2-3x. Small fans are safe to run alongside other motors.' },
        general:    { efficiency: 0.85, surgeFactor: 5.0, powerFactor: 0.75, startMethod: 'dol', hint: 'General motor: assume worst-case DOL surge 5x. Specify sub-type for better accuracy.' }
    },

    // Appliance name auto-detection presets (keys are regex patterns)
    APPLIANCE_PRESETS: {
        // Motors with clutch/DOL — sewing machines (domestic first, industrial if wattage overridden)
        'sewing.*servo|servo.*sewing|servo.*machine': { watt: 250, loadType: 'motor', startMethod: 'vfd', surgeFactor: 1.5, powerFactor: 0.85, dutyCycle: 60, hours: 8, hint: 'Servo motor sewing machine. Low inrush (1.5x), ~90% efficient. Ideal for PV — uses 40-60% less energy than clutch. Cost: ~₦50k+ more than clutch.' },
        'industrial.*sew|sew.*industrial': { watt: 550, loadType: 'motor', startMethod: 'dol', surgeFactor: 4.0, powerFactor: 0.7, dutyCycle: 60, hours: 8, hint: 'Industrial sewing machine with clutch motor (400-750W, ½-1HP). DOL start with 4-7x inrush. Common in Lagos tailoring shops. Surge: 2000-5000VA peak for 1-2 seconds.' },
        'sewing|sew.*machine': { watt: 250, loadType: 'motor', startMethod: 'dol', surgeFactor: 4.0, powerFactor: 0.7, dutyCycle: 60, hours: 8, hint: 'Domestic sewing machine with clutch motor (~250W, ⅓HP). DOL start with 3-4x inrush. If your machine is industrial (400W+), change the wattage above — sizing will auto-adjust.' },
        'refrigerator|fridge': { watt: 150, loadType: 'motor', startMethod: 'dol', surgeFactor: 5.0, powerFactor: 0.65, dutyCycle: 40, hours: 24, hint: 'Compressor motor with DOL start. Runs ~40% of the time (thermostat cycling).' },
        'freezer|deep\\s*freeze': { watt: 200, loadType: 'motor', startMethod: 'dol', surgeFactor: 5.0, powerFactor: 0.65, dutyCycle: 45, hours: 24, hint: 'Compressor load. Higher duty cycle than fridge.' },
        'air\\s*condition|split\\s*unit|\\bac\\b|\\ba\\.c\\.': { watt: 1500, loadType: 'motor', startMethod: 'dol', surgeFactor: 5.0, powerFactor: 0.75, dutyCycle: 65, hours: 10, hint: 'AC compressor motor. Heavy startup surge (5-7x). Consider inverter AC for lower surge and better PV compatibility.' },
        'inverter\\s*ac|inverter\\s*air': { watt: 1200, loadType: 'motor', startMethod: 'vfd', surgeFactor: 1.5, powerFactor: 0.9, dutyCycle: 60, hours: 10, hint: 'Inverter AC uses VFD — much lower startup surge than conventional AC.' },
        'water\\s*pump|pump|borehole': { watt: 750, loadType: 'motor', startMethod: 'dol', surgeFactor: 5.0, powerFactor: 0.7, dutyCycle: 100, hours: 4, hint: 'Pump motor. DOL start gives 5x inrush. Consider soft-start for large pumps.' },
        'washing\\s*machine|washer': { watt: 500, loadType: 'motor', startMethod: 'dol', surgeFactor: 4.0, powerFactor: 0.75, dutyCycle: 80, hours: 2, hint: 'Motor with heating element. Spin cycle creates high surge.' },
        'ceiling\\s*fan|fan': { watt: 75, loadType: 'motor', startMethod: 'dol', surgeFactor: 3.0, powerFactor: 0.65, dutyCycle: 100, hours: 10, hint: 'Small AC motor. Moderate starting surge.' },
        'blender|grinder|mixer': { watt: 500, loadType: 'motor', startMethod: 'dol', surgeFactor: 5.0, powerFactor: 0.7, dutyCycle: 50, hours: 0.5, hint: 'Short burst motor load. High inrush, short run time.' },
        // Electronic loads
        'led|light|bulb|lamp': { watt: 10, loadType: 'electronic', startMethod: 'vfd', surgeFactor: 1.2, powerFactor: 0.9, dutyCycle: 100, hours: 6, hint: 'LED/electronic lighting. Low surge, good power factor.' },
        'tv|television': { watt: 100, loadType: 'electronic', startMethod: 'vfd', surgeFactor: 1.3, powerFactor: 0.95, dutyCycle: 100, hours: 5, hint: 'Modern TV (LCD/LED). Electronic SMPS power supply.' },
        'laptop|computer|desktop|pc': { watt: 80, loadType: 'electronic', startMethod: 'vfd', surgeFactor: 1.2, powerFactor: 0.95, dutyCycle: 100, hours: 8, hint: 'Computer with SMPS. Stable electronic load.' },
        'phone\\s*charger|charger': { watt: 20, loadType: 'electronic', startMethod: 'vfd', surgeFactor: 1.0, powerFactor: 0.9, dutyCycle: 100, hours: 3, hint: 'Small electronic charger. Minimal load.' },
        'router|modem|wifi': { watt: 15, loadType: 'electronic', startMethod: 'vfd', surgeFactor: 1.0, powerFactor: 0.95, dutyCycle: 100, hours: 24, hint: 'Always-on network equipment.' },
        'decoder|dstv|gotv': { watt: 25, loadType: 'electronic', startMethod: 'vfd', surgeFactor: 1.1, powerFactor: 0.9, dutyCycle: 100, hours: 8, hint: 'Set-top box. Small electronic load.' },
        // Resistive loads
        'iron|pressing': { watt: 1200, loadType: 'resistive', startMethod: 'dol', surgeFactor: 1.0, powerFactor: 1.0, dutyCycle: 50, hours: 2, hint: 'Heating element. Pure resistive, no surge. Thermostat cycles ~50%.' },
        'kettle|boiler|water\\s*heater': { watt: 2000, loadType: 'resistive', startMethod: 'dol', surgeFactor: 1.0, powerFactor: 1.0, dutyCycle: 100, hours: 0.5, hint: 'Heating element. High wattage but short usage time.' },
        'microwave': { watt: 1000, loadType: 'mixed', startMethod: 'dol', surgeFactor: 2.0, powerFactor: 0.9, dutyCycle: 100, hours: 0.5, hint: 'Magnetron + motor. Moderate surge from turntable motor.' },
        'toaster|sandwich\\s*maker': { watt: 800, loadType: 'resistive', startMethod: 'dol', surgeFactor: 1.0, powerFactor: 1.0, dutyCycle: 100, hours: 0.3, hint: 'Pure resistive heating element.' },
        'heater|space\\s*heater': { watt: 1500, loadType: 'resistive', startMethod: 'dol', surgeFactor: 1.0, powerFactor: 1.0, dutyCycle: 100, hours: 6, hint: 'Resistive heating element. No surge.' }
    },

    // Panel spec presets by wattage (typical industry values)
    PANEL_PRESETS: {
        50:  { vmp: 18.2, voc: 22.0, imp: 2.75, isc: 2.95, tempCoeffPmax: -0.40, tempCoeffVoc: -0.30 },
        100: { vmp: 18.4, voc: 22.5, imp: 5.43, isc: 5.75, tempCoeffPmax: -0.39, tempCoeffVoc: -0.29 },
        150: { vmp: 18.6, voc: 23.0, imp: 8.06, isc: 8.55, tempCoeffPmax: -0.38, tempCoeffVoc: -0.28 },
        200: { vmp: 24.5, voc: 30.2, imp: 8.16, isc: 8.68, tempCoeffPmax: -0.37, tempCoeffVoc: -0.28 },
        250: { vmp: 30.5, voc: 37.0, imp: 8.20, isc: 8.72, tempCoeffPmax: -0.37, tempCoeffVoc: -0.28 },
        300: { vmp: 32.8, voc: 39.8, imp: 9.15, isc: 9.72, tempCoeffPmax: -0.36, tempCoeffVoc: -0.27 },
        330: { vmp: 34.0, voc: 41.2, imp: 9.71, isc: 10.30, tempCoeffPmax: -0.36, tempCoeffVoc: -0.27 },
        350: { vmp: 35.2, voc: 42.5, imp: 9.94, isc: 10.55, tempCoeffPmax: -0.35, tempCoeffVoc: -0.27 },
        370: { vmp: 35.8, voc: 43.5, imp: 10.34, isc: 10.95, tempCoeffPmax: -0.35, tempCoeffVoc: -0.27 },
        400: { vmp: 41.0, voc: 49.0, imp: 9.76, isc: 10.36, tempCoeffPmax: -0.35, tempCoeffVoc: -0.27 },
        450: { vmp: 41.5, voc: 49.8, imp: 10.84, isc: 11.50, tempCoeffPmax: -0.34, tempCoeffVoc: -0.27 },
        500: { vmp: 42.0, voc: 50.5, imp: 11.90, isc: 12.65, tempCoeffPmax: -0.34, tempCoeffVoc: -0.26 },
        540: { vmp: 42.5, voc: 51.2, imp: 12.71, isc: 13.48, tempCoeffPmax: -0.34, tempCoeffVoc: -0.26 },
        550: { vmp: 42.8, voc: 51.5, imp: 12.85, isc: 13.63, tempCoeffPmax: -0.34, tempCoeffVoc: -0.26 },
        600: { vmp: 43.5, voc: 52.5, imp: 13.79, isc: 14.60, tempCoeffPmax: -0.33, tempCoeffVoc: -0.26 },
        700: { vmp: 44.0, voc: 53.5, imp: 15.91, isc: 16.85, tempCoeffPmax: -0.33, tempCoeffVoc: -0.25 }
    },

    // MPPT controller presets by inverter VA rating
    MPPT_PRESETS: {
        1000:  { maxVoltage: 145, maxCurrent: 18, maxPower: 1500, minVoltage: 30, maxOperating: 130, maxCharge: 30 },
        1500:  { maxVoltage: 145, maxCurrent: 18, maxPower: 2000, minVoltage: 30, maxOperating: 130, maxCharge: 40 },
        2000:  { maxVoltage: 145, maxCurrent: 18, maxPower: 2600, minVoltage: 30, maxOperating: 130, maxCharge: 50 },
        2400:  { maxVoltage: 250, maxCurrent: 18, maxPower: 3000, minVoltage: 60, maxOperating: 230, maxCharge: 60 },
        3000:  { maxVoltage: 450, maxCurrent: 18, maxPower: 4500, minVoltage: 60, maxOperating: 420, maxCharge: 80 },
        3500:  { maxVoltage: 450, maxCurrent: 22, maxPower: 5200, minVoltage: 60, maxOperating: 420, maxCharge: 80 },
        4000:  { maxVoltage: 450, maxCurrent: 22, maxPower: 5500, minVoltage: 60, maxOperating: 420, maxCharge: 100 },
        5000:  { maxVoltage: 500, maxCurrent: 27, maxPower: 7500, minVoltage: 95, maxOperating: 450, maxCharge: 120 },
        6000:  { maxVoltage: 500, maxCurrent: 30, maxPower: 8000, minVoltage: 95, maxOperating: 450, maxCharge: 120 },
        8000:  { maxVoltage: 500, maxCurrent: 36, maxPower: 10400, minVoltage: 95, maxOperating: 450, maxCharge: 150 },
        10000: { maxVoltage: 500, maxCurrent: 42, maxPower: 13000, minVoltage: 120, maxOperating: 450, maxCharge: 180 },
        12000: { maxVoltage: 500, maxCurrent: 50, maxPower: 15600, minVoltage: 120, maxOperating: 450, maxCharge: 200 },
        15000: { maxVoltage: 500, maxCurrent: 60, maxPower: 19500, minVoltage: 120, maxOperating: 450, maxCharge: 250 }
    },

    // Standard inverter sizes (VA)
    INVERTER_SIZES: [300, 500, 600, 800, 1000, 1200, 1500, 2000, 2400, 3000, 3500, 4000, 5000, 6000, 8000, 10000, 12000, 15000],

    // Market range: what the client will actually find in Nigerian stores
    // Key = our calculated size, Value = [min, max] range seen in market
    // Some sizes overlap because brands vary (Felicity 2.4kVA, Must 2.5kVA, Luminous 3kVA, etc.)
    INVERTER_MARKET_RANGE: {
        300:   [300, 500],
        500:   [500, 600],
        600:   [600, 800],
        800:   [800, 1000],
        1000:  [1000, 1200],
        1200:  [1200, 1500],
        1500:  [1500, 2000],
        2000:  [2000, 2400],
        2400:  [2400, 2500],
        3000:  [3000, 3500],
        3500:  [3500, 4000],
        4000:  [4000, 5000],
        5000:  [5000, 5500],
        6000:  [6000, 6500],
        8000:  [8000, 10000],
        10000: [10000, 12000],
        12000: [12000, 15000],
        15000: [15000, 15000]
    },

    // DC voltage thresholds
    DC_VOLTAGE_THRESHOLDS: {
        12: 1500,
        24: 3000,
        48: 15000
    },

    // Maximum DC currents per voltage
    MAX_DC_CURRENT: {
        12: 150,
        24: 200,
        48: 250
    },

    // AWG to mm2 conversion and ampacity
    AWG_DATA: {
        14: { mm2: 2.08, ampFreeAir: 25, ampConduit: 20 },
        12: { mm2: 3.31, ampFreeAir: 30, ampConduit: 25 },
        10: { mm2: 5.26, ampFreeAir: 40, ampConduit: 35 },
        8: { mm2: 8.37, ampFreeAir: 55, ampConduit: 50 },
        6: { mm2: 13.30, ampFreeAir: 75, ampConduit: 65 },
        4: { mm2: 21.15, ampFreeAir: 95, ampConduit: 85 },
        2: { mm2: 33.62, ampFreeAir: 130, ampConduit: 115 },
        1: { mm2: 42.41, ampFreeAir: 150, ampConduit: 130 },
        0: { mm2: 53.49, ampFreeAir: 170, ampConduit: 150 },
        '-1': { mm2: 67.43, ampFreeAir: 195, ampConduit: 175 },
        '-2': { mm2: 85.01, ampFreeAir: 225, ampConduit: 200 },
        '-3': { mm2: 107.22, ampFreeAir: 260, ampConduit: 230 }
    },

    // Metric cable sizes (mm2)
    METRIC_CABLE_SIZES: [1.5, 2.5, 4, 6, 10, 16, 25, 35, 50, 70, 95, 120, 150, 185, 240],

    // Metric cable ampacity (Amps in conduit, copper, 30°C ambient, PVC insulated per IEC 60364)
    METRIC_CABLE_AMPACITY: {
        1.5: 14, 2.5: 21, 4: 28, 6: 36, 10: 50, 16: 68,
        25: 89, 35: 110, 50: 133, 70: 171, 95: 207,
        120: 239, 150: 272, 185: 310, 240: 364
    },

    // Standard battery Ah ratings
    STANDARD_AH_RATINGS: [50, 75, 100, 120, 150, 180, 200, 220, 250, 280, 300],

    // LiFePO4 cell ratings commonly available in the market
    LIFEPO4_CELL_RATINGS: [100, 150, 200, 230, 280, 304, 320],

    // LiFePO4 module library — 51.2V standard (16S × 3.2V)
    LITHIUM_MODULES: {
        nominalVoltage: 51.2,
        cellsPerModule: 16,
        cellVoltage: 3.2,
        catalog: [
            { kWh: 5.12,  ah: 100,  label: '5.12 kWh / 100Ah',  note: 'Entry-level, single inverter' },
            { kWh: 7.2,   ah: 140,  label: '7.2 kWh / 140Ah',   note: 'Popular mid-range (Felicity, Deye)' },
            { kWh: 7.68,  ah: 150,  label: '7.68 kWh / 150Ah',  note: 'Common rack module (Pylontech, BYD)' },
            { kWh: 10.24, ah: 200,  label: '10.24 kWh / 200Ah',  note: 'High-capacity single unit' },
            { kWh: 15.0,  ah: 293,  label: '15 kWh / ~300Ah',    note: 'Commercial / stacked modules' },
            { kWh: 17.5,  ah: 342,  label: '17.5 kWh / ~340Ah',  note: 'High-end rack (stacked 2-3 units)' },
            { kWh: 20.48, ah: 400,  label: '20.48 kWh / 400Ah',  note: 'Stackable / parallel config' }
        ]
    },

    // System constants
    COPPER_RESISTIVITY: 0.0217,  // ohm*mm2/m at 75C
    STC_TEMP: 25,
    NEC_CONTINUOUS_FACTOR: 1.25,
    INVERTER_DERATING: 0.80,
    INVERTER_EFFICIENCY: 0.93,
    MPPT_EFFICIENCY: 0.98,
    DC_VOLTAGE_DROP_TARGET: 0.03,
    AC_VOLTAGE_DROP_TARGET: 0.02,
    PV_SOILING_LOSS: 0.03,
    PV_MISMATCH_LOSS: 0.02,
    CABLE_LOSS_FACTOR: 0.02,
    VOC_HEADROOM_PERCENT: 0.03
};

/* =============================================================================
   PHASE 1: LOAD ENGINE - Pure calculation functions
   ============================================================================= */

const LoadEngine = {
    appliances: [],

    /**
     * Calculate real power considering efficiency
     */
    calculateRealPower(appliance) {
        return (appliance.ratedPowerW * appliance.quantity) / appliance.efficiency;
    },

    /**
     * Calculate apparent power (VA) from real power and power factor
     */
    calculateApparentPowerVA(appliance) {
        return this.calculateRealPower(appliance) / appliance.powerFactor;
    },

    /**
     * Calculate starting/surge VA
     */
    calculateStartingVA(appliance) {
        return this.calculateApparentPowerVA(appliance) * appliance.surgeFactor;
    },

    /**
     * Calculate daily energy consumption in Wh
     */
    calculateDailyEnergyWh(appliance) {
        return this.calculateRealPower(appliance) * appliance.dailyUsageHours * (appliance.dutyCycle / 100);
    },

    /**
     * Calculate operating current in Amps
     */
    calculateOperatingCurrent(appliance, voltage) {
        return this.calculateApparentPowerVA(appliance) / voltage;
    },

    /**
     * Validate appliance input
     */
    validateAppliance(appliance) {
        const errors = [];

        if (!appliance.name || appliance.name.trim() === '') {
            errors.push('Appliance name is required');
        }
        if (appliance.ratedPowerW <= 0 || appliance.ratedPowerW > 100000) {
            errors.push('Power must be between 1 and 100,000 watts');
        }
        if (appliance.quantity < 1 || appliance.quantity > 1000) {
            errors.push('Quantity must be between 1 and 1000');
        }
        if (appliance.dailyUsageHours < 0 || appliance.dailyUsageHours > 24) {
            errors.push('Daily hours must be between 0 and 24');
        }
        if (appliance.dutyCycle < 1 || appliance.dutyCycle > 100) {
            errors.push('Duty cycle must be between 1 and 100%');
        }
        if (appliance.surgeFactor < 1 || appliance.surgeFactor > 10) {
            errors.push('Surge factor must be between 1 and 10');
        }
        if (appliance.powerFactor < 0.5 || appliance.powerFactor > 1) {
            errors.push('Power factor must be between 0.5 and 1.0');
        }

        return errors;
    },

    /**
     * Get load summary
     */
    getSummary() {
        if (this.appliances.length === 0) {
            return { totalAppliances: 0, error: 'No appliances loaded' };
        }

        const acLoads = this.appliances.filter(a => a.isAC);
        const motorLoads = this.appliances.filter(a => a.loadType === 'motor');
        const simultaneousLoads = this.appliances.filter(a => a.isSimultaneous);

        return {
            totalAppliances: this.appliances.length,
            acLoadCount: acLoads.length,
            motorCount: motorLoads.length,
            simultaneousCount: simultaneousLoads.length,
            nonSimultaneousCount: this.appliances.length - simultaneousLoads.length
        };
    }
};

/* =============================================================================
   PHASE 2: AGGREGATION ENGINE - Aggregate all loads
   ============================================================================= */

const AggregationEngine = {
    /**
     * Calculate aggregated load values
     */
    calculate(appliances, config) {
        if (appliances.length === 0) {
            throw new Error('No appliances to aggregate');
        }

        // Total power calculations
        let totalRealPower = 0;
        let totalApparentPower = 0;
        let dailyEnergy = 0;
        let daytimeEnergy = 0;
        let nighttimeEnergy = 0;
        let acPower = 0;
        let dcPower = 0;
        let motorPower = 0;

        for (const app of appliances) {
            const realPower = LoadEngine.calculateRealPower(app);
            const apparentPower = LoadEngine.calculateApparentPowerVA(app);
            const energy = LoadEngine.calculateDailyEnergyWh(app);

            totalRealPower += realPower;
            totalApparentPower += apparentPower;
            dailyEnergy += energy;
            daytimeEnergy += energy * (app.daytimeRatio / 100);
            nighttimeEnergy += energy * (1 - app.daytimeRatio / 100);

            if (app.isAC) {
                acPower += apparentPower;
            } else {
                dcPower += realPower;
            }

            if (app.loadType === 'motor') {
                motorPower += apparentPower;
            }
        }

        // Peak simultaneous VA calculation
        const simultaneousApps = appliances.filter(a => a.isSimultaneous);
        const nonSimultaneousApps = appliances.filter(a => !a.isSimultaneous);

        const simultaneousVA = simultaneousApps.reduce((sum, a) => sum + LoadEngine.calculateApparentPowerVA(a), 0);
        const nonSimultaneousMax = nonSimultaneousApps.length > 0
            ? Math.max(...nonSimultaneousApps.map(a => LoadEngine.calculateApparentPowerVA(a)))
            : 0;
        const peakSimultaneous = simultaneousVA + nonSimultaneousMax;

        // Identify motor appliances for surge calculations
        const motorAppliances = appliances.filter(a => a.loadType === 'motor');
        const surges = appliances.map(a => ({
            delta: LoadEngine.calculateStartingVA(a) - LoadEngine.calculateApparentPowerVA(a),
            appliance: a
        }));
        surges.sort((a, b) => b.delta - a.delta);

        // WORST-CASE SURGE: All motors surge simultaneously
        // Conservative assumption — every motor starts at the same instant
        let highestSurge = peakSimultaneous;
        if (motorAppliances.length >= 2) {
            // Sum ALL motor surge deltas (worst-case: all start together)
            const totalMotorSurgeDelta = motorAppliances.reduce((sum, m) => {
                return sum + (LoadEngine.calculateStartingVA(m) - LoadEngine.calculateApparentPowerVA(m));
            }, 0);
            highestSurge = peakSimultaneous + totalMotorSurgeDelta;
        } else if (surges.length > 0) {
            // Single motor or non-motor surges: just add the biggest delta
            highestSurge = peakSimultaneous + surges[0].delta;
        }

        // STAGGERED SURGE: Only the single biggest motor surges at a time
        // Realistic assumption — user staggers motor starts by 30+ seconds
        let staggeredSurge = peakSimultaneous;
        let dominantMotor = null;
        if (motorAppliances.length >= 1) {
            let maxMotorSurgeVA = 0;
            let dominantApp = null;
            for (const m of motorAppliances) {
                const startVA = LoadEngine.calculateStartingVA(m);
                if (startVA > maxMotorSurgeVA) {
                    maxMotorSurgeVA = startVA;
                    dominantApp = m;
                    dominantMotor = { name: m.name, watt: m.ratedPowerW * m.quantity, surgeVA: Math.round(startVA), surgeFactor: m.surgeFactor };
                }
            }
            // Staggered = continuous of everything + only the dominant motor's surge delta
            const dominantDelta = maxMotorSurgeVA - LoadEngine.calculateApparentPowerVA(dominantApp);
            staggeredSurge = peakSimultaneous + dominantDelta;
        }

        // ── Industrial usage detection ──
        // Analyze motor appliances for industrial patterns that affect sizing
        const industrialMotors = motorAppliances.filter(m => m.isIndustrialSewing || m.ratedPowerW > 400);
        const hasIndustrialSewing = motorAppliances.some(m => m.isIndustrialSewing);
        const hasCompressor = motorAppliances.some(m => m.motorSubType === 'compressor');
        const clutchMotors = motorAppliances.filter(m => m.motorSubType === 'clutch');
        const servoMotors = motorAppliances.filter(m => m.motorSubType === 'servo');

        // Compliance risk: how likely the client WON'T follow staggering rules
        // Higher risk = bigger safety margin on recommended tier
        let complianceRisk = 'low'; // low, medium, high
        let complianceNote = '';
        if (hasIndustrialSewing && hasCompressor) {
            // Industrial sewing + freezer/AC = highest risk of simultaneous surge
            complianceRisk = 'high';
            complianceNote = 'Industrial sewing machine + compressor load detected. High risk of simultaneous startup — sizing includes safety buffer.';
        } else if (industrialMotors.length >= 2) {
            complianceRisk = 'high';
            complianceNote = 'Multiple industrial motors detected. Client may not always stagger starts — recommended tier includes compliance buffer.';
        } else if (hasIndustrialSewing || (hasCompressor && motorAppliances.length >= 2)) {
            complianceRisk = 'medium';
            complianceNote = 'Industrial motor load detected. Recommended tier includes moderate buffer for occasional non-compliance.';
        } else if (clutchMotors.length >= 1 && hasCompressor) {
            complianceRisk = 'medium';
            complianceNote = 'Clutch motor + compressor: moderate surge overlap risk. Recommended tier accounts for this.';
        }

        // Servo upgrade opportunity
        let servoUpgradeAdvice = null;
        if (clutchMotors.length > 0 && hasIndustrialSewing) {
            const clutchTotalW = clutchMotors.reduce((s, m) => s + m.ratedPowerW * m.quantity, 0);
            const estimatedServoSavings = Math.round(clutchTotalW * 0.40);
            const estimatedSurgeDrop = Math.round(clutchTotalW * 3.5 * 0.65); // clutch 4x → servo 1.5x
            servoUpgradeAdvice = {
                clutchCount: clutchMotors.length,
                clutchTotalW: clutchTotalW,
                estimatedEnergySavingsW: estimatedServoSavings,
                estimatedSurgeReductionVA: estimatedSurgeDrop,
                message: `Upgrade ${clutchMotors.length} clutch motor(s) to servo: Save ~${estimatedServoSavings}W daily draw, reduce peak surge by ~${estimatedSurgeDrop}VA. Inverter can be ~20% smaller. Cost: ~₦50k+ per motor.`
            };
        }

        // Design values with safety margins
        const designMargin = config.designMargin / 100;
        const designContinuous = peakSimultaneous * designMargin;
        const designSurge = highestSurge * designMargin;
        const designStaggeredSurge = staggeredSurge * designMargin;

        return {
            totalRealPowerW: Math.round(totalRealPower * 10) / 10,
            totalApparentPowerVA: Math.round(totalApparentPower * 10) / 10,
            peakSimultaneousVA: Math.round(peakSimultaneous * 10) / 10,
            highestSurgeVA: Math.round(highestSurge * 10) / 10,
            dailyEnergyWh: Math.round(dailyEnergy * 10) / 10,
            daytimeEnergyWh: Math.round(daytimeEnergy * 10) / 10,
            nighttimeEnergyWh: Math.round(nighttimeEnergy * 10) / 10,
            acPowerVA: Math.round(acPower * 10) / 10,
            dcPowerW: Math.round(dcPower * 10) / 10,
            motorPowerVA: Math.round(motorPower * 10) / 10,
            designContinuousVA: Math.round(designContinuous * 10) / 10,
            designSurgeVA: Math.round(designSurge * 10) / 10,
            designStaggeredSurgeVA: Math.round(designStaggeredSurge * 10) / 10,
            motorCount: motorAppliances.length,
            dominantMotor: dominantMotor,
            // Industrial intelligence
            hasIndustrialSewing: hasIndustrialSewing,
            hasCompressor: hasCompressor,
            industrialMotorCount: industrialMotors.length,
            complianceRisk: complianceRisk,
            complianceNote: complianceNote,
            servoUpgradeAdvice: servoUpgradeAdvice,
            clutchMotorCount: clutchMotors.length,
            servoMotorCount: servoMotors.length
        };
    }
};

/* =============================================================================
   PHASE 3: INVERTER SIZING ENGINE
   ============================================================================= */

const InverterSizingEngine = {
    /**
     * Format inverter VA as market range string (e.g., 2400 → "2400–2500 VA")
     * Returns the range the client will actually see when shopping in Nigerian stores.
     */
    formatMarketRange(sizeVA) {
        const range = DEFAULTS.INVERTER_MARKET_RANGE[sizeVA];
        if (range && range[0] !== range[1]) {
            return `${range[0]}–${range[1]} VA`;
        }
        return `${sizeVA} VA`;
    },

    /**
     * Select next standard inverter size
     */
    selectInverterSize(requiredVA) {
        for (const size of DEFAULTS.INVERTER_SIZES) {
            if (size >= requiredVA) {
                return size;
            }
        }
        return Math.ceil(requiredVA / 1000) * 1000;
    },

    /**
     * Select DC bus voltage based on system size
     */
    selectDCVoltage(inverterVA) {
        for (const [voltage, maxVA] of Object.entries(DEFAULTS.DC_VOLTAGE_THRESHOLDS).sort((a, b) => a[0] - b[0])) {
            if (inverterVA <= maxVA) {
                return parseInt(voltage);
            }
        }
        return 48;
    },

    /**
     * Calculate inverter requirements
     */
    calculate(aggregatedLoad, config) {
        const warnings = [];
        const blocks = [];
        const suggestions = [];

        // Required continuous capacity with design margin
        const continuousRequired = aggregatedLoad.designContinuousVA;
        const surgeRequired = aggregatedLoad.designSurgeVA;

        // Account for inverter derating
        const continuousWithDerating = continuousRequired / DEFAULTS.INVERTER_DERATING;

        // Find recommended standard size
        let recommendedSize = this.selectInverterSize(continuousWithDerating);

        // Validate surge capability
        const surgeCapability = recommendedSize * config.inverterSurgeMultiplier;
        if (surgeRequired > surgeCapability) {
            const largerSize = this.selectInverterSize(surgeRequired / config.inverterSurgeMultiplier);
            if (largerSize > recommendedSize) {
                warnings.push(
                    `Inverter upsized from ${recommendedSize}VA to ${largerSize}VA to handle ${Math.round(surgeRequired)}VA surge requirement`
                );
                recommendedSize = largerSize;
            }
        }

        // Staggered motor start sizing (optimized)
        let staggeredSize = recommendedSize;
        if (aggregatedLoad.motorCount >= 2 && aggregatedLoad.designStaggeredSurgeVA) {
            const staggeredSurgeCapNeeded = aggregatedLoad.designStaggeredSurgeVA / config.inverterSurgeMultiplier;
            const continuousNeeded = continuousWithDerating;
            const staggeredMinSize = Math.max(continuousNeeded, staggeredSurgeCapNeeded);
            staggeredSize = this.selectInverterSize(staggeredMinSize);
        }

        // Recommended sizing: balanced approach between conservative and staggered
        // Auto-buffer based on motor count AND compliance risk for real-world reliability
        let bufferPct = 0;
        if (aggregatedLoad.motorCount >= 3) bufferPct = 0.30;
        else if (aggregatedLoad.motorCount >= 2) bufferPct = 0.20;
        else if (aggregatedLoad.motorCount >= 1) bufferPct = 0.10;

        // ── Compliance-aware buffer ──
        // For clients unlikely to follow staggering rules, bump the recommended tier
        // toward conservative. This is the "smart balance" — no compromise on reliability.
        const complianceRisk = aggregatedLoad.complianceRisk || 'low';
        let complianceBuffer = 0;
        if (complianceRisk === 'high') {
            // High risk: recommended tier is 80% toward conservative (near-worst-case)
            complianceBuffer = 0.20;
            bufferPct = Math.max(bufferPct, 0.35);
        } else if (complianceRisk === 'medium') {
            // Medium risk: recommended tier is 50% toward conservative
            complianceBuffer = 0.10;
            bufferPct = Math.max(bufferPct, 0.25);
        }

        // Industrial sewing machine specific: if >400W clutch motor detected,
        // ensure minimum recommended is 3000VA (as per expert sizing guidance)
        let industrialMinVA = 0;
        if (aggregatedLoad.hasIndustrialSewing) {
            // Industrial clutch sewing (400-750W) + other loads = 3000VA minimum recommended
            industrialMinVA = 3000;
            if (aggregatedLoad.hasCompressor) {
                // Industrial sewing + freezer/AC = 3500VA minimum (never start together)
                industrialMinVA = 3500;
            }
            if (aggregatedLoad.industrialMotorCount >= 3) {
                industrialMinVA = 5000; // 3+ industrial motors → go big
            }
        }

        // Recommended = midpoint surge sizing + motor buffer + compliance buffer
        const midpointSurge = (surgeRequired + (aggregatedLoad.designStaggeredSurgeVA || surgeRequired)) / 2;
        // For high compliance risk, bias midpoint closer to worst-case
        const complianceSurgeBias = complianceRisk === 'high' ? 0.8 : complianceRisk === 'medium' ? 0.6 : 0.5;
        const biasedMidpointSurge = aggregatedLoad.designStaggeredSurgeVA
            ? aggregatedLoad.designStaggeredSurgeVA + (surgeRequired - aggregatedLoad.designStaggeredSurgeVA) * complianceSurgeBias
            : surgeRequired;
        const recommendedMinFromSurge = biasedMidpointSurge / config.inverterSurgeMultiplier;
        const recommendedMinFromContinuous = continuousWithDerating * (1 + bufferPct);
        let recommendedMinSize = Math.max(recommendedMinFromSurge, recommendedMinFromContinuous);

        // Apply industrial minimum floor
        if (industrialMinVA > 0) {
            recommendedMinSize = Math.max(recommendedMinSize, industrialMinVA);
        }

        let recommendedBalancedSize = this.selectInverterSize(recommendedMinSize);
        // Clamp between staggered and conservative
        if (recommendedBalancedSize > recommendedSize) recommendedBalancedSize = recommendedSize;
        if (recommendedBalancedSize < staggeredSize) recommendedBalancedSize = staggeredSize;

        // For industrial loads, don't let recommended drop below industrial floor
        if (industrialMinVA > 0 && recommendedBalancedSize < industrialMinVA) {
            recommendedBalancedSize = this.selectInverterSize(industrialMinVA);
        }

        // Determine DC bus voltage
        const dcVoltage = this.selectDCVoltage(recommendedSize);

        // Calculate DC currents
        const dcCurrentContinuous = continuousRequired / dcVoltage;
        const dcCurrentSurge = surgeRequired / dcVoltage;

        // DC current warnings
        const maxCurrent = DEFAULTS.MAX_DC_CURRENT[dcVoltage] || 250;

        if (dcCurrentContinuous > maxCurrent) {
            blocks.push(
                `HARD BLOCK: DC continuous current ${dcCurrentContinuous.toFixed(1)}A exceeds ${maxCurrent}A limit for ${dcVoltage}V system.`
            );
            suggestions.push(
                `Consider higher voltage bus (${dcVoltage * 2}V) or multiple inverters to reduce DC current to safe levels.`
            );
        } else if (dcCurrentContinuous > maxCurrent * 0.8) {
            warnings.push(
                `DC continuous current ${dcCurrentContinuous.toFixed(1)}A is high for ${dcVoltage}V system. Consider ${dcVoltage * 2}V bus.`
            );
        }

        if (dcCurrentSurge > maxCurrent * 1.5) {
            warnings.push(
                `DC surge current ${dcCurrentSurge.toFixed(1)}A will stress cables. Ensure adequate cable sizing and battery capacity.`
            );
        }

        // ── Industrial-specific warnings and suggestions ──
        if (aggregatedLoad.hasIndustrialSewing && complianceRisk !== 'low') {
            warnings.push(aggregatedLoad.complianceNote);
        }
        if (aggregatedLoad.servoUpgradeAdvice) {
            suggestions.push(aggregatedLoad.servoUpgradeAdvice.message);
        }
        if (aggregatedLoad.hasIndustrialSewing && aggregatedLoad.hasCompressor) {
            warnings.push(
                'Never start the sewing machine and freezer/AC together — wait 45-60 seconds between motor starts. Freezer surge is the real danger (5-7x for 1-2 seconds).'
            );
            suggestions.push(
                'Run sewing during peak sun (10am-4pm) — draws almost entirely from panels, extending battery life. Freezer runs 24/7 on thermostat cycles.'
            );
        }
        if (aggregatedLoad.hasIndustrialSewing && !aggregatedLoad.hasCompressor && aggregatedLoad.motorCount === 1) {
            suggestions.push(
                'Single industrial sewing machine detected. If adding any other motor (pump, AC, bigger fan) later — go straight to 5kVA inverter.'
            );
        }

        return {
            continuousVARequired: Math.round(continuousRequired * 10) / 10,
            surgeVARequired: Math.round(surgeRequired * 10) / 10,
            recommendedSizeVA: recommendedSize,
            recommendedBalancedSizeVA: recommendedBalancedSize,
            motorBufferPct: Math.round(bufferPct * 100),
            staggeredSizeVA: staggeredSize,
            staggeredSurgeVA: aggregatedLoad.designStaggeredSurgeVA || aggregatedLoad.designSurgeVA,
            motorCount: aggregatedLoad.motorCount || 0,
            dominantMotor: aggregatedLoad.dominantMotor || null,
            dcBusVoltage: dcVoltage,
            dcInputCurrentContinuous: Math.round(dcCurrentContinuous * 10) / 10,
            dcInputCurrentSurge: Math.round(dcCurrentSurge * 10) / 10,
            warnings,
            blocks,
            suggestions,
            // Industrial intelligence passthrough
            complianceRisk: complianceRisk,
            complianceNote: aggregatedLoad.complianceNote || '',
            hasIndustrialSewing: aggregatedLoad.hasIndustrialSewing || false,
            hasCompressor: aggregatedLoad.hasCompressor || false,
            industrialMinVA: industrialMinVA,
            servoUpgradeAdvice: aggregatedLoad.servoUpgradeAdvice || null,
            complianceBuffer: Math.round(complianceBuffer * 100)
        };
    }
};

/* =============================================================================
   PHASE 4: BATTERY SIZING ENGINE
   ============================================================================= */

const BatterySizingEngine = {
    /**
     * Select appropriate cell Ah rating (generic — lead acid and fallback)
     */
    selectCellAh(requiredAh) {
        for (const ah of DEFAULTS.STANDARD_AH_RATINGS) {
            if (ah >= requiredAh) {
                return ah;
            }
        }
        return Math.ceil(requiredAh / 100) * 100;
    },

    /**
     * Select LiFePO4 cell Ah from standard ratings
     */
    selectLithiumCellAh(requiredAh) {
        // Merge cell ratings + module Ah values for comprehensive matching
        const allAh = [...new Set([
            ...DEFAULTS.LIFEPO4_CELL_RATINGS,
            ...DEFAULTS.LITHIUM_MODULES.catalog.map(m => m.ah)
        ])].sort((a, b) => a - b);
        // Pick smallest that covers the requirement
        for (const ah of allAh) {
            if (ah >= requiredAh) return ah;
        }
        // Beyond max — return largest, caller uses parallel strings
        return allAh[allAh.length - 1];
    },

    /**
     * Match closest lithium module from catalog
     */
    /**
     * Match lithium module from catalog based on required NOMINAL kWh.
     * Prefers stacking common modules (5.12, 7.68, 10.24 kWh) over rare large singles.
     * @param {number} nominalKWh - Required nominal capacity (after DoD, efficiency, autonomy)
     * @returns {{ kWh, ah, label, note, stackCount, stackUnit? }}
     */
    matchLithiumModule(nominalKWh) {
        const catalog = DEFAULTS.LITHIUM_MODULES.catalog;
        // Stackable base units — these are the most available rack modules in the market
        const stackBases = catalog.filter(m => m.kWh <= 10.24);

        // 1. Try single module match (smallest module >= required nominal)
        let singleMatch = null;
        for (const mod of catalog) {
            if (mod.kWh >= nominalKWh * 0.97) {   // 3% tolerance for rounding
                singleMatch = mod;
                break;
            }
        }

        // If single module fits and is <= 10.24 kWh, use it directly (common market unit)
        if (singleMatch && singleMatch.kWh <= 10.24) {
            return { ...singleMatch, stackCount: 1 };
        }

        // 2. For > 10.24 kWh: prefer stacking common modules
        // Find the best stacking option (fewest units, closest fit)
        let bestStack = null;
        for (const base of stackBases) {
            if (base.kWh < 5) continue;  // Skip tiny modules for stacking
            const units = Math.ceil(nominalKWh / base.kWh);
            const totalKWh = Math.round(base.kWh * units * 100) / 100;
            const waste = totalKWh - nominalKWh;
            if (!bestStack || units < bestStack.units || (units === bestStack.units && waste < bestStack.waste)) {
                bestStack = { base, units, totalKWh, waste };
            }
        }

        // If stacking works (2-6 units), prefer it over rare large single module
        if (bestStack && bestStack.units <= 6) {
            const b = bestStack.base;
            return {
                kWh: bestStack.totalKWh,
                ah: Math.round(b.ah * bestStack.units),
                label: bestStack.units === 1
                    ? b.label
                    : `${bestStack.totalKWh} kWh (${bestStack.units}\u00D7 ${b.label})`,
                note: bestStack.units === 1
                    ? b.note
                    : `${bestStack.units} units stacked/parallel, each ${b.kWh} kWh`,
                stackCount: bestStack.units,
                stackUnit: b
            };
        }

        // 3. Fallback: if a large single module exists, use it
        if (singleMatch) {
            return { ...singleMatch, stackCount: 1 };
        }

        // 4. Very large requirement: stack largest available
        const largest = catalog[catalog.length - 1];
        const unitsNeeded = Math.ceil(nominalKWh / largest.kWh);
        return {
            kWh: Math.round(largest.kWh * unitsNeeded * 100) / 100,
            ah: largest.ah * unitsNeeded,
            label: `${Math.round(largest.kWh * unitsNeeded * 10) / 10} kWh (${unitsNeeded}\u00D7 ${largest.label})`,
            note: `${unitsNeeded} units stacked/parallel, each ${largest.kWh} kWh`,
            stackCount: unitsNeeded,
            stackUnit: largest
        };
    },

    /**
     * Build tiered recommendations from RAW usable energy.
     * Tiers multiply the usable demand FIRST, then each tier independently
     * computes its own nominal via: tierNominal = (usable × multiplier) / (DoD × efficiency)
     * This avoids compounding margin-on-margin.
     *
     * @param {number} usableEnergyWh - Raw energy demand (dailyLoad × autonomy), before DoD/eff
     * @param {number} bankVoltage    - Effective bank voltage (51.2V for LiFePO4)
     * @param {object} specs          - Battery chemistry specs (DoD, efficiency, etc.)
     * @param {string} chemistry      - Chemistry key
     * @param {number} designMarginPct - Design margin as percentage (e.g. 125)
     */
    buildTiers(usableEnergyWh, bankVoltage, specs, chemistry, designMarginPct) {
        const isLithium = chemistry === 'lifepo4';
        const tiers = {};
        const dod = specs.maxDoD;
        const eff = specs.dischargeEfficiency;
        const margin = (designMarginPct || 100) / 100;
        const selfDischargeFactor = 1 + (specs.selfDischargeDaily * (usableEnergyWh > 0 ? 1 : 0));

        // Helper: build a tier by scaling USABLE energy, then computing nominal
        const makeTier = (label, multiplier, note) => {
            // 1. Scale the usable energy demand
            const tierUsableWh = usableEnergyWh * multiplier;
            // 2. Convert to nominal: usable / (DoD × eff) × self-discharge × design margin
            const tierNominalWh = (tierUsableWh / eff / dod) * selfDischargeFactor * margin;
            const tierNominalKWh = Math.round(tierNominalWh / 100) / 10;
            // 3. Convert to Ah at bank voltage for cell-level sizing
            const targetAh = tierNominalWh / bankVoltage;
            const cellAh = isLithium ? this.selectLithiumCellAh(targetAh) : this.selectCellAh(targetAh);
            const strings = Math.ceil(targetAh / cellAh);
            const actualAh = strings * cellAh;
            const actualKWh = Math.round(actualAh * bankVoltage / 100) / 10;
            // 4. Module match based on tier's nominal kWh
            const module = isLithium ? this.matchLithiumModule(tierNominalKWh) : null;
            return {
                label,
                ah: cellAh,
                kWh: actualKWh,
                strings,
                nominalKWh: tierNominalKWh,
                note: strings > 1 ? `${note} — ${strings}P \u00D7 ${cellAh}Ah` : note,
                module
            };
        };

        tiers.economy = makeTier('ECONOMY MATCH', 1.0,
            'Meets computed requirement (DoD + efficiency + margin applied)');
        tiers.balanced = makeTier('BALANCED DESIGN', 1.20,
            '+20% usable headroom for degradation & real-world cycling');
        tiers.expansion = makeTier('EXPANSION READY', 1.50,
            '+50% usable headroom — absorbs load growth without upgrade');

        return tiers;
    },

    /**
     * Calculate battery bank requirements
     */
    calculate(aggregatedLoad, inverterReq, config, chemistry) {
        const warnings = [];
        const blocks = [];
        const suggestions = [];

        const specs = DEFAULTS.BATTERY_SPECS[chemistry];
        const bankVoltage = inverterReq.dcBusVoltage;
        const cellVoltage = specs.cellVoltage;
        const isLithium = chemistry === 'lifepo4';

        // For LiFePO4: use 51.2V (16S) standard when bank voltage is 48V
        const effectiveCellsInSeries = isLithium && bankVoltage >= 48
            ? (specs.cellsPerModule || 16)
            : Math.round(bankVoltage / cellVoltage);
        const effectiveBankVoltage = isLithium && bankVoltage >= 48
            ? (specs.moduleVoltage || 51.2)
            : bankVoltage;

        // Calculate usable capacity needed
        const usableCapacityWh = (aggregatedLoad.dailyEnergyWh * config.autonomyDays) / specs.dischargeEfficiency;

        // Total capacity considering DoD
        let totalCapacityWh = usableCapacityWh / specs.maxDoD;

        // Add margin for self-discharge during autonomy
        const selfDischargeLoss = specs.selfDischargeDaily * config.autonomyDays;
        totalCapacityWh *= (1 + selfDischargeLoss);

        // Apply design margin
        totalCapacityWh *= (config.designMargin / 100);

        // Calculate Ah at bank voltage (use effective voltage for lithium)
        let totalCapacityAh = totalCapacityWh / effectiveBankVoltage;

        // Series/parallel configuration
        const cellsInSeries = effectiveCellsInSeries;

        // Check discharge rate
        const peakLoadCurrent = inverterReq.dcInputCurrentSurge;
        let maxDischargeCurrent = totalCapacityAh * specs.maxDischargeRate;

        if (peakLoadCurrent > maxDischargeCurrent) {
            const requiredAh = peakLoadCurrent / specs.maxDischargeRate;
            if (requiredAh > totalCapacityAh) {
                warnings.push(
                    `Battery Ah increased from ${Math.round(totalCapacityAh)}Ah to ${Math.round(requiredAh)}Ah to support ${peakLoadCurrent.toFixed(1)}A discharge`
                );
                totalCapacityAh = requiredAh;
                totalCapacityWh = totalCapacityAh * effectiveBankVoltage;
            }
        }

        // Select cell Ah rating and parallel strings
        const recommendedAh = isLithium ? this.selectLithiumCellAh(totalCapacityAh) : this.selectCellAh(totalCapacityAh);
        const stringsParallel = Math.ceil(totalCapacityAh / recommendedAh);
        const actualCapacityAh = stringsParallel * recommendedAh;

        // Recalculate actual current ratings
        maxDischargeCurrent = actualCapacityAh * specs.maxDischargeRate;
        const maxChargeCurrent = actualCapacityAh * specs.maxChargeRate;

        // Hard blocks for current violations
        if (peakLoadCurrent > maxDischargeCurrent * 1.5) {
            blocks.push(
                `HARD BLOCK: Peak load current ${peakLoadCurrent.toFixed(1)}A exceeds safe discharge limit of ${(maxDischargeCurrent * 1.5).toFixed(1)}A (150% of max). Risk of battery damage and fire.`
            );
            suggestions.push(
                `Increase battery capacity to at least ${Math.round(peakLoadCurrent / specs.maxDischargeRate)}Ah or reduce peak load by using soft-start motors.`
            );
        }

        const totalCells = cellsInSeries * stringsParallel;

        // Required nominal kWh — the engineering basis for module selection
        // This is totalCapacityWh BEFORE cell rounding, representing the true requirement
        const requiredNominalKWh = Math.round(totalCapacityWh / 100) / 10;

        // Design basis for transparency
        const designBasis = {
            dailyLoadWh: Math.round(aggregatedLoad.dailyEnergyWh),
            autonomyDays: config.autonomyDays,
            dod: specs.maxDoD,
            dischargeEfficiency: specs.dischargeEfficiency,
            designMargin: config.designMargin,
            effectiveUsableFactor: Math.round(specs.maxDoD * specs.dischargeEfficiency * 1000) / 1000,
            requiredNominalKWh
        };

        // Build tiered recommendations — tiers scale USABLE energy, then each computes its own nominal
        const baseUsableEnergyWh = aggregatedLoad.dailyEnergyWh * config.autonomyDays;
        const tiers = this.buildTiers(baseUsableEnergyWh, effectiveBankVoltage, specs, chemistry, config.designMargin);

        // Capacity range for display
        const capacityRange = {
            min: tiers.economy.ah,
            balanced: tiers.balanced.ah,
            max: tiers.expansion.strings * tiers.expansion.ah,
            minKWh: tiers.economy.kWh,
            balancedKWh: tiers.balanced.kWh,
            maxKWh: tiers.expansion.kWh
        };

        // Lithium module recommendation — based on required nominal kWh (not rounded cell Ah)
        const moduleMatch = isLithium ? this.matchLithiumModule(requiredNominalKWh) : null;

        // Note about 51.2V standard
        if (isLithium && bankVoltage >= 48) {
            suggestions.push(
                `LiFePO4 standard: 51.2V nominal (16S × 3.2V). Modern rack batteries (Pylontech, Felicity, BYD, Deye) use this standard. Actual terminal voltage: 44.8V–58.4V operating range.`
            );
        }

        return {
            chemistry,
            chemistryName: specs.name,
            usableCapacityWh: Math.round(usableCapacityWh * 10) / 10,
            totalCapacityWh: Math.round(actualCapacityAh * effectiveBankVoltage * 10) / 10,
            totalCapacityAh: Math.round(actualCapacityAh * 10) / 10,
            bankVoltage: effectiveBankVoltage,
            bankVoltageNominal: bankVoltage,
            cellsInSeries,
            stringsInParallel: stringsParallel,
            totalCells,
            maxDischargeCurrent: Math.round(maxDischargeCurrent * 10) / 10,
            maxChargeCurrent: Math.round(maxChargeCurrent * 10) / 10,
            peakLoadCurrent: Math.round(peakLoadCurrent * 10) / 10,
            recommendedAhPerCell: recommendedAh,
            // Engineering basis + tiered recommendations
            requiredNominalKWh,
            designBasis,
            tiers,
            capacityRange,
            moduleMatch,
            isLithium,
            effectiveBankVoltage,
            warnings,
            blocks,
            suggestions
        };
    }
};

/* =============================================================================
   PHASE 5: PV ARRAY ENGINE
   ============================================================================= */

const PVArrayEngine = {
    /**
     * Calculate PV array design
     */
    calculate(aggregatedLoad, batteryReq, config, panel, mppt) {
        const warnings = [];
        const blocks = [];
        const suggestions = [];

        const batterySpecs = DEFAULTS.BATTERY_SPECS[batteryReq.chemistry];

        // System efficiency
        const systemEfficiency =
            DEFAULTS.INVERTER_EFFICIENCY *
            batterySpecs.chargeEfficiency *
            (1 - DEFAULTS.CABLE_LOSS_FACTOR) *
            (1 - DEFAULTS.PV_SOILING_LOSS) *
            (1 - DEFAULTS.PV_MISMATCH_LOSS);

        // Required PV energy
        let requiredPVEnergy = aggregatedLoad.dailyEnergyWh / systemEfficiency;

        // Optionally add daytime load power to PV requirement
        // This ensures panels can simultaneously power daytime loads AND charge batteries
        const pvAccountForDaytimeLoad = document.getElementById('pvAccountForDaytimeLoad')?.checked !== false;
        const daytimeLoadWh = aggregatedLoad.daytimeEnergyWh || 0;
        if (pvAccountForDaytimeLoad && daytimeLoadWh > 0) {
            // Daytime load needs to be directly powered by PV during sun hours
            const daytimePVWh = daytimeLoadWh / systemEfficiency;
            requiredPVEnergy += daytimePVWh;
        }

        // Add energy to replenish battery
        const batteryRechargeWh = batteryReq.usableCapacityWh / batterySpecs.chargeEfficiency;
        requiredPVEnergy += batteryRechargeWh / config.autonomyDays;

        // Apply design margin
        requiredPVEnergy *= (config.designMargin / 100);

        // Calculate required array wattage
        let requiredWattage = requiredPVEnergy / config.avgPSH;

        // Temperature derating
        const tempDelta = config.ambientTempMax - DEFAULTS.STC_TEMP;
        const tempCoeffPmax = panel.tempCoeffPmax || -0.35;  // From panel specs or default
        const tempDerating = 1 + (tempCoeffPmax / 100 * tempDelta);
        if (tempDerating < 1) {
            requiredWattage /= tempDerating;
        }

        // Number of panels needed
        const panelsRequired = Math.ceil(requiredWattage / panel.wattage);

        // Voc at coldest temperature
        const tempDeltaCold = config.ambientTempMin - DEFAULTS.STC_TEMP;
        const vocTempFactor = 1 + (panel.tempCoeffVoc / 100 * tempDeltaCold);
        const vocCold = panel.voc * vocTempFactor;

        // Maximum panels in series based on cold Voc limit AND max operating voltage
        const maxSeriesVoc = Math.floor((mppt.maxVoltage * (1 - DEFAULTS.VOC_HEADROOM_PERCENT)) / vocCold);
        const maxSeriesVmp = mppt.maxOperatingVoltage ? Math.floor(mppt.maxOperatingVoltage / panel.vmp) : maxSeriesVoc;
        const maxSeriesForMPPT = Math.min(maxSeriesVoc, maxSeriesVmp);

        // Minimum panels in series: must exceed MPPT min voltage AND battery voltage * 1.2
        const minStringVmpBatt = batteryReq.bankVoltage * 1.2;
        const minStringVmpMPPT = mppt.minVoltage || 60;
        const minStringVmp = Math.max(minStringVmpBatt, minStringVmpMPPT);
        const minSeriesForMPPT = Math.max(1, Math.ceil(minStringVmp / panel.vmp));

        if (maxSeriesForMPPT < minSeriesForMPPT) {
            blocks.push(
                `HARD BLOCK: Cannot configure viable string. Min series for efficiency: ${minSeriesForMPPT}, Max series for MPPT voltage limit: ${maxSeriesForMPPT}. Need different panel or MPPT.`
            );
            suggestions.push(
                `Use an MPPT with higher voltage rating (>${Math.round(vocCold * minSeriesForMPPT)}V) or panels with lower Voc.`
            );
        }

        // Find optimal series count
        let panelsInSeries = Math.min(
            maxSeriesForMPPT,
            Math.max(minSeriesForMPPT, Math.floor(Math.sqrt(panelsRequired)))
        );

        // Calculate parallel strings
        let stringsParallel = Math.ceil(panelsRequired / panelsInSeries);

        // Validate MPPT current limit
        let arrayIsc = panel.isc * stringsParallel;
        if (arrayIsc > mppt.maxCurrent) {
            const maxParallel = Math.floor(mppt.maxCurrent / panel.isc);
            if (maxParallel < 1) {
                blocks.push(
                    `HARD BLOCK: Single string Isc (${panel.isc}A) exceeds MPPT max current (${mppt.maxCurrent}A)`
                );
                suggestions.push(
                    `Use an MPPT with higher current rating (>${panel.isc}A) or panels with lower Isc.`
                );
            } else {
                panelsInSeries = Math.ceil(panelsRequired / maxParallel);
                stringsParallel = maxParallel;
                warnings.push(
                    `Parallel strings limited to ${maxParallel} due to MPPT current limit`
                );
            }
        }

        // Final configuration
        const totalPanels = panelsInSeries * stringsParallel;
        const stringVmp = panel.vmp * panelsInSeries;
        const stringVoc = panel.voc * panelsInSeries;
        const stringVocCold = vocCold * panelsInSeries;
        const arrayImp = panel.imp * stringsParallel;
        arrayIsc = panel.isc * stringsParallel;
        const arrayWattage = panel.wattage * totalPanels;
        const deratedOutput = arrayWattage * tempDerating * (1 - DEFAULTS.PV_SOILING_LOSS);
        const dailyEnergy = deratedOutput * config.avgPSH;

        // Validation checks
        if (stringVocCold > mppt.maxVoltage) {
            blocks.push(
                `HARD BLOCK: Cold Voc (${stringVocCold.toFixed(1)}V) exceeds MPPT max voltage (${mppt.maxVoltage}V). Risk of MPPT damage!`
            );
            suggestions.push(
                `Reduce panels in series to ${Math.floor(mppt.maxVoltage / vocCold)} or less, or use an MPPT rated for ${Math.round(stringVocCold)}V+.`
            );
        } else if (stringVocCold > mppt.maxVoltage * 0.9) {
            warnings.push(
                `Cold Voc (${stringVocCold.toFixed(1)}V) is within 10% of MPPT limit. Consider reducing panels in series.`
            );
        }

        if (arrayWattage > mppt.maxPower) {
            warnings.push(
                `Array power (${arrayWattage}W) exceeds MPPT rating (${mppt.maxPower}W). MPPT will limit output to its rated power.`
            );
        }

        // Check string Vmp vs max operating voltage
        if (mppt.maxOperatingVoltage && stringVmp > mppt.maxOperatingVoltage) {
            warnings.push(
                `String Vmp (${stringVmp.toFixed(1)}V) exceeds MPPT max operating voltage (${mppt.maxOperatingVoltage}V). MPPT may not track efficiently. Consider fewer panels in series.`
            );
        }

        // Check string Vmp vs min startup voltage
        if (mppt.minVoltage && stringVmp < mppt.minVoltage) {
            warnings.push(
                `String Vmp (${stringVmp.toFixed(1)}V) is below MPPT min startup voltage (${mppt.minVoltage}V). System may not start in low-light conditions.`
            );
        }

        return {
            panelsInSeries,
            stringsInParallel: stringsParallel,
            totalPanels,
            stringVmp: Math.round(stringVmp * 10) / 10,
            stringVoc: Math.round(stringVoc * 10) / 10,
            stringVocCold: Math.round(stringVocCold * 10) / 10,
            arrayImp: Math.round(arrayImp * 100) / 100,
            arrayIsc: Math.round(arrayIsc * 100) / 100,
            arrayWattage: Math.round(arrayWattage * 10) / 10,
            deratedOutput: Math.round(deratedOutput * 10) / 10,
            dailyEnergyWh: Math.round(dailyEnergy * 10) / 10,
            pvAccountForDaytimeLoad: pvAccountForDaytimeLoad,
            daytimeLoadWh: Math.round(daytimeLoadWh),
            warnings,
            blocks,
            suggestions
        };
    }
};

/* =============================================================================
   PHASE 6: CHARGE CONTROLLER VALIDATION
   ============================================================================= */

const ChargeControllerValidator = {
    /**
     * Validate charge controller against array configuration
     */
    validate(pvDesign, mppt) {
        const warnings = [];
        const blocks = [];
        const suggestions = [];

        // Voltage validation
        const maxPVVoltageOK = pvDesign.stringVocCold <= mppt.maxVoltage;
        const voltageHeadroom = (mppt.maxVoltage - pvDesign.stringVocCold) / mppt.maxVoltage;

        if (!maxPVVoltageOK) {
            blocks.push(
                `HARD BLOCK: String Voc (cold) ${pvDesign.stringVocCold.toFixed(1)}V EXCEEDS MPPT maximum ${mppt.maxVoltage}V. IMMEDIATE RISK OF EQUIPMENT DAMAGE AND FIRE.`
            );
            suggestions.push(
                `Increase MPPT voltage rating to at least ${Math.round(pvDesign.stringVocCold * 1.1)}V or reduce panels in series.`
            );
        } else if (voltageHeadroom < 0.05) {
            warnings.push(
                `CRITICAL: Only ${(voltageHeadroom * 100).toFixed(1)}% voltage headroom. Temperature excursions may cause overvoltage damage.`
            );
        }

        // Current validation
        const iscWithMargin = pvDesign.arrayIsc * DEFAULTS.NEC_CONTINUOUS_FACTOR;
        const maxPVCurrentOK = iscWithMargin <= mppt.maxCurrent;
        const currentHeadroom = (mppt.maxCurrent - pvDesign.arrayIsc) / mppt.maxCurrent;

        if (!maxPVCurrentOK) {
            blocks.push(
                `HARD BLOCK: Array Isc with NEC margin (${iscWithMargin.toFixed(1)}A) EXCEEDS MPPT maximum ${mppt.maxCurrent}A.`
            );
            suggestions.push(
                `Increase MPPT current rating to at least ${Math.round(iscWithMargin)}A or reduce parallel strings.`
            );
        }

        // Power validation
        const maxPowerOK = pvDesign.arrayWattage <= mppt.maxPower * 1.3;

        if (pvDesign.arrayWattage > mppt.maxPower * 1.3) {
            warnings.push(
                `Array significantly oversized (${pvDesign.arrayWattage}W vs ${mppt.maxPower}W MPPT). Consider multiple MPPTs.`
            );
        }

        return {
            isValid: maxPVVoltageOK && maxPVCurrentOK && maxPowerOK,
            maxPVVoltageOK,
            maxPVCurrentOK,
            maxPowerOK,
            voltageHeadroomPercent: Math.round(voltageHeadroom * 1000) / 10,
            currentHeadroomPercent: Math.round(currentHeadroom * 1000) / 10,
            warnings,
            blocks,
            suggestions
        };
    }
};

/* =============================================================================
   PHASE 7: CABLE SIZING ENGINE
   ============================================================================= */

const CableSizingEngine = {
    /**
     * Find next standard metric cable size >= given mm2
     */
    findMarketMetricSize(mm2) {
        for (const size of DEFAULTS.METRIC_CABLE_SIZES) {
            if (size >= mm2) return size;
        }
        return DEFAULTS.METRIC_CABLE_SIZES[DEFAULTS.METRIC_CABLE_SIZES.length - 1];
    },

    /**
     * Find closest AWG equivalent for a given mm2 value
     */
    findClosestAWG(mm2) {
        const awgKeys = Object.keys(DEFAULTS.AWG_DATA).map(Number).sort((a, b) => b - a);
        let closest = null;
        let closestDiff = Infinity;
        for (const awg of awgKeys) {
            const diff = Math.abs(DEFAULTS.AWG_DATA[awg].mm2 - mm2);
            if (diff < closestDiff) {
                closestDiff = diff;
                closest = awg;
            }
        }
        if (closest === 0) return '1/0';
        if (closest === -1) return '2/0';
        if (closest === -2) return '3/0';
        if (closest === -3) return '4/0';
        return closest.toString();
    },

    /**
     * Get metric cable ampacity for a given standard metric size
     */
    getMetricAmpacity(mm2) {
        return DEFAULTS.METRIC_CABLE_AMPACITY[mm2] || 0;
    },

    /**
     * Size individual cable run
     */
    sizeCable(name, current, voltage, length, isDC, maxDrop) {
        const warnings = [];
        let parallelCables = 1;

        // Calculate minimum cross-section for voltage drop
        const allowedDropV = voltage * maxDrop;
        const minAreaVdrop = (current * DEFAULTS.COPPER_RESISTIVITY * length * 2) / allowedDropV;

        // Find AWG that meets both voltage drop and ampacity
        let selectedAWG = null;
        let selectedMm2 = 0;
        let selectedAmpacity = 0;

        const awgKeys = Object.keys(DEFAULTS.AWG_DATA).map(Number).sort((a, b) => b - a);

        for (const awg of awgKeys) {
            const data = DEFAULTS.AWG_DATA[awg];
            if (data.mm2 >= minAreaVdrop && data.ampConduit >= current) {
                selectedAWG = awg;
                selectedMm2 = data.mm2;
                selectedAmpacity = data.ampConduit;
                break;
            }
        }

        if (selectedAWG === null) {
            // Need parallel runs or larger conductor
            const maxPracticalMm2 = 107.22;
            if (minAreaVdrop > maxPracticalMm2) {
                parallelCables = Math.ceil(minAreaVdrop / maxPracticalMm2);
                selectedMm2 = maxPracticalMm2;
                selectedAWG = -3;
                selectedAmpacity = DEFAULTS.AWG_DATA['-3'].ampConduit * parallelCables;
                warnings.push(
                    `Requires ${parallelCables}x 4/0 AWG (${maxPracticalMm2.toFixed(1)}mm2) cables in parallel`
                );
            } else {
                // Find closest metric size
                for (const mm2 of DEFAULTS.METRIC_CABLE_SIZES) {
                    if (mm2 >= minAreaVdrop) {
                        selectedMm2 = mm2;
                        break;
                    }
                }
                if (selectedMm2 === 0) {
                    selectedMm2 = DEFAULTS.METRIC_CABLE_SIZES[DEFAULTS.METRIC_CABLE_SIZES.length - 1];
                }
                selectedAWG = -3;
                selectedAmpacity = DEFAULTS.AWG_DATA['-3'].ampConduit;
                warnings.push(`Use ${selectedMm2.toFixed(1)}mm2 metric cable`);
            }
        }

        // Calculate actual voltage drop
        const effectiveMm2 = selectedMm2 * parallelCables;
        const actualResistance = DEFAULTS.COPPER_RESISTIVITY * length * 2 / effectiveMm2;
        const actualDropV = current * actualResistance;
        const actualDropPercent = actualDropV / voltage;

        // Check ampacity
        if (selectedAmpacity < current) {
            const parallelNeeded = Math.ceil(current / selectedAmpacity);
            if (parallelNeeded > parallelCables) {
                parallelCables = parallelNeeded;
                warnings.push(`Ampacity requires ${parallelCables} parallel cables`);
                selectedAmpacity *= parallelCables;
            }
        }

        // AWG label
        let awgLabel = selectedAWG.toString();
        if (selectedAWG === 0) awgLabel = '1/0';
        else if (selectedAWG === -1) awgLabel = '2/0';
        else if (selectedAWG === -2) awgLabel = '3/0';
        else if (selectedAWG === -3) awgLabel = '4/0';

        // Market-standard metric cable sizing
        const computedMm2 = Math.round(selectedMm2 * 100) / 100;
        const marketMm2 = this.findMarketMetricSize(computedMm2);
        const marketAmpacity = this.getMetricAmpacity(marketMm2);
        const marketAWGEquiv = this.findClosestAWG(marketMm2);

        // Check if market cable meets ampacity for the current
        let marketAmpacityOK = marketAmpacity >= current || parallelCables > 1;
        let finalMarketMm2 = marketMm2;
        if (!marketAmpacityOK && parallelCables <= 1) {
            // Upsize market cable to meet ampacity
            for (const size of DEFAULTS.METRIC_CABLE_SIZES) {
                if (size >= computedMm2 && (DEFAULTS.METRIC_CABLE_AMPACITY[size] || 0) >= current) {
                    finalMarketMm2 = size;
                    marketAmpacityOK = true;
                    break;
                }
            }
        }

        // Build display strings
        const isSameSize = computedMm2 === finalMarketMm2;
        const sizeRangeDisplay = isSameSize
            ? `${finalMarketMm2}mm²`
            : `${computedMm2} – ${finalMarketMm2}mm²`;

        return {
            name,
            current: Math.round(current * 10) / 10,
            voltage: Math.round(voltage * 10) / 10,
            lengthM: length,
            isDC,
            recommendedAWG: awgLabel,
            recommendedMm2: computedMm2,
            marketMm2: finalMarketMm2,
            marketAWGEquiv,
            marketAmpacity: DEFAULTS.METRIC_CABLE_AMPACITY[finalMarketMm2] || 0,
            sizeRangeDisplay,
            actualVoltageDropPercent: Math.round(actualDropPercent * 10000) / 100,
            ampacityRating: selectedAmpacity,
            ampacityOK: selectedAmpacity >= current,
            voltageDropOK: actualDropPercent <= maxDrop,
            parallelCables,
            warnings
        };
    },

    /**
     * Calculate all cable sizes
     */
    calculate(inverterReq, batteryReq, pvDesign, config, cableLengths, panel, mppt) {
        const warnings = [];
        const blocks = [];
        const suggestions = [];
        const dcRuns = [];
        const acRuns = [];

        // 1. PV String cables
        const pvStringRun = this.sizeCable(
            'PV String Cable (per string)',
            panel.isc * DEFAULTS.NEC_CONTINUOUS_FACTOR,
            pvDesign.stringVmp,
            cableLengths.pvToMPPT,
            true,
            DEFAULTS.DC_VOLTAGE_DROP_TARGET
        );
        dcRuns.push(pvStringRun);

        // 2. PV Array to MPPT
        const pvArrayRun = this.sizeCable(
            'PV Array to MPPT',
            pvDesign.arrayIsc * DEFAULTS.NEC_CONTINUOUS_FACTOR,
            pvDesign.stringVmp,
            cableLengths.pvToMPPT,
            true,
            DEFAULTS.DC_VOLTAGE_DROP_TARGET
        );
        dcRuns.push(pvArrayRun);

        // 3. MPPT to Battery
        const chargeCurrent = Math.min(mppt.maxChargeCurrent || 60, batteryReq.maxChargeCurrent) * DEFAULTS.NEC_CONTINUOUS_FACTOR;
        const mpptBatteryRun = this.sizeCable(
            'MPPT to Battery',
            chargeCurrent,
            batteryReq.bankVoltage,
            cableLengths.mpptToBatt,
            true,
            DEFAULTS.DC_VOLTAGE_DROP_TARGET * 0.5
        );
        dcRuns.push(mpptBatteryRun);

        // 4. Battery to Inverter
        const batteryInverterRun = this.sizeCable(
            'Battery to Inverter',
            inverterReq.dcInputCurrentSurge * DEFAULTS.NEC_CONTINUOUS_FACTOR,
            inverterReq.dcBusVoltage,
            cableLengths.battToInv,
            true,
            DEFAULTS.DC_VOLTAGE_DROP_TARGET * 0.5
        );
        dcRuns.push(batteryInverterRun);

        // 5. Inverter AC Output
        const acCurrent = inverterReq.continuousVARequired / config.acVoltage * DEFAULTS.NEC_CONTINUOUS_FACTOR;
        const inverterOutputRun = this.sizeCable(
            'Inverter AC Output',
            acCurrent,
            config.acVoltage,
            cableLengths.invToLoad,
            false,
            DEFAULTS.AC_VOLTAGE_DROP_TARGET
        );
        acRuns.push(inverterOutputRun);

        // Aggregate warnings
        for (const run of [...dcRuns, ...acRuns]) {
            if (!run.ampacityOK) {
                blocks.push(`${run.name}: Current ${run.current}A exceeds cable ampacity`);
                suggestions.push(`${run.name}: Use parallel cables or increase cable size`);
            }
            if (!run.voltageDropOK) {
                warnings.push(`${run.name}: Voltage drop ${run.actualVoltageDropPercent.toFixed(2)}% exceeds target`);
            }
            if (run.parallelCables > 1) {
                warnings.push(`${run.name}: Requires ${run.parallelCables} parallel cables`);
            }
            warnings.push(...run.warnings);
        }

        // Calculate total copper
        const totalLength = [...dcRuns, ...acRuns].reduce((sum, r) => sum + r.lengthM * 2 * r.parallelCables, 0);
        const totalMm2 = [...dcRuns, ...acRuns].reduce((sum, r) => sum + r.recommendedMm2 * r.lengthM * 2 * r.parallelCables, 0);
        const copperKg = totalMm2 * 0.00894;

        return {
            dcRuns,
            acRuns,
            totalCopperLengthM: Math.round(totalLength * 10) / 10,
            estimatedCopperKg: Math.round(copperKg * 100) / 100,
            warnings,
            blocks,
            suggestions
        };
    }
};

/* =============================================================================
   PHASE 8: PROTECTION ENGINE
   ============================================================================= */

const ProtectionEngine = {
    // Standard MCCB sizes (Amps)
    MCCB_SIZES: [16, 20, 25, 32, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400],
    // Standard MCB sizes (Amps)
    MCB_SIZES: [6, 10, 16, 20, 25, 32, 40, 50, 63],
    // Standard DC fuse sizes — Class T / ANL (Amps)
    DC_FUSE_SIZES: [30, 40, 50, 60, 80, 100, 125, 150, 175, 200, 250, 300, 350, 400, 500, 600],

    /**
     * Select next standard MCCB size above required amps
     */
    selectMCCB(requiredAmps) {
        for (const size of this.MCCB_SIZES) {
            if (size >= requiredAmps) return size;
        }
        return Math.ceil(requiredAmps / 50) * 50;
    },

    /**
     * Select next standard MCB size above required amps
     */
    selectMCB(requiredAmps) {
        for (const size of this.MCB_SIZES) {
            if (size >= requiredAmps) return size;
        }
        return Math.ceil(requiredAmps / 10) * 10;
    },

    /**
     * Select next standard DC fuse size above required amps
     */
    selectDCFuse(requiredAmps) {
        for (const size of this.DC_FUSE_SIZES) {
            if (size >= requiredAmps) return size;
        }
        return Math.ceil(requiredAmps / 100) * 100;
    },

    /**
     * Design complete protection scheme
     */
    design(inverterReq, batteryReq, pvDesign, config, manualBreakers) {
        const warnings = [];
        const pvSide = [];
        const batterySide = [];
        const acSide = [];
        const earthing = [];
        manualBreakers = manualBreakers || {};

        // ---- PV SIDE PROTECTION ----

        // String Fuses (required when >1 parallel string)
        if (pvDesign.stringsInParallel > 1) {
            const stringFuseRating = Math.ceil(pvDesign.arrayIsc / pvDesign.stringsInParallel * 1.56 / 5) * 5;
            pvSide.push({
                name: 'String Fuse (per string)',
                type: 'DC Fuse',
                rating: `${stringFuseRating}A / ${Math.round(pvDesign.stringVocCold + 50)}VDC`,
                location: 'In each string positive conductor',
                purpose: 'Protect against reverse current from parallel strings',
                mandatory: true
            });
        }

        // PV DC Isolator / Breaker
        const pvIsolatorCalc = Math.ceil(pvDesign.arrayIsc * 1.25);
        const pvIsolatorRating = this.selectMCB(pvIsolatorCalc);
        const pvVoltageRating = Math.round(pvDesign.stringVocCold + 50);

        // Check if user provided manual PV breaker
        if (manualBreakers.pvDC > 0) {
            const manualPV = manualBreakers.pvDC;
            pvSide.push({
                name: 'PV DC Isolator / Breaker',
                type: 'DC Disconnect Switch',
                rating: `${manualPV}A / ${pvVoltageRating}VDC`,
                location: 'Before MPPT/inverter PV input',
                purpose: 'Safe isolation for maintenance',
                mandatory: true,
                isManual: true,
                autoSuggested: pvIsolatorRating
            });
            if (manualPV < pvIsolatorCalc) {
                warnings.push(`PV DC breaker (${manualPV}A) is undersized. Min required: ${pvIsolatorCalc}A (Isc x 1.25). Recommended: ${pvIsolatorRating}A standard size.`);
            } else if (manualPV > pvIsolatorRating * 2) {
                warnings.push(`PV DC breaker (${manualPV}A) is oversized. May not trip on fault. Recommended: ${pvIsolatorRating}A.`);
            }
        } else {
            pvSide.push({
                name: 'PV DC Isolator / Breaker',
                type: 'DC Disconnect Switch',
                rating: `${pvIsolatorRating}A / ${pvVoltageRating}VDC`,
                location: 'Before MPPT/inverter PV input',
                purpose: 'Safe isolation for maintenance',
                mandatory: true
            });
        }

        // PV DC SPD
        pvSide.push({
            name: 'PV DC SPD',
            type: 'Surge Protection Device (Type 2)',
            rating: `Type 2 / ${Math.round(pvDesign.stringVocCold * 1.2)}VDC`,
            location: 'At combiner box or MPPT input',
            purpose: 'Lightning and surge protection',
            mandatory: false
        });

        // Combiner box for larger arrays
        if (pvDesign.stringsInParallel > 2) {
            pvSide.push({
                name: 'PV Combiner Box',
                type: 'Junction Box with fuses',
                rating: `${pvDesign.stringsInParallel} string inputs`,
                location: 'Near PV array, before cable run to inverter',
                purpose: 'Combine parallel strings with individual fuse protection',
                mandatory: true
            });
        }

        // ---- BATTERY SIDE PROTECTION ----

        // DC MCCB (Battery-Inverter) — the primary DC protection device
        const battMCCBCalc = batteryReq.maxDischargeCurrent * 1.25;
        const battMCCBRating = this.selectMCCB(battMCCBCalc);

        if (manualBreakers.battDC > 0) {
            const manualBatt = manualBreakers.battDC;
            batterySide.push({
                name: 'DC MCCB (Battery-Inverter)',
                type: 'DC Moulded Case Circuit Breaker',
                rating: `${manualBatt}A / ${batteryReq.bankVoltage}VDC`,
                location: 'Between battery bank positive terminal and inverter DC input',
                purpose: 'Main DC overcurrent protection and isolation for battery-inverter link',
                mandatory: true,
                isManual: true,
                autoSuggested: battMCCBRating
            });
            if (manualBatt < Math.ceil(battMCCBCalc)) {
                warnings.push(`Battery DC MCCB (${manualBatt}A) is undersized. Min required: ${Math.ceil(battMCCBCalc)}A (max discharge x 1.25). Recommended standard size: ${battMCCBRating}A.`);
            } else if (manualBatt > battMCCBRating * 2) {
                warnings.push(`Battery DC MCCB (${manualBatt}A) is oversized. May not trip on fault. Recommended: ${battMCCBRating}A.`);
            }
        } else {
            batterySide.push({
                name: 'DC MCCB (Battery-Inverter)',
                type: 'DC Moulded Case Circuit Breaker',
                rating: `${battMCCBRating}A / ${batteryReq.bankVoltage}VDC`,
                location: 'Between battery bank positive terminal and inverter DC input',
                purpose: 'Main DC overcurrent protection and isolation for battery-inverter link',
                mandatory: true
            });
        }

        // Battery Fuse (backup short-circuit protection)
        const battFuseCalc = battMCCBRating * 1.5;
        const battFuseRating = this.selectDCFuse(battFuseCalc);
        batterySide.push({
            name: 'Battery Fuse (Backup)',
            type: 'DC Fuse (Class T / ANL)',
            rating: `${battFuseRating}A / ${batteryReq.bankVoltage}VDC`,
            location: 'Between battery positive terminal and DC MCCB',
            purpose: 'Backup short-circuit protection — trips faster than MCCB on dead short',
            mandatory: true
        });

        // BMS for LiFePO4
        if (batteryReq.chemistry === 'lifepo4') {
            batterySide.push({
                name: 'Battery Management System (BMS)',
                type: 'BMS',
                rating: `${batteryReq.totalCapacityAh}Ah / ${batteryReq.cellsInSeries}S`,
                location: 'Integrated with battery bank',
                purpose: 'Cell balancing, over/under voltage, temperature, short-circuit protection',
                mandatory: true
            });
            warnings.push('LiFePO4 REQUIRES proper BMS — do not operate without! Ensure BMS communication (CAN/RS485) is connected to inverter if supported.');
        }

        // ---- AC SIDE PROTECTION ----

        const acBreakerCalc = inverterReq.continuousVARequired / config.acVoltage * 1.25;
        const acBreakerRating = this.selectMCB(acBreakerCalc);

        if (manualBreakers.ac > 0) {
            const manualAC = manualBreakers.ac;
            acSide.push({
                name: 'Inverter Output MCB',
                type: 'AC Miniature Circuit Breaker',
                rating: `${manualAC}A / ${config.acVoltage}VAC`,
                location: 'Inverter AC output to distribution board',
                purpose: 'AC overcurrent protection',
                mandatory: true,
                isManual: true,
                autoSuggested: acBreakerRating
            });
            if (manualAC < Math.ceil(acBreakerCalc)) {
                warnings.push(`AC MCB (${manualAC}A) is undersized. Min required: ${Math.ceil(acBreakerCalc)}A. Recommended: ${acBreakerRating}A.`);
            } else if (manualAC > acBreakerRating * 2) {
                warnings.push(`AC MCB (${manualAC}A) is oversized. May not protect wiring. Recommended: ${acBreakerRating}A.`);
            }
        } else {
            acSide.push({
                name: 'Inverter Output MCB',
                type: 'AC Miniature Circuit Breaker',
                rating: `${acBreakerRating}A / ${config.acVoltage}VAC`,
                location: 'Inverter AC output to distribution board',
                purpose: 'AC overcurrent protection',
                mandatory: true
            });
        }

        acSide.push({
            name: 'AC SPD',
            type: 'Surge Protection Device (Type 2)',
            rating: `Type 2 / ${config.acVoltage}VAC`,
            location: 'Main AC distribution board',
            purpose: 'Surge protection for connected loads',
            mandatory: false
        });

        // AVR (Automatic Voltage Regulator)
        // Standard AVR sizes: 1kVA, 2kVA, 3kVA, 5kVA, 8kVA, 10kVA, 15kVA, 20kVA, 30kVA
        const avrSizes = [1000, 2000, 3000, 5000, 8000, 10000, 15000, 20000, 30000];
        const avrRequired = inverterReq.continuousVARequired * 1.2; // 20% margin over continuous load
        let avrRating = avrSizes.find(s => s >= avrRequired) || Math.ceil(avrRequired / 5000) * 5000;

        acSide.push({
            name: 'Automatic Voltage Regulator (AVR)',
            type: 'Servo Motor / Relay-type AVR',
            rating: `${(avrRating / 1000).toFixed(avrRating >= 1000 ? 0 : 1)}kVA / ${config.acVoltage}VAC`,
            location: 'Between utility/grid input and transfer switch (or inverter AC input if grid-tied/hybrid)',
            purpose: 'Stabilizes incoming AC voltage to protect equipment from under/over voltage. Critical in areas with unstable grid supply.',
            mandatory: false,
            notes: inverterReq.continuousVARequired > 5000 ?
                'For loads above 5kVA, use a servo-motor type AVR for better regulation accuracy (±2-3%). Relay-type AVRs have wider tolerance (±5-8%).' :
                'Relay-type AVR is sufficient for this load range. Consider servo-motor type if voltage fluctuations exceed ±15%.'
        });

        // ---- EARTHING ----

        earthing.push({
            name: 'Equipment Earth',
            type: 'Earth Conductor',
            rating: '6mm2 minimum copper (green/yellow)',
            location: 'All metallic enclosures — inverter, panels frame, battery rack, combiner',
            purpose: 'Equipment fault protection per IEC 62109',
            mandatory: true
        });

        earthing.push({
            name: 'Earth Electrode',
            type: 'Earth Rod (Copper-bonded steel, min 1.5m)',
            rating: 'Target < 10 ohm impedance',
            location: 'Near array/inverter location, driven into ground',
            purpose: 'Fault current path to ground',
            mandatory: true
        });

        return { pvSide, batterySide, acSide, earthing, warnings };
    }
};

/* =============================================================================
   PHASE 9: SYSTEM LOSSES ENGINE
   ============================================================================= */

const SystemLossEngine = {
    /**
     * Calculate comprehensive system losses
     */
    calculate(aggregatedLoad, batteryReq, pvDesign, cableSizing, config) {
        const batterySpecs = DEFAULTS.BATTERY_SPECS[batteryReq.chemistry];

        // Component efficiencies
        const inverterEff = DEFAULTS.INVERTER_EFFICIENCY;
        const batteryRoundTrip = batterySpecs.chargeEfficiency * batterySpecs.dischargeEfficiency;
        const mpptEff = DEFAULTS.MPPT_EFFICIENCY;

        // PV losses
        const tempDelta = config.ambientTempMax - DEFAULTS.STC_TEMP;
        const pvTempDerating = Math.abs(-0.35 / 100 * tempDelta);
        const pvSoilingLoss = DEFAULTS.PV_SOILING_LOSS;
        const pvMismatchLoss = DEFAULTS.PV_MISMATCH_LOSS;

        // Cable losses (estimate from sizing results)
        const dcCableLoss = DEFAULTS.CABLE_LOSS_FACTOR;
        const acCableLoss = DEFAULTS.CABLE_LOSS_FACTOR / 2;

        // Total losses
        const totalDCLosses = pvTempDerating + pvSoilingLoss + pvMismatchLoss + dcCableLoss;
        const totalACLosses = acCableLoss + (1 - inverterEff);

        // Overall system efficiency
        const overallEfficiency = (1 - totalDCLosses) * batteryRoundTrip * inverterEff * (1 - acCableLoss);

        // Energy analysis
        const grossPVEnergy = pvDesign.dailyEnergyWh;
        const netAvailableEnergy = grossPVEnergy * overallEfficiency;
        const loadRequirement = aggregatedLoad.dailyEnergyWh;
        const energyMargin = ((netAvailableEnergy - loadRequirement) / loadRequirement) * 100;

        return {
            inverterEfficiency: Math.round(inverterEff * 1000) / 10,
            batteryRoundTripEfficiency: Math.round(batteryRoundTrip * 1000) / 10,
            mpptEfficiency: Math.round(mpptEff * 1000) / 10,
            pvTempDerating: Math.round(pvTempDerating * 1000) / 10,
            pvSoilingLoss: Math.round(pvSoilingLoss * 1000) / 10,
            pvMismatchLoss: Math.round(pvMismatchLoss * 1000) / 10,
            dcCableLoss: Math.round(dcCableLoss * 1000) / 10,
            acCableLoss: Math.round(acCableLoss * 1000) / 10,
            totalDCLosses: Math.round(totalDCLosses * 1000) / 10,
            totalACLosses: Math.round(totalACLosses * 1000) / 10,
            overallSystemEfficiency: Math.round(overallEfficiency * 1000) / 10,
            grossPVEnergyDaily: Math.round(grossPVEnergy),
            netAvailableEnergyDaily: Math.round(netAvailableEnergy),
            loadRequirementDaily: Math.round(loadRequirement),
            energyMarginPercent: Math.round(energyMargin * 10) / 10
        };
    }
};

/* =============================================================================
   PHASE 10: UPGRADE PATH ENGINE
   Comprehensive upgrade analysis with battery limits, MPPT expansion,
   cable/breaker reassessment, and load growth simulation
   ============================================================================= */

const UpgradeSimulator = {
    // Battery parallel limits by chemistry (manufacturer typical maximums)
    BATTERY_PARALLEL_LIMITS: {
        lifepo4: { maxParallel: 6, reason: 'LiFePO4 BMS synchronization limit — most manufacturers allow up to 6 units in parallel with CAN/RS485 communication' },
        agm: { maxParallel: 4, reason: 'AGM lead-acid — more than 4 parallel strings causes uneven charging and shortened lifespan due to current imbalance' },
        gel: { maxParallel: 4, reason: 'Gel batteries are sensitive to overcharge — more than 4 parallel strings makes balanced charging very difficult' },
        fla: { maxParallel: 4, reason: 'Flooded lead-acid — parallel strings must be identical age and capacity. More than 4 strings is impractical to maintain' }
    },

    /**
     * Generate comprehensive upgrade analysis for the current system design
     */
    analyzeUpgradePaths(results, panel, mppt, config) {
        const paths = [];
        const batteryChemistry = results.battery.chemistry;
        const battSpec = DEFAULTS.BATTERY_SPECS[batteryChemistry];
        const parallelLimit = this.BATTERY_PARALLEL_LIMITS[batteryChemistry] || { maxParallel: 4, reason: 'General safety limit' };

        // ---- 1. BATTERY EXPANSION ----
        const currentAh = results.battery.totalCapacityAh;
        const bankVoltage = results.battery.bankVoltage;
        const singleBattAh = results.battery.batteryAh || currentAh;
        const currentParallelStrings = results.battery.parallelStrings || 1;
        const maxAdditionalStrings = parallelLimit.maxParallel - currentParallelStrings;

        const batteryPath = {
            category: 'Battery Expansion',
            icon: '&#128267;',
            current: `${currentAh}Ah @ ${bankVoltage}V (${currentParallelStrings} parallel string${currentParallelStrings > 1 ? 's' : ''})`,
            options: []
        };

        if (maxAdditionalStrings > 0) {
            for (let add = 1; add <= Math.min(maxAdditionalStrings, 3); add++) {
                const newTotal = currentParallelStrings + add;
                const newAh = Math.round(singleBattAh * newTotal);
                const newKwh = Math.round(newAh * bankVoltage / 100) / 10;
                const usableKwh = Math.round(newKwh * battSpec.maxDoD * 10) / 10;
                const autonomyHrs = Math.round(usableKwh * 1000 / (results.aggregation.dailyEnergyWh / 24) * 10) / 10;

                batteryPath.options.push({
                    label: `Add ${add} battery string${add > 1 ? 's' : ''} (${newTotal} total)`,
                    detail: `${newAh}Ah / ${newKwh}kWh total (${usableKwh}kWh usable at ${battSpec.maxDoD * 100}% DoD)`,
                    impact: `Autonomy: ~${autonomyHrs} hours at current load`,
                    feasible: true,
                    notes: add === maxAdditionalStrings ? `This is the maximum for ${batteryChemistry.toUpperCase()} — ${parallelLimit.reason}` : null
                });
            }
        } else {
            batteryPath.options.push({
                label: 'Maximum parallel strings reached',
                detail: `${currentParallelStrings} of ${parallelLimit.maxParallel} parallel strings already in use`,
                impact: parallelLimit.reason,
                feasible: false,
                notes: `To increase capacity further: (1) Upgrade to higher Ah individual batteries, or (2) Switch to a ${bankVoltage === 48 ? 'higher voltage battery system' : '48V bank'} with larger per-unit capacity`
            });
        }
        paths.push(batteryPath);

        // ---- 2. PV ARRAY / PANEL EXPANSION ----
        const currentPanels = results.pvArray.totalPanels;
        const currentWatts = results.pvArray.arrayWattage;
        const pvPath = {
            category: 'PV Array Expansion',
            icon: '&#9728;',
            current: `${currentPanels} × ${panel.wattage}W = ${currentWatts}W`,
            options: []
        };

        // Check how many more panels the current MPPT can handle
        const tempDeltaCold = (config.ambientTempMin || 20) - DEFAULTS.STC_TEMP;
        const vocTempFactor = 1 + (panel.tempCoeffVoc / 100 * tempDeltaCold);
        const vocCold = panel.voc * vocTempFactor;
        const maxSeriesPerMPPT = Math.floor(mppt.maxVoltage / vocCold);
        const maxPanelsByPower = Math.floor(mppt.maxPower / panel.wattage);
        const maxPanelsByCurrent = Math.floor(mppt.maxCurrent / (panel.isc * 1.04));
        const maxPanelsOnCurrentMPPT = Math.min(maxSeriesPerMPPT * maxPanelsByCurrent, maxPanelsByPower);

        const roomOnCurrentMPPT = maxPanelsOnCurrentMPPT - currentPanels;

        if (roomOnCurrentMPPT > 0) {
            const addPanels = Math.min(roomOnCurrentMPPT, currentPanels); // up to doubling
            for (const addCount of [Math.min(2, roomOnCurrentMPPT), Math.min(4, roomOnCurrentMPPT), Math.min(roomOnCurrentMPPT, 8)].filter((v, i, a) => v > 0 && a.indexOf(v) === i)) {
                const newTotal = currentPanels + addCount;
                const newWatts = newTotal * panel.wattage;
                // Find best config for new total
                const bestCfg = ConfigurationComparisonEngine.compare(newTotal, panel, mppt, config);
                const rec = bestCfg.recommended >= 0 ? bestCfg.configurations[bestCfg.recommended] : null;

                pvPath.options.push({
                    label: `Add ${addCount} panels (${newTotal} total, ${newWatts}W)`,
                    detail: rec ? `Best config: ${rec.label} — Voc(cold): ${rec.stringVocCold}V, Isc: ${rec.arrayIsc}A` : 'No valid single-MPPT config found — add another MPPT',
                    impact: `+${Math.round(addCount * panel.wattage * config.avgPSH)}Wh/day estimated additional energy`,
                    feasible: rec !== null,
                    notes: rec ? null : 'Exceeds single MPPT capacity — requires additional MPPT controller'
                });
            }
        }

        // Suggest adding MPPT for larger expansions
        if (roomOnCurrentMPPT <= 2 || currentPanels >= maxPanelsOnCurrentMPPT * 0.8) {
            const additionalMPPTCapacity = 3000; // typical external MPPT
            const extraPanels = Math.floor(additionalMPPTCapacity / panel.wattage);
            pvPath.options.push({
                label: `Add external MPPT controller + ${extraPanels} panels`,
                detail: `New MPPT (e.g., 3000W / 60A / 150V) handling ${extraPanels} × ${panel.wattage}W = ${extraPanels * panel.wattage}W separately`,
                impact: `Total system: ${currentWatts + extraPanels * panel.wattage}W. Each MPPT tracks independently for maximum harvest.`,
                feasible: true,
                notes: 'Requires separate PV DC breaker and cabling for the new MPPT input. Both MPPTs charge the same battery bank.'
            });
        }
        paths.push(pvPath);

        // ---- 3. INVERTER UPGRADE ----
        const currentInvVA = results.inverter.recommendedSizeVA;
        const loadUtilization = Math.round(results.aggregation.designContinuousVA / currentInvVA * 100);
        const inverterPath = {
            category: 'Inverter Capacity',
            icon: '&#9889;',
            current: `${currentInvVA}VA (${loadUtilization}% utilized)`,
            options: []
        };

        if (loadUtilization > 70) {
            const sizes = [5000, 6000, 8000, 10000, 12000, 15000].filter(s => s > currentInvVA);
            sizes.slice(0, 2).forEach(size => {
                const newUtil = Math.round(results.aggregation.designContinuousVA / size * 100);
                inverterPath.options.push({
                    label: `Upgrade to ${size}VA inverter`,
                    detail: `Load utilization drops to ${newUtil}%. Surge capacity: ${Math.round(size * (config.inverterSurgeMultiplier || 2))}VA`,
                    impact: `Can add ~${Math.round((size - results.aggregation.designContinuousVA) * 0.8)}VA more loads before next upgrade`,
                    feasible: true,
                    notes: size > 5000 && bankVoltage < 48 ? 'Inverters above 5kVA typically require 48V DC bus' : null
                });
            });
        } else {
            inverterPath.options.push({
                label: 'No inverter upgrade needed currently',
                detail: `Running at ${loadUtilization}% — plenty of headroom`,
                impact: `Can add ~${Math.round((currentInvVA - results.aggregation.designContinuousVA) * 0.8)}VA more loads on current inverter`,
                feasible: true,
                notes: null
            });
        }
        paths.push(inverterPath);

        // ---- 4. CABLE & BREAKER REASSESSMENT ----
        const protectionPath = {
            category: 'Cables & Protection',
            icon: '&#128268;',
            current: 'Sized for current system',
            options: []
        };

        // If panels expand, PV cable may need upgrade
        if (roomOnCurrentMPPT > 0) {
            const futureIsc = (currentPanels + Math.min(roomOnCurrentMPPT, 4)) * panel.isc * 1.04 / maxSeriesPerMPPT;
            protectionPath.options.push({
                label: 'PV DC Cable & Breaker',
                detail: `Current array Isc: ${results.pvArray.arrayIsc}A. After adding panels: up to ${futureIsc.toFixed(1)}A`,
                impact: futureIsc > results.pvArray.arrayIsc * 1.3 ? 'May need thicker PV DC cable and larger breaker' : 'Current cabling should be sufficient',
                feasible: true,
                notes: 'Always verify cable ampacity after adding panels. String fuses required when parallel strings > 1.'
            });
        }

        // Battery cable with more parallel strings
        if (maxAdditionalStrings > 0) {
            const futureDischarge = (currentParallelStrings + 1) * singleBattAh * (battSpec.maxDischargeRate || 0.5);
            protectionPath.options.push({
                label: 'Battery DC Cable & MCCB',
                detail: `Adding battery strings increases max discharge current to ~${Math.round(futureDischarge)}A`,
                impact: futureDischarge > results.battery.maxDischargeCurrent * 1.2 ? 'Battery MCCB and cables will need upgrading' : 'Current battery protection should handle one additional string',
                feasible: true,
                notes: 'Each parallel battery string should have its own fuse. Battery MCCB must be rated for total bank discharge current.'
            });
        }
        paths.push(protectionPath);

        // ---- 5. LOAD GROWTH SCENARIOS ----
        const loadGrowthPath = {
            category: 'Load Growth Scenarios',
            icon: '&#128200;',
            current: `${Math.round(results.aggregation.dailyEnergyWh)}Wh/day, ${Math.round(results.aggregation.peakSimultaneousVA)}VA peak`,
            options: []
        };

        // Common load additions
        const commonAdditions = [
            { name: 'Air Conditioner (1HP)', watts: 1000, hours: 6, surge: 3 },
            { name: 'Electric Iron (2kW)', watts: 2000, hours: 0.5, surge: 1 },
            { name: 'Washing Machine', watts: 500, hours: 1, surge: 3 },
            { name: 'Microwave Oven', watts: 1200, hours: 0.5, surge: 1.2 },
            { name: 'Desktop Computer + Monitor', watts: 350, hours: 8, surge: 1.5 }
        ];

        for (const load of commonAdditions) {
            const addedWh = load.watts * load.hours;
            const newDailyWh = results.aggregation.dailyEnergyWh + addedWh;
            const newPeakVA = results.aggregation.peakSimultaneousVA + load.watts * load.surge;
            const invOk = newPeakVA <= currentInvVA * (config.inverterSurgeMultiplier || 2);
            const battOk = newDailyWh <= results.battery.totalCapacityWh * battSpec.maxDoD;
            const pvOk = newDailyWh <= results.pvArray.dailyEnergyWh * 0.9;

            const issues = [];
            if (!invOk) issues.push('Inverter surge capacity exceeded');
            if (!battOk) issues.push('Battery storage insufficient for autonomy');
            if (!pvOk) issues.push('PV array undersized for new daily energy');

            loadGrowthPath.options.push({
                label: `Add ${load.name} (${load.watts}W, ${load.hours}h/day)`,
                detail: `New daily energy: ${Math.round(newDailyWh)}Wh (+${Math.round(addedWh)}Wh). Peak VA with surge: ${Math.round(newPeakVA)}VA`,
                impact: issues.length === 0 ? 'System can handle this addition without upgrades' : `Requires upgrades: ${issues.join(', ')}`,
                feasible: issues.length === 0,
                notes: null
            });
        }
        paths.push(loadGrowthPath);

        return paths;
    }
};

/* =============================================================================
   CONFIGURATION COMPARISON ENGINE
   Generates and scores all valid panel configurations
   ============================================================================= */

const ConfigurationComparisonEngine = {
    /**
     * Generate all valid configurations for given panel count + MPPT specs
     */
    compare(numPanels, panel, mppt, config) {
        const configs = [];
        const seen = new Set(); // track unique S×P combos to avoid duplicates
        const tempDeltaCold = (config.ambientTempMin || 20) - DEFAULTS.STC_TEMP;
        const vocTempFactor = 1 + (panel.tempCoeffVoc / 100 * tempDeltaCold);
        const vocCold = panel.voc * vocTempFactor;

        // Isc with tolerance (typical +4% for real panels)
        const iscTolerance = panel.isc * 1.04;

        // Determine feasible series range — use actual limits, not reduced
        const absMaxSeries = Math.floor(mppt.maxVoltage / vocCold);
        const absMinSeries = Math.max(1, Math.ceil((mppt.minVoltage || 60) / panel.vmp));

        // Try both ceil and floor for parallel count to find configs using
        // exact, fewer, or slightly more panels than requested
        const parallelCandidates = (s) => {
            const candidates = new Set();
            const pCeil = Math.ceil(numPanels / s);
            const pFloor = Math.floor(numPanels / s);
            if (pCeil >= 1) candidates.add(pCeil);
            if (pFloor >= 1) candidates.add(pFloor);
            candidates.add(1); // always try single string
            return [...candidates];
        };

        for (let s = absMinSeries; s <= Math.min(absMaxSeries, numPanels); s++) {
            for (const p of parallelCandidates(s)) {
            const key = `${s}x${p}`;
            if (seen.has(key)) continue;
            seen.add(key);
            const actualPanels = s * p;

            const stringVmp = Math.round(s * panel.vmp * 100) / 100;
            const stringVoc = Math.round(s * panel.voc * 100) / 100;
            const stringVocCold = Math.round(s * vocCold * 100) / 100;
            const arrayImp = Math.round(p * panel.imp * 100) / 100;
            const arrayIsc = Math.round(p * panel.isc * 100) / 100;
            const arrayIscTol = Math.round(p * iscTolerance * 100) / 100;
            const totalPower = actualPanels * panel.wattage;

            // All checks
            const vocOk = stringVocCold < mppt.maxVoltage;
            const vmpMaxOk = stringVmp <= (mppt.maxOperatingVoltage || mppt.maxVoltage * 0.9);
            const vmpMinOk = stringVmp >= (mppt.minVoltage || 60);
            const currentOk = arrayIscTol <= mppt.maxCurrent;
            const powerOk = totalPower <= mppt.maxPower;
            const startupOk = stringVmp >= (mppt.minVoltage || 60);
            const valid = vocOk && vmpMaxOk && vmpMinOk && currentOk && powerOk && startupOk;

            // Score (higher = better, only for valid configs)
            const vocMargin = vocOk ? Math.round((1 - stringVocCold / mppt.maxVoltage) * 1000) / 10 : 0;
            const currentMargin = currentOk ? Math.round((1 - arrayIscTol / mppt.maxCurrent) * 1000) / 10 : 0;
            const powerUtil = Math.round(totalPower / mppt.maxPower * 1000) / 10;
            const extraPanelPenalty = Math.abs(actualPanels - numPanels) * 10;

            let score = 0;
            if (valid) {
                score = vocMargin * 0.3 + currentMargin * 0.3 + (100 - Math.abs(powerUtil - 70)) * 0.2 - extraPanelPenalty;
            }

            // Generate pros/cons
            const pros = [];
            const cons = [];

            if (p === 1) {
                pros.push('Simpler wiring - single string, no combiner needed');
                pros.push('Lower current - easier on cables and connectors');
                cons.push('No redundancy - shading one panel affects entire string');
            } else if (p === 2) {
                pros.push('Redundancy - if one string is shaded, other still produces');
                cons.push('Higher total current - needs thicker cables');
                if (currentMargin < 15) cons.push('Current very close to input limit');
            } else {
                pros.push('Good redundancy across multiple strings');
                cons.push('Complex wiring - combiner box recommended');
                cons.push('Higher current requires attention to cable sizing');
            }

            if (vocMargin > 20) pros.push(`Good voltage headroom (${vocMargin}% below Voc limit)`);
            else if (vocMargin < 10 && vocOk) cons.push(`Tight voltage headroom (only ${vocMargin}%)`);

            if (stringVmp > 200) pros.push('Higher string voltage = lower current losses in cables');
            if (actualPanels > numPanels) cons.push(`Needs ${actualPanels - numPanels} extra panel(s) to fill configuration`);
            if (actualPanels === numPanels) pros.push('Uses exact panel count - no waste');
            if (!currentOk) cons.push(`FAILS: Array Isc ${arrayIscTol}A exceeds ${mppt.maxCurrent}A max input`);
            if (!vocOk) cons.push(`FAILS: String Voc(cold) ${stringVocCold}V exceeds ${mppt.maxVoltage}V limit`);
            if (!vmpMaxOk) cons.push(`FAILS: String Vmp ${stringVmp}V exceeds ${mppt.maxOperatingVoltage}V operating max`);
            if (!powerOk) cons.push(`FAILS: Total ${totalPower}W exceeds ${mppt.maxPower}W max input`);

            configs.push({
                label: `${s}S x ${p}P`,
                series: s,
                parallel: p,
                totalPanels: actualPanels,
                stringVmp, stringVoc, stringVocCold,
                arrayImp, arrayIsc, arrayIscTol, totalPower,
                valid, score,
                checks: { vocOk, vmpMaxOk, vmpMinOk, currentOk, powerOk, startupOk },
                margins: { vocMargin, currentMargin, powerUtil },
                pros, cons
            });
            } // end inner for (parallelCandidates)
        } // end outer for (series)

        // Sort: valid first (by score desc), then invalid
        configs.sort((a, b) => {
            if (a.valid && !b.valid) return -1;
            if (!a.valid && b.valid) return 1;
            return b.score - a.score;
        });

        // Mark recommended
        if (configs.length > 0 && configs[0].valid) {
            configs[0].recommended = true;
        }

        // If no valid config found for this panel count, search nearby counts
        let nearbyValid = null;
        if (!configs.some(c => c.valid)) {
            nearbyValid = this.findNearbyValidConfig(numPanels, panel, mppt, config);
        }

        return {
            configurations: configs,
            recommended: configs.findIndex(c => c.recommended),
            userConfig: null,
            nearbyValid
        };
    },

    /**
     * Search nearby panel counts to find valid configurations
     * when the exact count yields nothing valid.
     * Uses dynamic range based on panel count to handle large arrays.
     */
    findNearbyValidConfig(numPanels, panel, mppt, config) {
        const tempDeltaCold = (config.ambientTempMin || 20) - DEFAULTS.STC_TEMP;
        const vocTempFactor = 1 + (panel.tempCoeffVoc / 100 * tempDeltaCold);
        const vocCold = panel.voc * vocTempFactor;
        const iscTolerance = panel.isc * 1.04;
        const results = [];
        const seen = new Set();

        // Dynamic range: search far enough to always find valid configs
        // For large panel counts, the nearest valid config may be far away
        const searchRange = Math.max(20, numPanels);

        for (let delta = -searchRange; delta <= searchRange; delta++) {
            if (delta === 0) continue;
            const tryCount = numPanels + delta;
            if (tryCount < 1) continue;

            const absMaxSeries = Math.floor(mppt.maxVoltage / vocCold);
            const absMinSeries = Math.max(1, Math.ceil((mppt.minVoltage || 60) / panel.vmp));

            for (let s = absMinSeries; s <= Math.min(absMaxSeries, tryCount); s++) {
                // Try both ceil and floor for parallel, plus single string
                const pCeil = Math.ceil(tryCount / s);
                const pFloor = Math.floor(tryCount / s);
                const pCandidates = new Set();
                if (pCeil >= 1) pCandidates.add(pCeil);
                if (pFloor >= 1) pCandidates.add(pFloor);
                pCandidates.add(1);

                for (const p of pCandidates) {
                    const key = `${s}x${p}`;
                    if (seen.has(key)) continue;
                    seen.add(key);

                    const actualPanels = s * p;
                    const actualDelta = actualPanels - numPanels;

                    const stringVmp = Math.round(s * panel.vmp * 100) / 100;
                    const stringVocCold = Math.round(s * vocCold * 100) / 100;
                    const arrayIscTol = Math.round(p * iscTolerance * 100) / 100;
                    const totalPower = actualPanels * panel.wattage;

                    const vocOk = stringVocCold < mppt.maxVoltage;
                    const vmpMaxOk = stringVmp <= (mppt.maxOperatingVoltage || mppt.maxVoltage * 0.9);
                    const vmpMinOk = stringVmp >= (mppt.minVoltage || 60);
                    const currentOk = arrayIscTol <= mppt.maxCurrent;
                    const powerOk = totalPower <= mppt.maxPower;
                    const valid = vocOk && vmpMaxOk && vmpMinOk && currentOk && powerOk;

                    if (valid) {
                        const vocMargin = Math.round((1 - stringVocCold / mppt.maxVoltage) * 1000) / 10;
                        const currentMargin = Math.round((1 - arrayIscTol / mppt.maxCurrent) * 1000) / 10;
                        results.push({
                            label: `${s}S x ${p}P`,
                            series: s,
                            parallel: p,
                            totalPanels: actualPanels,
                            requestedPanels: tryCount,
                            delta: actualDelta,
                            stringVmp,
                            stringVocCold,
                            arrayIscTol,
                            totalPower,
                            vocMargin,
                            currentMargin,
                            powerUtil: Math.round(totalPower / mppt.maxPower * 1000) / 10
                        });
                    }
                }
            }
        }

        if (results.length === 0) return null;

        // Sort by: closest to target panel count, then by best margins
        results.sort((a, b) => {
            const aDist = Math.abs(a.delta);
            const bDist = Math.abs(b.delta);
            if (aDist !== bDist) return aDist - bDist;
            return (b.vocMargin + b.currentMargin) - (a.vocMargin + a.currentMargin);
        });

        // Deduplicate by totalPanels (keep best margin per panel count)
        const seenCounts = new Set();
        const deduped = [];
        for (const r of results) {
            if (!seenCounts.has(r.totalPanels)) {
                seenCounts.add(r.totalPanels);
                deduped.push(r);
            }
            if (deduped.length >= 5) break;
        }

        return deduped;
    },

    /**
     * Validate a specific user-chosen configuration
     */
    validateUserConfig(series, parallel, numPanels, panel, mppt, config) {
        const tempDeltaCold = (config.ambientTempMin || 20) - DEFAULTS.STC_TEMP;
        const vocTempFactor = 1 + (panel.tempCoeffVoc / 100 * tempDeltaCold);
        const vocCold = panel.voc * vocTempFactor;
        const iscTolerance = panel.isc * 1.04;

        const actualPanels = series * parallel;
        const stringVmp = Math.round(series * panel.vmp * 100) / 100;
        const stringVoc = Math.round(series * panel.voc * 100) / 100;
        const stringVocCold = Math.round(series * vocCold * 100) / 100;
        const arrayImp = Math.round(parallel * panel.imp * 100) / 100;
        const arrayIsc = Math.round(parallel * panel.isc * 100) / 100;
        const arrayIscTol = Math.round(parallel * iscTolerance * 100) / 100;
        const totalPower = actualPanels * panel.wattage;

        const checks = {
            vocOk: stringVocCold < mppt.maxVoltage,
            vmpMaxOk: stringVmp <= (mppt.maxOperatingVoltage || mppt.maxVoltage * 0.9),
            vmpMinOk: stringVmp >= (mppt.minVoltage || 60),
            currentOk: arrayIscTol <= mppt.maxCurrent,
            powerOk: totalPower <= mppt.maxPower,
            startupOk: stringVmp >= (mppt.minVoltage || 60),
            panelCountOk: actualPanels >= numPanels
        };

        const valid = checks.vocOk && checks.vmpMaxOk && checks.vmpMinOk && checks.currentOk && checks.powerOk && checks.startupOk;

        const warnings = [];
        const blocks = [];

        if (!checks.vocOk) blocks.push(`HARD BLOCK: String Voc(cold) = ${stringVocCold}V EXCEEDS ${mppt.maxVoltage}V max. Risk of equipment damage.`);
        if (!checks.currentOk) blocks.push(`HARD BLOCK: Array Isc (with tolerance) = ${arrayIscTol}A EXCEEDS ${mppt.maxCurrent}A max input current.`);
        if (!checks.vmpMaxOk) blocks.push(`String Vmp = ${stringVmp}V exceeds MPPT operating max ${mppt.maxOperatingVoltage}V. MPPT cannot track properly.`);
        if (!checks.vmpMinOk) warnings.push(`String Vmp = ${stringVmp}V is below min startup voltage ${mppt.minVoltage}V. System may not start in low light.`);
        if (!checks.powerOk) warnings.push(`Total array power ${totalPower}W exceeds max input ${mppt.maxPower}W. Inverter will clip — not dangerous but wastes panels.`);
        if (actualPanels > numPanels) warnings.push(`Configuration uses ${actualPanels} panels but you specified ${numPanels}. You need ${actualPanels - numPanels} additional panel(s).`);
        if (actualPanels < numPanels) warnings.push(`Configuration uses ${actualPanels} of ${numPanels} panels. ${numPanels - actualPanels} panel(s) unused.`);

        const vocMargin = checks.vocOk ? Math.round((1 - stringVocCold / mppt.maxVoltage) * 1000) / 10 : 0;
        const currentMargin = checks.currentOk ? Math.round((1 - arrayIscTol / mppt.maxCurrent) * 1000) / 10 : 0;

        return {
            label: `${series}S x ${parallel}P`,
            series, parallel, totalPanels: actualPanels,
            stringVmp, stringVoc, stringVocCold,
            arrayImp, arrayIsc, arrayIscTol, totalPower,
            valid, checks,
            margins: { vocMargin, currentMargin, powerUtil: Math.round(totalPower / mppt.maxPower * 1000) / 10 },
            warnings, blocks
        };
    }
};

/* =============================================================================
   MULTI-MPPT PANEL DISTRIBUTION ENGINE
   Intelligently distributes panels across multiple MPPT inputs
   ============================================================================= */

const MultiMPPTDistributor = {
    /**
     * Distribute numPanels across multiple MPPTs, finding the best valid config per MPPT.
     * Returns null if only 1 MPPT (handled by normal ConfigurationComparisonEngine).
     *
     * Strategy:
     * 1. Try to split panels evenly across MPPTs
     * 2. If uneven, give more to the MPPT with higher power capacity
     * 3. For each MPPT, find the best valid S×P configuration
     * 4. Score the overall distribution and return top options
     */
    distribute(numPanels, panel, mppt, config) {
        if (!mppt.allMPPTs || mppt.allMPPTs.length <= 1) return null;

        const allMPPTs = mppt.allMPPTs;
        const mpptCount = allMPPTs.length;
        const results = [];

        // Generate candidate distributions
        const distributions = this.generateDistributions(numPanels, mpptCount, allMPPTs, panel);

        for (const dist of distributions) {
            const mpptAssignments = [];
            let allValid = true;
            let totalScore = 0;
            let totalActualPanels = 0;

            for (let i = 0; i < mpptCount; i++) {
                const panelsForThisMPPT = dist[i];
                if (panelsForThisMPPT === 0) {
                    mpptAssignments.push({
                        mpptLabel: allMPPTs[i].label,
                        mpptIndex: i,
                        panels: 0,
                        series: 0,
                        parallel: 0,
                        config: null,
                        valid: true,
                        unused: true
                    });
                    continue;
                }

                // Find best valid config for this MPPT with its own limits
                const bestConfig = this.findBestConfigForMPPT(panelsForThisMPPT, panel, allMPPTs[i], config);

                if (bestConfig && bestConfig.valid) {
                    mpptAssignments.push({
                        mpptLabel: allMPPTs[i].label,
                        mpptIndex: i,
                        panels: bestConfig.totalPanels,
                        requestedPanels: panelsForThisMPPT,
                        series: bestConfig.series,
                        parallel: bestConfig.parallel,
                        config: bestConfig,
                        valid: true,
                        unused: false
                    });
                    totalScore += bestConfig.score;
                    totalActualPanels += bestConfig.totalPanels;
                } else {
                    // Find the least-invalid config
                    const leastBad = this.findBestConfigForMPPT(panelsForThisMPPT, panel, allMPPTs[i], config, true);
                    mpptAssignments.push({
                        mpptLabel: allMPPTs[i].label,
                        mpptIndex: i,
                        panels: panelsForThisMPPT,
                        requestedPanels: panelsForThisMPPT,
                        series: leastBad ? leastBad.series : 0,
                        parallel: leastBad ? leastBad.parallel : 0,
                        config: leastBad,
                        valid: false,
                        unused: false,
                        violations: leastBad ? leastBad.violations : ['No valid configuration possible']
                    });
                    allValid = false;
                    totalActualPanels += panelsForThisMPPT;
                }
            }

            // Penalize for deviation from requested panel count
            const panelDeviation = Math.abs(totalActualPanels - numPanels);

            results.push({
                distribution: dist,
                mpptAssignments,
                allValid,
                totalActualPanels,
                requestedPanels: numPanels,
                panelDeviation,
                totalScore: allValid ? totalScore - panelDeviation * 5 : -1000,
                label: mpptAssignments.map(a => a.unused ? `${a.mpptLabel}: unused` : `${a.mpptLabel}: ${a.series}S×${a.parallel}P (${a.panels})`).join(' | ')
            });
        }

        // Sort: all-valid first, then by score desc
        results.sort((a, b) => {
            if (a.allValid && !b.allValid) return -1;
            if (!a.allValid && b.allValid) return 1;
            return b.totalScore - a.totalScore;
        });

        // Mark best as recommended
        if (results.length > 0 && results[0].allValid) {
            results[0].recommended = true;
        }

        return {
            distributions: results.slice(0, 6),
            recommended: results[0] && results[0].allValid ? 0 : -1,
            mpptCount,
            totalPanelsRequested: numPanels
        };
    },

    /**
     * Generate candidate panel distributions across MPPTs.
     * Tries: even split, weighted by power capacity, and various offsets.
     */
    generateDistributions(numPanels, mpptCount, allMPPTs, panel) {
        const distributions = [];
        const seen = new Set();

        const addDist = (d) => {
            const key = d.join(',');
            if (!seen.has(key) && d.every(v => v >= 0)) {
                seen.add(key);
                distributions.push([...d]);
            }
        };

        // Even split
        const basePerMPPT = Math.floor(numPanels / mpptCount);
        const remainder = numPanels % mpptCount;
        const evenDist = Array(mpptCount).fill(basePerMPPT);
        for (let r = 0; r < remainder; r++) evenDist[r]++;
        addDist(evenDist);

        // Reverse even (give remainder to last MPPTs)
        const evenDist2 = Array(mpptCount).fill(basePerMPPT);
        for (let r = 0; r < remainder; r++) evenDist2[mpptCount - 1 - r]++;
        addDist(evenDist2);

        // Weighted by max power capacity
        const totalPower = allMPPTs.reduce((s, m) => s + m.maxPower, 0);
        const weightedDist = allMPPTs.map(m => Math.round(numPanels * m.maxPower / totalPower));
        const wSum = weightedDist.reduce((s, v) => s + v, 0);
        if (wSum !== numPanels) weightedDist[0] += (numPanels - wSum);
        addDist(weightedDist);

        // Try all panels on primary, rest on secondary, etc.
        for (let i = 0; i < mpptCount; i++) {
            // Put maximum on one MPPT, distribute rest
            const maxPanelsForI = Math.floor(allMPPTs[i].maxPower / panel.wattage);
            const forI = Math.min(numPanels, maxPanelsForI);
            const rest = numPanels - forI;

            if (mpptCount === 2) {
                const d = [0, 0];
                d[i] = forI;
                d[1 - i] = rest;
                addDist(d);
            } else if (mpptCount === 3) {
                // Split rest evenly among other two
                const others = [0, 1, 2].filter(j => j !== i);
                const halfRest = Math.floor(rest / 2);
                const d = [0, 0, 0];
                d[i] = forI;
                d[others[0]] = halfRest;
                d[others[1]] = rest - halfRest;
                addDist(d);
            }
        }

        // Try offsets: move 1-3 panels between MPPTs
        for (let offset = 1; offset <= Math.min(3, basePerMPPT); offset++) {
            for (let from = 0; from < mpptCount; from++) {
                for (let to = 0; to < mpptCount; to++) {
                    if (from === to) continue;
                    const d = [...evenDist];
                    d[from] -= offset;
                    d[to] += offset;
                    if (d[from] >= 0) addDist(d);
                }
            }
        }

        return distributions;
    },

    /**
     * Find the best valid S×P configuration for a given number of panels on a single MPPT.
     * If includeBest is true, returns the least-invalid config when none are valid.
     */
    findBestConfigForMPPT(numPanels, panel, mpptSpec, config, includeBest) {
        const tempDeltaCold = (config.ambientTempMin || 20) - DEFAULTS.STC_TEMP;
        const vocTempFactor = 1 + (panel.tempCoeffVoc / 100 * tempDeltaCold);
        const vocCold = panel.voc * vocTempFactor;
        const iscTolerance = panel.isc * 1.04;

        const absMaxSeries = Math.floor(mpptSpec.maxVoltage / vocCold);
        const absMinSeries = Math.max(1, Math.ceil((mpptSpec.minVoltage || 60) / panel.vmp));

        let bestValid = null;
        let bestInvalid = null;
        let bestValidScore = -Infinity;
        let leastViolations = Infinity;

        for (let s = absMinSeries; s <= Math.min(absMaxSeries, numPanels); s++) {
            // Try both ceil and floor for parallel
            const pCandidates = new Set();
            pCandidates.add(Math.ceil(numPanels / s));
            const pf = Math.floor(numPanels / s);
            if (pf >= 1) pCandidates.add(pf);
            pCandidates.add(1);

            for (const p of pCandidates) {
                const actualPanels = s * p;
                const stringVmp = Math.round(s * panel.vmp * 100) / 100;
                const stringVocCold = Math.round(s * vocCold * 100) / 100;
                const arrayIscTol = Math.round(p * iscTolerance * 100) / 100;
                const totalPower = actualPanels * panel.wattage;

                const vocOk = stringVocCold < mpptSpec.maxVoltage;
                const vmpMaxOk = stringVmp <= (mpptSpec.maxOperatingVoltage || mpptSpec.maxVoltage * 0.9);
                const vmpMinOk = stringVmp >= (mpptSpec.minVoltage || 60);
                const currentOk = arrayIscTol <= mpptSpec.maxCurrent;
                const powerOk = totalPower <= mpptSpec.maxPower;
                const valid = vocOk && vmpMaxOk && vmpMinOk && currentOk && powerOk;

                const vocMargin = vocOk ? Math.round((1 - stringVocCold / mpptSpec.maxVoltage) * 1000) / 10 : 0;
                const currentMargin = currentOk ? Math.round((1 - arrayIscTol / mpptSpec.maxCurrent) * 1000) / 10 : 0;
                const panelDev = Math.abs(actualPanels - numPanels);

                const score = valid ?
                    vocMargin * 0.3 + currentMargin * 0.3 + (100 - Math.abs(totalPower / mpptSpec.maxPower * 100 - 70)) * 0.2 - panelDev * 10
                    : 0;

                if (valid && score > bestValidScore) {
                    bestValidScore = score;
                    bestValid = {
                        series: s, parallel: p, totalPanels: actualPanels,
                        stringVmp, stringVocCold, arrayIscTol, totalPower,
                        valid: true, score, vocMargin, currentMargin,
                        label: `${s}S×${p}P`,
                        powerUtil: Math.round(totalPower / mpptSpec.maxPower * 1000) / 10
                    };
                }

                if (!valid && includeBest) {
                    const violations = [];
                    if (!vocOk) violations.push(`Voc(cold) ${stringVocCold}V > ${mpptSpec.maxVoltage}V`);
                    if (!vmpMaxOk) violations.push(`Vmp ${stringVmp}V > ${mpptSpec.maxOperatingVoltage}V`);
                    if (!vmpMinOk) violations.push(`Vmp ${stringVmp}V < ${mpptSpec.minVoltage}V`);
                    if (!currentOk) violations.push(`Isc ${arrayIscTol}A > ${mpptSpec.maxCurrent}A`);
                    if (!powerOk) violations.push(`Power ${totalPower}W > ${mpptSpec.maxPower}W`);

                    if (violations.length < leastViolations || (violations.length === leastViolations && panelDev < Math.abs((bestInvalid ? bestInvalid.totalPanels : 0) - numPanels))) {
                        leastViolations = violations.length;
                        bestInvalid = {
                            series: s, parallel: p, totalPanels: actualPanels,
                            stringVmp, stringVocCold, arrayIscTol, totalPower,
                            valid: false, score: -1000, vocMargin: 0, currentMargin: 0,
                            label: `${s}S×${p}P`, violations,
                            powerUtil: Math.round(totalPower / mpptSpec.maxPower * 1000) / 10
                        };
                    }
                }
            }
        }

        return bestValid || (includeBest ? bestInvalid : null);
    }
};

/* =============================================================================
   SMART ADVISORY ENGINE
   Practical, installer-level advice grounded in real-world experience
   ============================================================================= */

const SmartAdvisoryEngine = {
    generate(results) {
        const advisories = [];
        const appliances = LoadEngine.appliances || [];
        const agg = results.aggregation;
        const inv = results.inverter;
        const batt = results.battery;
        const pv = results.pvArray;
        const config = results.config;
        const mppt = results.mpptValidation;

        // ---- LOAD MANAGEMENT ----

        // Identify load categories
        const heavyLoads = appliances.filter(a => a.ratedPowerW * a.quantity > 800);
        const motorLoads = appliances.filter(a => a.loadType === 'motor');
        const resistiveLoads = appliances.filter(a => a.loadType === 'resistive' && a.ratedPowerW * a.quantity >= 1000);
        const cookerLoads = appliances.filter(a => a.loadType === 'resistive' && a.ratedPowerW * a.quantity >= 1500 &&
            /cook|stove|hot\s*plate|oven|ring/i.test(a.name));
        const ironHeaterLoads = appliances.filter(a => a.loadType === 'resistive' && a.ratedPowerW * a.quantity >= 1000 &&
            /iron|heater|heat/i.test(a.name) && !/cook|stove|hot\s*plate|oven/i.test(a.name));

        // Simultaneous motor warning
        if (motorLoads.length >= 2) {
            const combinedSurge = motorLoads.reduce((sum, m) => sum + m.ratedPowerW * m.quantity * m.surgeFactor, 0);
            advisories.push({
                category: 'Load Management',
                severity: 'warning',
                title: 'Multiple Motors Detected',
                message: `You have ${motorLoads.length} motor loads (${motorLoads.map(m => m.name).join(', ')}). Combined startup surge is ${Math.round(combinedSurge)}VA. Do NOT start them at the same time — stagger startup by at least 30 seconds to avoid tripping the inverter.`
            });
        }

        // Individual heavy motor warning
        motorLoads.forEach(m => {
            const motorVA = m.ratedPowerW * m.quantity;
            const pctOfInverter = Math.round(motorVA / inv.continuousVARequired * 100);
            if (pctOfInverter > 30) {
                advisories.push({
                    category: 'Load Management',
                    severity: 'info',
                    title: `Heavy Motor: ${m.name}`,
                    message: `${m.name} (${motorVA}W) uses ${pctOfInverter}% of your continuous load capacity. Run ONLY during peak sun hours (10am-3pm). Turn off by 4:00pm at the latest to preserve battery for evening.`
                });
            }
        });

        // ---- HEATING / COOKING APPLIANCE WARNINGS ----

        // Cooker — absolute prohibition on solar
        cookerLoads.forEach(c => {
            const watts = c.ratedPowerW * c.quantity;
            advisories.push({
                category: 'Heating Appliances',
                severity: 'critical',
                title: `Electric Cooker: ${c.name} (${watts}W)`,
                message: `Electric cookers, hot plates, and ovens draw ${watts}W+ continuously for long periods. This is NOT practical on solar — even at peak sun, cooking drains the battery faster than panels can replenish. STRONGLY ADVISED: Use gas for cooking. This single change can reduce your daily energy consumption by 30-50% and dramatically extend battery life.`
            });
        });

        // Iron / Heater — rare use at peak sun only
        ironHeaterLoads.forEach(r => {
            const watts = r.ratedPowerW * r.quantity;
            advisories.push({
                category: 'Heating Appliances',
                severity: 'warning',
                title: `${r.name} (${watts}W) — Peak Sun Only`,
                message: `Use ${r.name} ONLY between 11am-1pm when solar output peaks. Keep sessions under 30 minutes. Turn off ALL other heavy loads (AC, pump, washing machine) while ironing/heating. Never use on cloudy days or after 2pm. This is a rare-use appliance on solar, not daily.`
            });
        });

        // Other resistive loads (kettle, etc.)
        resistiveLoads.filter(r =>
            !cookerLoads.includes(r) && !ironHeaterLoads.includes(r)
        ).forEach(r => {
            const watts = r.ratedPowerW * r.quantity;
            if (watts >= 2000) {
                advisories.push({
                    category: 'Heating Appliances',
                    severity: 'critical',
                    title: `Heavy Resistive Load: ${r.name} (${watts}W)`,
                    message: `${r.name} draws ${watts}W — nearly as much as a cooker. Use only briefly during peak sun (11am-1pm) and never with other heavy loads. Consider alternatives: gas kettle, solar water heater, etc.`
                });
            } else {
                advisories.push({
                    category: 'Heating Appliances',
                    severity: 'warning',
                    title: `Heating Appliance: ${r.name} (${watts}W)`,
                    message: `Schedule ${r.name} during daytime (10am-2pm) when panels are generating. Never run simultaneously with AC, pump, or washing machine.`
                });
            }
        });

        // ---- BATTERY GUIDANCE ----

        const batteryWh = batt.totalCapacityWh || (batt.totalCapacityAh * batt.bankVoltage);
        const usableBatteryWh = Math.round(batteryWh * (DEFAULTS.BATTERY_SPECS[batt.chemistry || 'lifepo4'].maxDoD));
        const dailyEnergy = agg.dailyEnergyWh;
        const batteryRatio = usableBatteryWh / dailyEnergy;
        const chemistry = batt.chemistry || 'lifepo4';
        const specs = DEFAULTS.BATTERY_SPECS[chemistry] || DEFAULTS.BATTERY_SPECS.lifepo4;

        if (batteryRatio < 0.6) {
            advisories.push({
                category: 'Battery',
                severity: 'warning',
                title: 'Limited Battery Storage',
                message: `Your battery stores ~${usableBatteryWh}Wh usable (${Math.round(batteryRatio * 100)}% of your ${dailyEnergy.toFixed(0)}Wh daily usage). Treat the battery as overnight bridge power: (1) Run ALL heavy loads during sun hours only, (2) After 5pm, use only lights, fan, TV, phone charging, (3) Never run AC overnight. This will keep the battery healthy and get you through to morning.`
            });
        } else if (batteryRatio < 1.0) {
            advisories.push({
                category: 'Battery',
                severity: 'info',
                title: 'Battery Operation Guide',
                message: `Your ${batt.totalCapacityAh}Ah battery provides ~${usableBatteryWh}Wh usable energy. Comfortable operation: (1) Run pump and AC during peak sun (10am-3pm) only, (2) Never run two heavy appliances together, (3) After 4:30pm, switch to light loads only. Your ${pv.totalPanels} panels (${pv.arrayWattage}W) can charge the battery AND power loads simultaneously during sun hours.`
            });
        } else {
            advisories.push({
                category: 'Battery',
                severity: 'info',
                title: 'Good Battery Capacity',
                message: `Your ${batt.totalCapacityAh}Ah battery provides ~${usableBatteryWh}Wh usable — ${Math.round(batteryRatio * 100)}% of daily usage. You have solid overnight capacity. Still best to run heavy loads during sun hours to maximize battery lifespan.`
            });
        }

        // DoD guidance
        advisories.push({
            category: 'Battery',
            severity: 'info',
            title: 'Depth of Discharge',
            message: `Your ${specs.name} battery should not regularly discharge below ${Math.round(specs.maxDoD * 100)}% DoD. The system is designed with this limit. For longest life (${specs.cycleLife}+ cycles), aim for ${Math.round(specs.maxDoD * 80)}% daily discharge or less.`
        });

        // ---- CHARGE TIME ESTIMATE (dynamic based on daytime load checkbox) ----
        const peakPVOutput = pv.arrayWattage * 0.8; // realistic peak (derating, temp, etc.)
        const psh = config.avgPSH || 4.5;
        const pvAccountForDaytimeLoad = pv.pvAccountForDaytimeLoad !== false;
        const daytimeLoadWh = agg.daytimeEnergyWh || 0;
        const avgDaytimeLoadW = daytimeLoadWh / psh;
        const chargeEffAdv = 0.92;

        if (pvAccountForDaytimeLoad && daytimeLoadWh > 0) {
            // PV sized for loads + charging — show the split
            const netChargePower = Math.max(peakPVOutput - avgDaytimeLoadW, 0);
            const chargeCurrentFromPV = netChargePower / batt.bankVoltage;
            const effectiveChargeCurrent = Math.min(chargeCurrentFromPV, batt.maxChargeCurrent || chargeCurrentFromPV);
            const fullChargeHours = effectiveChargeCurrent > 0 ? batt.totalCapacityAh / (effectiveChargeCurrent * chargeEffAdv) : 999;
            const dailyChargeWh = netChargePower * psh * chargeEffAdv;
            const usableBattWh = batt.usableCapacityWh || (batt.totalCapacityAh * batt.bankVoltage * 0.5);
            const dailyChargePercent = Math.round(dailyChargeWh / usableBattWh * 100);

            advisories.push({
                category: 'Battery',
                severity: fullChargeHours <= psh ? 'info' : 'warning',
                title: 'Charge Time — PV Powers Loads + Charges Battery',
                message: `Your panels produce ~${Math.round(peakPVOutput)}W during peak sun. Of this, ~${Math.round(avgDaytimeLoadW)}W powers daytime loads, leaving ~<strong>${Math.round(netChargePower)}W</strong> for battery charging (${Math.round(effectiveChargeCurrent)}A at ${batt.bankVoltage}V).<br><br>`
                    + `<strong>From empty → full:</strong> ${fullChargeHours > 100 ? '10+ hours' : fullChargeHours.toFixed(1) + ' hours'} of peak sun needed. `
                    + `With ${psh}h peak sun daily: ${fullChargeHours <= psh
                        ? '<strong style="color: green;">Battery can fully recharge in a single sunny day.</strong> Array is well-sized for simultaneous load + charging.'
                        : `<strong style="color: #d97706;">May need ${Math.ceil(fullChargeHours / psh)} sunny days</strong> for full recharge. Daily charge: ~${Math.round(dailyChargeWh)}Wh (${dailyChargePercent}% of usable capacity). Keep heavy loads off until battery exceeds 60%.`}`
                    + `<br><br><em>This estimate assumes all daytime loads run during peak sun. Actual charging is faster on days with lighter load usage.</em>`
            });
        } else {
            // PV sized for charging only — but loads WILL run and steal power
            const chargeOnlyPowerW = peakPVOutput;
            const chargeOnlyCurrent = chargeOnlyPowerW / batt.bankVoltage;
            const chargeOnlyTime = batt.totalCapacityAh / (chargeOnlyCurrent * chargeEffAdv);

            const netIfLoadsRun = Math.max(chargeOnlyPowerW - avgDaytimeLoadW, 0);
            const netCurrentIfLoads = netIfLoadsRun / batt.bankVoltage;
            const actualChargeTime = netCurrentIfLoads > 0 ? batt.totalCapacityAh / (netCurrentIfLoads * chargeEffAdv) : 999;

            const severity = actualChargeTime > psh * 2 ? 'critical' : actualChargeTime > psh ? 'warning' : 'info';

            advisories.push({
                category: 'Battery',
                severity: severity,
                title: 'Charge Time — PV Sized for Battery Only',
                message: `<strong>Daytime load sizing is OFF.</strong> Panels produce ~${Math.round(peakPVOutput)}W — all intended for battery charging.<br><br>`
                    + `<strong>Best case (no loads):</strong> Full charge in ${chargeOnlyTime.toFixed(1)} hours (${Math.round(chargeOnlyCurrent)}A at ${batt.bankVoltage}V). ${chargeOnlyTime <= psh ? 'Achievable in 1 sunny day.' : `Needs ${Math.ceil(chargeOnlyTime / psh)} sunny days.`}<br>`
                    + `<strong>Reality (loads running):</strong> Daytime loads draw ~${Math.round(avgDaytimeLoadW)}W from PV, leaving only ~${Math.round(netIfLoadsRun)}W for charging. `
                    + `Actual charge time: <strong>${actualChargeTime > 100 ? '10+ hours' : actualChargeTime.toFixed(1) + ' hours'}</strong>. `
                    + (avgDaytimeLoadW > peakPVOutput * 0.8
                        ? '<strong style="color: #dc2626;">DANGER: Loads consume most of the PV output — battery may drain even during sunshine! Enable "Size PV for daytime loads" or add more panels urgently.</strong>'
                        : actualChargeTime > psh * 1.5
                            ? '<strong style="color: #d97706;">Battery will not fully recharge in one day if loads run during sun hours. Enable "Size PV for daytime loads" for reliable operation.</strong>'
                            : 'Charging is adequate if loads are kept light during sun hours.')
            });
        }

        // ---- CHEMISTRY-SPECIFIC ADVICE ----
        if (chemistry === 'agm') {
            advisories.push({
                category: 'Battery',
                severity: 'warning',
                title: 'AGM Battery — Heat & Sulfation Warning',
                message: 'AGM batteries are sensitive to heat and sulfation. In hot climates (above 30°C ambient): (1) Keep batteries in a ventilated, shaded area — never in direct sun or enclosed hot rooms, (2) Avoid leaving batteries at partial charge for extended periods — sulfation builds up and permanently reduces capacity, (3) Ensure the charge controller completes full absorption charge daily, (4) Expect 2-3 year lifespan in tropical heat vs 4-5 years in temperate climate. Water loss is sealed but heat accelerates degradation.'
            });
            advisories.push({
                category: 'Battery',
                severity: 'info',
                title: 'AGM Charging Profile',
                message: `AGM batteries must not be fast-charged — max charge rate is ${Math.round(specs.maxChargeRate * 100)}% of capacity (${Math.round(batt.totalCapacityAh * specs.maxChargeRate)}A for your ${batt.totalCapacityAh}Ah bank). Ensure your charge controller is set to AGM profile, not flooded or lithium. Overcharging causes gas venting and permanent damage.`
            });
        } else if (chemistry === 'gel') {
            advisories.push({
                category: 'Battery',
                severity: 'warning',
                title: 'Gel Battery — Charge Voltage Critical',
                message: 'Gel batteries are very sensitive to charge voltage. Even slightly high voltage causes irreversible gel drying. (1) Set charge voltage to exactly manufacturer spec (typically 14.1-14.4V per 12V unit), (2) Never use "flooded" or "AGM" charge profile — gel requires lower voltage, (3) Heat derating: reduce charge voltage by 3mV/°C above 25°C, (4) Place batteries in the coolest location available.'
            });
        } else if (chemistry === 'fla') {
            advisories.push({
                category: 'Battery',
                severity: 'warning',
                title: 'Flooded Lead Acid — Maintenance Required',
                message: 'Flooded batteries require regular maintenance: (1) Check electrolyte levels every 2-4 weeks — top up with distilled water only, (2) Ensure periodic equalization charge (monthly) to prevent stratification, (3) Battery room MUST be ventilated — hydrogen gas is explosive, (4) Clean terminals with baking soda solution quarterly to prevent corrosion. Neglecting maintenance can halve battery life.'
            });
        } else if (chemistry === 'lifepo4') {
            advisories.push({
                category: 'Battery',
                severity: 'info',
                title: 'LiFePO4 — Low Maintenance',
                message: `LiFePO4 is the most forgiving chemistry for solar. No maintenance needed, handles partial charge well, and ${specs.cycleLife}+ cycle life. Key points: (1) Built-in BMS handles cell balancing — do not bypass, (2) Avoid charging below 0°C (most BMS will block this automatically), (3) If stored long-term, keep at 50-60% charge. Your battery should last 8-10 years with normal use.`
            });
        }

        // ---- W vs VA EXPLANATION ----
        const totalWatts = agg.totalWatts || agg.designContinuousVA * 0.85;
        const totalVA = agg.designContinuousVA;
        const powerFactor = totalWatts / totalVA;

        if (Math.abs(totalWatts - totalVA) > 50) {
            advisories.push({
                category: 'General',
                severity: 'info',
                title: 'Understanding W vs VA',
                message: `Your loads total ${Math.round(totalWatts)}W (real power) but the inverter sees ${Math.round(totalVA)}VA (apparent power). The difference is because motors (AC, pump, fan) draw extra reactive current. Your inverter is sized at ${inv.recommendedSizeVA || inv.continuousVARequired}VA to handle this apparent power. Think of it this way: Watts = actual energy consumed, VA = what the inverter must be rated to deliver. Both numbers are correct — they measure different things.`
            });
        }

        // ---- PV ARRAY GUIDANCE (dynamic, multi-scenario) ----
        const pvToLoad = pv.arrayWattage / (dailyEnergy / (config.avgPSH || 4.5));
        const pvDeratedW = pv.arrayWattage * 0.80;
        const requiredPVW = dailyEnergy / (config.avgPSH || 4.5);
        const overproductionPct = Math.round((pvToLoad - 1) * 100);
        const cloudDayOutput = pv.arrayWattage * 0.25; // ~25% on heavy cloud
        const cloudDayWh = cloudDayOutput * (config.avgPSH || 4.5);
        const cloudCoverage = Math.round(cloudDayWh / dailyEnergy * 100);

        if (pvToLoad > 1.5) {
            advisories.push({
                category: 'PV Array',
                severity: 'info',
                title: `Array Oversized by ${overproductionPct}%`,
                message: `Your ${pv.arrayWattage}W array produces ~${overproductionPct}% more than the minimum ${Math.round(requiredPVW)}W needed for your ${dailyEnergy.toFixed(0)}Wh daily load. `
                    + `<strong>Benefits:</strong> faster battery charging, comfortable daytime load capacity, better performance in haze/harmattan. `
                    + `On a cloudy day (~25% output), you'd still get ~${Math.round(cloudDayWh)}Wh — ${cloudCoverage >= 80 ? 'enough to cover most loads.' : cloudCoverage >= 50 ? 'covering about half your needs. Battery handles the rest.' : 'you will rely heavily on battery.'} `
                    + `<br><em>Expansion headroom: You can add ~${Math.round((pvDeratedW - requiredPVW) * (config.avgPSH || 4.5))}Wh of daily load before needing more panels.</em>`
            });
        } else if (pvToLoad > 1.3) {
            advisories.push({
                category: 'PV Array',
                severity: 'info',
                title: `Well-Sized Array (+${overproductionPct}% headroom)`,
                message: `Your ${pv.arrayWattage}W array has ${overproductionPct}% headroom over the minimum ${Math.round(requiredPVW)}W needed. Faster battery charging and comfortable daytime operation. `
                    + `Cloudy day resilience: ~${cloudCoverage}% of daily needs covered at 25% output. `
                    + `Room to add ~${Math.round((pvDeratedW - requiredPVW) * (config.avgPSH || 4.5))}Wh of extra daily load.`
            });
        } else if (pvToLoad >= 1.0) {
            advisories.push({
                category: 'PV Array',
                severity: 'warning',
                title: `Tight Array (+${overproductionPct}% headroom)`,
                message: `Your ${pv.arrayWattage}W array meets the ${Math.round(requiredPVW)}W requirement with only ${overproductionPct}% margin. `
                    + `This works on clear days, but on cloudy/hazy days (~25% output), you'd only get ~${Math.round(cloudDayWh)}Wh — just ${cloudCoverage}% of your ${dailyEnergy.toFixed(0)}Wh need. Battery will drain. `
                    + `<br><strong>Recommendation:</strong> Add 1-2 more panels for reliable all-weather operation. Harmattan season and dust can reduce output 20-40%.`
            });
        } else if (pvToLoad >= 0.8) {
            advisories.push({
                category: 'PV Array',
                severity: 'warning',
                title: `Array Undersized (${Math.abs(overproductionPct)}% short)`,
                message: `Your ${pv.arrayWattage}W array is ${Math.abs(overproductionPct)}% below the ${Math.round(requiredPVW)}W needed for your ${dailyEnergy.toFixed(0)}Wh daily load. `
                    + `Battery will not fully recharge on a typical day, leading to progressive discharge over consecutive cloudy days. `
                    + `<br><strong>Action needed:</strong> Add at least ${Math.ceil((requiredPVW - pv.arrayWattage) / (config.panelWattage || 400))} more panel(s) or reduce daily energy consumption by ${Math.round(dailyEnergy * (1 - pvToLoad))}Wh.`
            });
        } else {
            advisories.push({
                category: 'PV Array',
                severity: 'critical',
                title: `Array Critically Undersized (${Math.abs(overproductionPct)}% short)`,
                message: `Your ${pv.arrayWattage}W array produces only ${Math.round(pvToLoad * 100)}% of what your ${dailyEnergy.toFixed(0)}Wh load requires. `
                    + `Battery will discharge deeply every day, destroying cycle life rapidly. `
                    + `<strong>You need at least ${Math.round(requiredPVW)}W of panels (${Math.ceil(requiredPVW / (config.panelWattage || 400))} panels) minimum, preferably ${Math.round(requiredPVW * 1.3)}W+ for reliable operation.</strong>`
            });
        }

        // MPPT clipping advisory (if array oversized vs MPPT capacity)
        if (mppt && mppt.maxPower && pv.arrayWattage > mppt.maxPower) {
            const clippedW = pv.arrayWattage - mppt.maxPower;
            const clippedPct = Math.round(clippedW / pv.arrayWattage * 100);
            advisories.push({
                category: 'PV Array',
                severity: clippedPct > 15 ? 'warning' : 'info',
                title: `MPPT Clipping: ${clippedPct}% of Array Power`,
                message: `Your ${pv.arrayWattage}W array exceeds the MPPT's ${mppt.maxPower}W capacity by ${clippedW}W. `
                    + `During peak sun, the MPPT will clip at ${mppt.maxPower}W — the excess ${clippedW}W is safely discarded as heat. `
                    + (clippedPct <= 15
                        ? `This is common practice (${clippedPct}% oversize). Benefits: better low-light and morning/evening performance. No harm to equipment.`
                        : `At ${clippedPct}%, you're wasting significant panel capacity. Consider a higher-rated MPPT controller or dual-MPPT inverter.`)
            });
        }

        // Seasonal/weather variation advisory
        advisories.push({
            category: 'PV Array',
            severity: 'info',
            title: 'Seasonal & Weather Performance',
            message: `<strong>Clear day:</strong> ~${Math.round(pv.dailyEnergyWh || pv.arrayWattage * (config.avgPSH || 4.5) * 0.8)}Wh production (${config.avgPSH || 4.5}h peak sun). `
                + `<strong>Hazy/harmattan:</strong> ~${Math.round((pv.dailyEnergyWh || pv.arrayWattage * (config.avgPSH || 4.5) * 0.8) * 0.6)}Wh (60%). `
                + `<strong>Heavy cloud/rain:</strong> ~${Math.round(cloudDayWh)}Wh (25%). `
                + `<br>During rainy season (May-Oct in southern Nigeria), expect 2-3 consecutive cloudy days — battery autonomy of ${config.autonomyDays || 1} day(s) must cover this. `
                + `Clean panels monthly — dust/bird droppings can reduce output 5-15%.`
        });

        // ---- PANEL MISMATCH ADVISORY ----
        const mismatchData = results.mismatchData;
        if (mismatchData) {
            if (mismatchData.spread <= 5) {
                advisories.push({
                    category: 'PV Array',
                    severity: 'info',
                    title: `Panel Mismatch: ${mismatchData.spread.toFixed(1)}% — Acceptable`,
                    message: `Your mixed panels (${mismatchData.count} panels, ${mismatchData.totalW}W total) have a ${mismatchData.spread.toFixed(1)}% wattage spread. This is within the industry-accepted 5% tolerance. Energy loss from mismatch will be under 3%. No action needed.`
                });
            } else if (mismatchData.spread <= 10) {
                advisories.push({
                    category: 'PV Array',
                    severity: 'warning',
                    title: `Panel Mismatch: ${mismatchData.spread.toFixed(1)}% — Marginal`,
                    message: `Your panels have a ${mismatchData.spread.toFixed(1)}% wattage spread (${mismatchData.count} panels, ${mismatchData.totalW}W). This exceeds ideal 5% but is workable. Expected 5-8% energy loss. Best practice: group similar wattages into the same series string. Different strings can have different wattages when wired in parallel.`
                });
            } else {
                advisories.push({
                    category: 'PV Array',
                    severity: 'critical',
                    title: `Panel Mismatch: ${mismatchData.spread.toFixed(1)}% — Excessive`,
                    message: `Your panels have a ${mismatchData.spread.toFixed(1)}% wattage spread — too high for a single series string. The weakest panel will bottleneck the entire string, wasting 10-20% of the stronger panels' capacity. Solution: separate panels by wattage into different parallel strings, or use a dual-MPPT inverter with each group on a separate input.`
                });
            }
        }

        // ---- SUN WEAKENING & TIME-BASED GUIDANCE ----

        advisories.push({
            category: 'Load Management',
            severity: 'warning',
            title: 'Sun Weakening After 4:00pm',
            message: `Solar output drops significantly after 4:00pm and becomes negligible by 5:30-6:00pm. Turn off AC, pumping machine, and all heavy loads by 4:00pm at the latest. From 4:00pm onward, your system runs primarily on battery. Keeping heavy loads on past this time drains the battery before nightfall and shortens battery life.`
        });

        // ---- COPING STRATEGIES FOR UNDERSIZED EQUIPMENT ----
        const invUsableVA = (inv.recommendedSizeVA || 0) * DEFAULTS.INVERTER_DERATING;
        const invIsUndersize = inv.isManualOverride && invUsableVA < (agg.designContinuousVA || agg.peakSimultaneousVA);
        const invIsSurgeShort = inv.isManualOverride && (inv.recommendedSizeVA || 0) * (config.inverterSurgeMultiplier || 2) < (agg.highestSurgeVA || agg.designSurgeVA || 0);
        const battIsUndersize = batt.isManualOverride && (batt.autoSuggestedAh || 0) > batt.totalCapacityAh * 1.2;
        const battUnitUndersize = batt.isUnitCountOverride && (batt.autoSuggestedStrings || 0) > (batt.stringsInParallel || 1);

        if (invIsUndersize || invIsSurgeShort || battIsUndersize || battUnitUndersize) {
            // Build load priority tiers from appliances
            const allApps = [...appliances].sort((a, b) => (b.ratedPowerW * b.quantity) - (a.ratedPowerW * a.quantity));
            const criticalLoads = appliances.filter(a => /fridge|freezer|router|modem|light|fan/i.test(a.name));
            const heavyNonCrit = appliances.filter(a =>
                a.ratedPowerW * a.quantity > 500 && !criticalLoads.includes(a)
            );
            const lightLoads = appliances.filter(a =>
                a.ratedPowerW * a.quantity <= 500 && !criticalLoads.includes(a)
            );

            let copeMsg = '';

            if (invIsUndersize) {
                const usable = Math.round(invUsableVA);
                const needed = Math.round(agg.designContinuousVA || agg.peakSimultaneousVA);
                const deficit = needed - usable;
                copeMsg += `<strong>Inverter Capacity:</strong> Your ${inv.recommendedSizeVA}VA inverter provides ~${usable}W usable (after 80% derating). Your loads need ${needed}VA continuous — a ${Math.round(deficit)}VA shortfall. `;
                copeMsg += `You CANNOT run all loads simultaneously. `;
            }

            if (invIsSurgeShort) {
                copeMsg += `<strong>Surge:</strong> Motor startup surges (${Math.round(agg.highestSurgeVA || agg.designSurgeVA)}VA worst-case) exceed your inverter's ${Math.round((inv.recommendedSizeVA || 0) * (config.inverterSurgeMultiplier || 2))}VA surge rating. NEVER start two motors at the same time — the inverter will trip or shut down. `;
            }

            if (battIsUndersize || battUnitUndersize) {
                const autoAh = batt.autoSuggestedAh || (batt.autoSuggestedStrings ? batt.autoSuggestedStrings * batt.recommendedAhPerCell : 0);
                copeMsg += `<strong>Battery:</strong> Your ${Math.round(batt.totalCapacityAh)}Ah is smaller than the recommended ${Math.round(autoAh)}Ah. Expect reduced autonomy and faster cycling — avoid deep discharge. `;
            }

            // Priority tier list
            copeMsg += '<br><br><strong>Load Priority Tiers (run in order of importance):</strong><br>';
            copeMsg += '<strong>Tier 1 — Always On (Critical):</strong> ';
            copeMsg += criticalLoads.length > 0
                ? criticalLoads.map(a => `${a.name} (${a.ratedPowerW * a.quantity}W)`).join(', ')
                : 'Lights, fan, fridge, router';
            copeMsg += '<br><strong>Tier 2 — Daytime Only (Heavy):</strong> ';
            copeMsg += heavyNonCrit.length > 0
                ? heavyNonCrit.map(a => `${a.name} (${a.ratedPowerW * a.quantity}W)`).join(', ')
                : 'AC, pump, washing machine';
            copeMsg += ' — run ONE at a time during peak sun (10am-3pm)<br>';
            copeMsg += '<strong>Tier 3 — Occasional (Light):</strong> ';
            copeMsg += lightLoads.length > 0
                ? lightLoads.map(a => `${a.name} (${a.ratedPowerW * a.quantity}W)`).join(', ')
                : 'TV, laptop, chargers';

            // Specific rules
            copeMsg += '<br><br><strong>Survival Rules:</strong><br>';
            copeMsg += '1. NEVER run more than ONE Tier 2 appliance at a time<br>';
            copeMsg += '2. Turn off ALL Tier 2 loads by 4:00pm — battery only after sunset<br>';
            copeMsg += '3. If inverter trips: turn off the last appliance started, wait 30 seconds, restart<br>';
            copeMsg += '4. On cloudy days: Tier 1 loads only — no heavy loads at all<br>';
            copeMsg += '5. After 6pm: Tier 1 + Tier 3 only (lights, fan, TV, phone charging)';

            copeMsg += '<br><br><em>This is a temporary coping strategy. For reliable, safe operation with your full load list, upgrade to the recommended inverter (' + (inv.autoSuggestedSizeVA || 'see auto-calculation') + 'VA) and battery size.</em>';

            advisories.push({
                category: 'Coping Strategies',
                severity: 'warning',
                title: 'Managing With Undersized Equipment',
                message: copeMsg
            });

            // Max simultaneous load estimate
            if (invIsUndersize) {
                const safeSimultaneousW = Math.round(invUsableVA * 0.85);
                let comboMsg = `Your inverter can safely handle ~${safeSimultaneousW}W of simultaneous load. `;
                comboMsg += 'Safe combinations (examples):<br>';

                // Build safe combos from actual appliances
                const sortedByW = [...appliances].sort((a, b) => a.ratedPowerW * a.quantity - b.ratedPowerW * b.quantity);
                let comboW = 0;
                const safeCombo = [];
                for (const app of sortedByW) {
                    const w = app.ratedPowerW * app.quantity;
                    if (comboW + w <= safeSimultaneousW) {
                        safeCombo.push(`${app.name} (${w}W)`);
                        comboW += w;
                    }
                }
                if (safeCombo.length > 0) {
                    comboMsg += `• ${safeCombo.join(' + ')} = ${comboW}W [SAFE]<br>`;
                }

                // Unsafe combo example (two heaviest)
                if (heavyNonCrit.length >= 2) {
                    const h1 = heavyNonCrit[0], h2 = heavyNonCrit[1];
                    const unsafeW = h1.ratedPowerW * h1.quantity + h2.ratedPowerW * h2.quantity;
                    comboMsg += `• ${h1.name} + ${h2.name} = ${unsafeW}W [DANGER — exceeds capacity]`;
                }

                advisories.push({
                    category: 'Coping Strategies',
                    severity: 'info',
                    title: 'Safe Load Combinations',
                    message: comboMsg
                });
            }
        }

        // ---- DAYTIME SELF-SUFFICIENCY (with W vs VA context) ----
        const peakPVPower = pv.arrayWattage * 0.8;
        const peakLoadVA = agg.peakSimultaneousVA || agg.designContinuousVA;
        const peakLoadW = peakLoadVA * (powerFactor || 0.85);

        if (peakPVPower > peakLoadW * 1.2) {
            const surplus = Math.round(peakPVPower - peakLoadW);
            advisories.push({
                category: 'General',
                severity: 'info',
                title: 'Daytime Self-Sufficiency',
                message: `During peak sun (10am-2pm), your panels produce ~${Math.round(peakPVPower)}W. Your loads draw ~${Math.round(peakLoadW)}W real power (${Math.round(peakLoadVA)}VA apparent). That leaves ~${surplus}W surplus going directly to battery charging. You can comfortably run appliances during these hours while the battery charges simultaneously.`
            });
        }

        // ---- DAILY ROUTINE SUGGESTION ----
        if (heavyLoads.length > 0) {
            // Build a practical daily schedule
            let schedule = '';
            const acLoad = appliances.find(a => /air\s*con|a\.?c\.?|split\s*unit|cooling/i.test(a.name));
            const pumpLoad = appliances.find(a => /pump|bore\s*hole|water/i.test(a.name) && a.loadType === 'motor');
            const washLoad = appliances.find(a => /wash|laundry/i.test(a.name));
            const ironLoad = appliances.find(a => /iron/i.test(a.name));

            schedule += '<br><strong>Suggested Daily Routine:</strong><br>';
            schedule += '<span style="font-family: monospace; font-size: 0.85rem; line-height: 1.8;">';
            schedule += '6:00am - 9:00am &nbsp; Lights, fan, TV, phone charging (light loads)<br>';

            if (pumpLoad) {
                schedule += '9:30am - 10:30am &nbsp; Pumping machine (sun is building up)<br>';
            }
            if (washLoad) {
                schedule += '10:00am - 11:30am &nbsp; Washing machine (good sun, battery charging)<br>';
            }
            if (ironLoad) {
                schedule += '11:00am - 11:30am &nbsp; Ironing (peak sun ONLY, nothing else heavy)<br>';
            }
            if (acLoad) {
                schedule += '11:00am - 3:30pm &nbsp; AC (peak sun hours — turn off by 3:30pm)<br>';
            }
            schedule += '4:00pm onward &nbsp;&nbsp;&nbsp; Light loads ONLY (lights, fan, TV, phone)<br>';
            schedule += '6:00pm - 6:00am &nbsp; Battery powers essentials overnight<br>';
            schedule += '</span>';
            schedule += '<br><em>Key rule: Never run two heavy loads at the same time. Stagger everything.</em>';

            advisories.push({
                category: 'Daily Routine',
                severity: 'info',
                title: 'Recommended Daily Load Schedule',
                message: `To get the best out of your battery and panels, follow this schedule. Your panels produce power from ~7am to ~5:30pm, with peak output between 10am-3pm. Heavy loads should ONLY run during peak sun.${schedule}`
            });
        }

        // Combined heavy load scheduling (if 3+)
        if (heavyLoads.length >= 3) {
            advisories.push({
                category: 'Load Management',
                severity: 'warning',
                title: 'Heavy Load Scheduling',
                message: `You have ${heavyLoads.length} heavy loads (${heavyLoads.map(h => h.name + ' ' + (h.ratedPowerW * h.quantity) + 'W').join(', ')}). NEVER run more than one heavy load at the same time. Stagger each by at least 30 minutes. Your inverter can handle one at a time while panels charge the battery.`
            });
        }

        // ---- GRID/UTILITY CHARGING ADVISORY ----
        const gridMaxChargeA = parseFloat((document.getElementById('gridMaxChargeA') || {}).value) || 0;
        const gridInputRange = (document.getElementById('gridInputVoltageRange') || {}).value || '';
        const sysType = (document.getElementById('systemType') || {}).value || '';

        if (gridMaxChargeA > 0 && (sysType === 'hybrid' || sysType === 'grid_tie')) {
            const gridChargeW = gridMaxChargeA * batt.bankVoltage;
            const gridChargeHours = batt.totalCapacityAh / (gridMaxChargeA * 0.92);

            advisories.push({
                category: 'Grid Charging',
                severity: 'info',
                title: `Grid/Utility Charging: ${gridMaxChargeA}A Available`,
                message: `Your hybrid inverter can charge at up to ${gridMaxChargeA}A from the grid (~${Math.round(gridChargeW)}W). `
                    + `Full charge from empty: ~${gridChargeHours.toFixed(1)} hours. `
                    + `Grid input range: ${gridInputRange || 'not specified'}VAC. `
                    + `<br><br><strong>Lagos Grid Strategy:</strong> `
                    + `(1) Set grid charging to nighttime (midnight-5am) when NEPA/PHCN supply is most stable. `
                    + `(2) Use AVR before inverter — Lagos voltage swings (140-260V) can damage charger circuits. `
                    + `(3) Set charge current to ${Math.min(gridMaxChargeA, Math.round(batt.totalCapacityAh * 0.3))}A or lower for battery longevity — fast charging reduces cycle life. `
                    + `(4) During prolonged grid availability, let grid charge to 80% then switch to solar for the remaining 20% — gentler on ${batt.chemistryName} cells.`
            });
        }

        return advisories;
    }
};

/* =============================================================================
   PHASE 11: OUTPUT GENERATION
   ============================================================================= */

const OutputGenerator = {
    /**
     * Generate complete system report
     */
    generateReport(results) {
        return {
            meta: {
                generatedAt: new Date().toISOString(),
                version: '2.0.0'
            },
            summary: {
                totalDailyEnergy: results.aggregation.dailyEnergyWh,
                peakLoad: results.aggregation.peakSimultaneousVA,
                inverterSize: results.inverter.recommendedSizeVA,
                batteryCapacity: results.battery.totalCapacityAh,
                pvArraySize: results.pvArray.arrayWattage,
                totalPanels: results.pvArray.totalPanels
            },
            details: results,
            warnings: this.collectAllWarnings(results),
            blocks: this.collectAllBlocks(results)
        };
    },

    collectAllWarnings(results) {
        const warnings = [];
        if (results.inverter.warnings) warnings.push(...results.inverter.warnings);
        if (results.battery.warnings) warnings.push(...results.battery.warnings);
        if (results.pvArray.warnings) warnings.push(...results.pvArray.warnings);
        if (results.mpptValidation.warnings) warnings.push(...results.mpptValidation.warnings);
        if (results.cables.warnings) warnings.push(...results.cables.warnings);
        if (results.protection.warnings) warnings.push(...results.protection.warnings);
        return warnings;
    },

    collectAllBlocks(results) {
        const blocks = [];
        if (results.inverter.blocks) blocks.push(...results.inverter.blocks);
        if (results.battery.blocks) blocks.push(...results.battery.blocks);
        if (results.pvArray.blocks) blocks.push(...results.pvArray.blocks);
        if (results.mpptValidation.blocks) blocks.push(...results.mpptValidation.blocks);
        if (results.cables.blocks) blocks.push(...results.cables.blocks);
        return blocks;
    }
};

/* =============================================================================
   PHASE 12: DEFENSE NOTES (Hard Blocks Display)
   ============================================================================= */

const DefenseNotes = {
    /**
     * Check for any hard blocks in the system
     */
    checkForBlocks(results) {
        const blocks = OutputGenerator.collectAllBlocks(results);
        const suggestions = [];

        if (results.inverter.suggestions) suggestions.push(...results.inverter.suggestions);
        if (results.battery.suggestions) suggestions.push(...results.battery.suggestions);
        if (results.pvArray.suggestions) suggestions.push(...results.pvArray.suggestions);
        if (results.mpptValidation.suggestions) suggestions.push(...results.mpptValidation.suggestions);
        if (results.cables.suggestions) suggestions.push(...results.cables.suggestions);

        return {
            hasBlocks: blocks.length > 0,
            blocks,
            suggestions
        };
    }
};

/* =============================================================================
   UI CONTROLLER - Connects UI to calculation engines
   ============================================================================= */

const PVCalculator = {
    results: null,
    editingIndex: null,  // Track which appliance is being edited

    /**
     * Toggle dark/light theme
     */
    toggleTheme() {
        const html = document.documentElement;
        const btn = document.getElementById('themeToggleBtn');
        const currentTheme = html.getAttribute('data-theme');

        if (currentTheme === 'dark') {
            html.removeAttribute('data-theme');
            btn.innerHTML = '&#9790;'; // Moon icon
            btn.title = 'Switch to Dark Mode';
            localStorage.setItem('pv-theme', 'light');
        } else {
            html.setAttribute('data-theme', 'dark');
            btn.innerHTML = '&#9788;'; // Sun icon
            btn.title = 'Switch to Light Mode';
            localStorage.setItem('pv-theme', 'dark');
        }
    },

    /**
     * Initialize theme from localStorage on page load
     */
    initTheme() {
        const saved = localStorage.getItem('pv-theme');
        const btn = document.getElementById('themeToggleBtn');
        if (saved === 'dark') {
            document.documentElement.setAttribute('data-theme', 'dark');
            if (btn) { btn.innerHTML = '&#9788;'; btn.title = 'Switch to Light Mode'; }
        }
    },

    /**
     * SMART PANEL VALIDATION
     * Validates Vmp × Imp ≈ Wp within ±3% tolerance
     */
    validatePanelSpecs() {
        const wattage = parseFloat(document.getElementById('panelWattage').value) || 0;
        const vmp = parseFloat(document.getElementById('panelVmp').value) || 0;
        const voc = parseFloat(document.getElementById('panelVoc').value) || 0;
        const imp = parseFloat(document.getElementById('panelImp').value) || 0;
        const isc = parseFloat(document.getElementById('panelIsc').value) || 0;

        const badge = document.getElementById('panelValidationBadge');
        const msg = document.getElementById('panelValidationMsg');

        // Guard against division by zero
        if (wattage <= 0 || vmp <= 0 || imp <= 0) {
            badge.innerHTML = '';
            msg.innerHTML = '';
            return { valid: false, errors: ['Missing panel specifications'] };
        }

        const errors = [];
        const warnings = [];

        // Calculate power from Vmp × Imp
        const calculatedPower = vmp * imp;
        const tolerance = 0.03; // 3% tolerance
        const percentDiff = Math.abs(calculatedPower - wattage) / wattage;

        if (percentDiff > tolerance) {
            errors.push(`Vmp × Imp = ${calculatedPower.toFixed(1)}W does NOT match ${wattage}Wp (${(percentDiff * 100).toFixed(1)}% difference). Expected within ±3%.`);
        }

        // Validate Vmp < Voc
        if (vmp >= voc) {
            errors.push(`Vmp (${vmp}V) must be less than Voc (${voc}V)`);
        }

        // Validate Imp < Isc
        if (imp >= isc) {
            errors.push(`Imp (${imp}A) must be less than Isc (${isc}A)`);
        }

        // Typical ratio checks (warnings)
        const vocVmpRatio = voc / vmp;
        if (vocVmpRatio < 1.1 || vocVmpRatio > 1.35) {
            warnings.push(`Voc/Vmp ratio (${vocVmpRatio.toFixed(2)}) is unusual. Typical: 1.15-1.25 for crystalline silicon panels.`);
        }

        const iscImpRatio = isc / imp;
        if (iscImpRatio < 1.02 || iscImpRatio > 1.15) {
            warnings.push(`Isc/Imp ratio (${iscImpRatio.toFixed(2)}) is unusual. Typical: 1.05-1.10`);
        }

        // Practical voltage/current range checks for common panels
        const isManual = document.getElementById('manualMode').checked;
        const tips = [];

        if (wattage <= 200 && vmp > 40) {
            warnings.push(`Vmp (${vmp}V) seems high for a ${wattage}W panel. Most ${wattage}W panels have Vmp around 18-30V.`);
        }
        if (wattage >= 300 && vmp < 20) {
            warnings.push(`Vmp (${vmp}V) seems low for a ${wattage}W panel. Most 300W+ panels have Vmp around 30-45V.`);
        }
        if (voc > 60) {
            warnings.push(`Voc (${voc}V) is very high. Most residential panels have Voc under 55V. Double-check your datasheet.`);
        }
        if (isc > 20) {
            warnings.push(`Isc (${isc}A) is very high. Most panels have Isc between 5-15A. Verify from datasheet.`);
        }
        if (imp > 0 && imp < 1) {
            warnings.push(`Imp (${imp}A) is very low. Most panels have Imp above 2A. Check your datasheet or unit.`);
        }

        // Generate helpful tips for manual mode users
        if (isManual) {
            const expectedVmp = wattage < 200 ? '18-25V' : wattage < 350 ? '30-38V' : '35-45V';
            const expectedImp = (wattage / (wattage < 200 ? 20 : wattage < 350 ? 34 : 41)).toFixed(1);
            tips.push(`Tip: For a ${wattage}W panel, typical Vmp is ${expectedVmp} and Imp is ~${expectedImp}A`);
            tips.push(`All specs are on your panel datasheet label or manufacturer spec sheet`);
            tips.push(`Vmp × Imp must equal the rated wattage (within ±3%)`);
        }

        // Update UI
        if (errors.length > 0) {
            badge.innerHTML = '<span class="spec-badge mismatch">INVALID</span>';
            let msgHtml = `<div class="validation-message validation-error">${errors.join('<br>')}</div>`;
            if (tips.length > 0) {
                msgHtml += `<div style="margin-top: 6px; padding: 6px 10px; font-size: 0.8rem; color: var(--text-muted); background: var(--bg-color); border-radius: 4px;">${tips.join('<br>')}</div>`;
            }
            msg.innerHTML = msgHtml;
            document.getElementById('panelWattage').classList.add('invalid');
            document.getElementById('panelVmp').classList.add('invalid');
            document.getElementById('panelImp').classList.add('invalid');
            return { valid: false, errors };
        } else if (warnings.length > 0) {
            badge.innerHTML = '<span class="spec-badge warning">CHECK</span>';
            let msgHtml = `<div class="validation-message validation-warning">${warnings.join('<br>')}</div>`;
            if (tips.length > 0) {
                msgHtml += `<div style="margin-top: 6px; padding: 6px 10px; font-size: 0.8rem; color: var(--text-muted); background: var(--bg-color); border-radius: 4px;">${tips.join('<br>')}</div>`;
            }
            msg.innerHTML = msgHtml;
        } else {
            badge.innerHTML = '<span class="spec-badge match">VALID</span>';
            let msgHtml = `<div class="validation-message validation-success">Panel specs OK: ${calculatedPower.toFixed(1)}W = Vmp × Imp</div>`;
            if (tips.length > 0) {
                msgHtml += `<div style="margin-top: 6px; padding: 6px 10px; font-size: 0.8rem; color: var(--text-muted); background: var(--bg-color); border-radius: 4px;">${tips.join('<br>')}</div>`;
            }
            msg.innerHTML = msgHtml;
        }

        document.getElementById('panelWattage').classList.remove('invalid');
        document.getElementById('panelVmp').classList.remove('invalid');
        document.getElementById('panelImp').classList.remove('invalid');
        return { valid: true, calculatedPower, warnings };
    },

    /**
     * Validate MPPT specifications
     */
    validateMPPT() {
        const maxV = parseFloat(document.getElementById('mpptMaxVoltage').value) || 0;
        const maxI = parseFloat(document.getElementById('mpptMaxCurrent').value) || 0;
        const maxP = parseFloat(document.getElementById('mpptMaxPower').value) || 0;

        const errors = [];

        if (maxV < 30) errors.push('MPPT max voltage too low (min 30V)');
        if (maxI < 5) errors.push('MPPT max current too low (min 5A)');
        if (maxP < 100) errors.push('MPPT max power too low (min 100W)');

        // Sanity check: V × I should be reasonable vs power rating
        if (maxV * maxI < maxP * 0.5) {
            errors.push(`V × I (${maxV * maxI}W) seems low for ${maxP}W MPPT`);
        }

        return { valid: errors.length === 0, errors };
    },

    /**
     * Toggle manual mode
     */
    toggleManualMode() {
        const isManual = document.getElementById('manualMode').checked;
        const sections = [
            'inverterManualSection',
            'batteryManualSection',
            'pvManualSection',
            'breakerManualSection'
        ];
        const batteryIndicator = document.getElementById('batteryManualIndicator');

        sections.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                if (isManual) el.classList.remove('hidden');
                else el.classList.add('hidden');
            }
        });

        if (isManual) {
            batteryIndicator.classList.remove('hidden');
        } else {
            batteryIndicator.classList.add('hidden');
        }

        // Show/hide expert mode option
        const expertSection = document.getElementById('expertModeSection');
        if (expertSection) {
            if (isManual) {
                expertSection.classList.remove('hidden');
            } else {
                expertSection.classList.add('hidden');
                const expertCb = document.getElementById('expertMode');
                if (expertCb) expertCb.checked = false;
            }
        }

        // Panel field auto-suggest behavior
        const panelFields = ['panelVmp', 'panelVoc', 'panelImp', 'panelIsc', 'panelTempCoeffPmax', 'panelTempCoeffVoc'];
        const mpptFields = ['mpptMaxVoltage', 'mpptMaxCurrent', 'mpptMaxPower', 'mpptMinVoltage', 'mpptMaxOperatingVoltage', 'mpptMaxChargeCurrent'];

        if (isManual) {
            // In manual mode: all fields editable, clear auto indicators
            [...panelFields, ...mpptFields].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.background = '';
                    el.style.color = '';
                }
            });
            const badge = document.getElementById('panelValidationBadge');
            if (badge) badge.innerHTML = '';
            const msg = document.getElementById('panelValidationMsg');
            if (msg) msg.innerHTML = '';
        } else {
            // In auto mode: fields get a subtle background hint
            [...panelFields, ...mpptFields].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.background = 'rgba(34,197,94,0.06)';
                }
            });
            // Trigger auto-suggest
            this.autoSuggestPanelSpecs();
        }
    },

    /**
     * Expert mode change handler
     */
    onExpertModeChange() {
        // Expert mode effect is read during calculate() — just trigger recalc
        this.calculate();
    },

    /**
     * Open coping score modal with full breakdown
     */
    openCopingModal() {
        if (!this.results) return;
        const R = this.results;
        const inv = R.inverter;
        const batt = R.battery;
        const agg = R.aggregation;
        const appliances = (typeof LoadEngine !== 'undefined' && LoadEngine.appliances) || [];

        // Recalculate scores for display
        const invUsableW = (inv.recommendedSizeVA || 0) * DEFAULTS.INVERTER_DERATING;
        const contNeeded = agg.designContinuousVA || agg.peakSimultaneousVA || 0;
        const invRatio = contNeeded > 0 ? Math.min(invUsableW / contNeeded, 1.0) : 1.0;
        const surgeNeeded = agg.highestSurgeVA || agg.designSurgeVA || 0;
        const surgeCap = (inv.recommendedSizeVA || 0) * (R.config?.inverterSurgeMultiplier || 2.0);
        const surgeRatio = surgeNeeded > 0 ? Math.min(surgeCap / surgeNeeded, 1.0) : 1.0;
        const autoAh = batt.autoSuggestedAh || batt.totalCapacityAh;
        const battRatio = autoAh > 0 ? Math.min(batt.totalCapacityAh / autoAh, 1.0) : 1.0;
        const copingScore = Math.round((invRatio * 0.40 + surgeRatio * 0.25 + battRatio * 0.35) * 100);
        const scoreColor = copingScore >= 75 ? '#16a34a' : copingScore >= 50 ? '#d97706' : '#dc2626';
        const scoreLabel = copingScore >= 75 ? 'Manageable' : copingScore >= 50 ? 'Tight' : 'Critical';

        // Categorize appliances into tiers
        const criticalLoads = appliances.filter(a => /fridge|freezer|router|modem|light|fan/i.test(a.name));
        const heavyNonCrit = appliances.filter(a => a.ratedPowerW * a.quantity > 500 && !criticalLoads.includes(a));
        const lightLoads = appliances.filter(a => a.ratedPowerW * a.quantity <= 500 && !criticalLoads.includes(a));
        const safeSimW = Math.round(invUsableW * 0.85);

        // Build safe combos (greedy, lightest first)
        const sorted = [...appliances].sort((a, b) => a.ratedPowerW * a.quantity - b.ratedPowerW * b.quantity);
        let comboW = 0;
        const safeCombos = [];
        for (const app of sorted) {
            const w = app.ratedPowerW * app.quantity;
            if (comboW + w <= safeSimW) { safeCombos.push({ name: app.name, w }); comboW += w; }
        }

        // Build modal content
        let body = '';

        // Score bar
        body += `<h4>Overall Coping Score</h4>`;
        body += `<div style="display:flex; align-items:center; gap:12px; margin-bottom:4px;">`;
        body += `<span style="font-size:2rem; font-weight:bold; color:${scoreColor};">${copingScore}%</span>`;
        body += `<span style="font-size:1rem; color:${scoreColor}; font-weight:600;">${scoreLabel}</span>`;
        body += `</div>`;
        body += `<div class="score-bar"><div class="score-bar-fill" style="width:${copingScore}%; background:${scoreColor};"></div></div>`;

        // Component breakdown
        body += `<h4>Component Breakdown</h4>`;
        body += `<table style="width:100%; border-collapse:collapse; font-size:0.85rem;">`;
        body += `<tr style="border-bottom:1px solid var(--border-color);"><td style="padding:6px 0;"><strong>Inverter Continuous</strong></td><td style="text-align:right;">${Math.round(invUsableW)}W usable / ${Math.round(contNeeded)}VA needed</td><td style="text-align:right; width:60px; color:${invRatio < 1 ? '#dc2626' : '#16a34a'}; font-weight:600;">${Math.round(invRatio * 100)}%</td></tr>`;
        body += `<tr style="border-bottom:1px solid var(--border-color);"><td style="padding:6px 0;"><strong>Surge Capacity</strong></td><td style="text-align:right;">${Math.round(surgeCap)}VA capacity / ${Math.round(surgeNeeded)}VA required</td><td style="text-align:right; color:${surgeRatio < 1 ? '#dc2626' : '#16a34a'}; font-weight:600;">${Math.round(surgeRatio * 100)}%</td></tr>`;
        body += `<tr><td style="padding:6px 0;"><strong>Battery Capacity</strong></td><td style="text-align:right;">${Math.round(batt.totalCapacityAh)}Ah actual / ${Math.round(autoAh)}Ah recommended</td><td style="text-align:right; color:${battRatio < 1 ? '#dc2626' : '#16a34a'}; font-weight:600;">${Math.round(battRatio * 100)}%</td></tr>`;
        body += `</table>`;
        body += `<div style="font-size:0.75rem; color:var(--text-muted); margin-top:4px;">Weights: Inverter 40% + Surge 25% + Battery 35%</div>`;

        // Load priority tiers
        body += `<h4>Load Priority Tiers</h4>`;
        const tierRow = (badge, cls, label, items) => {
            const list = items.length > 0
                ? items.map(a => `${a.name} (${a.ratedPowerW * a.quantity}W)`).join(', ')
                : '<em>None detected</em>';
            return `<div style="margin-bottom:8px;"><span class="tier-badge ${cls}">${badge}</span> <strong>${label}:</strong> ${list}</div>`;
        };
        body += tierRow('TIER 1', 'tier-1', 'Always On (Critical)', criticalLoads);
        body += tierRow('TIER 2', 'tier-2', 'Daytime Only (Heavy)', heavyNonCrit);
        body += tierRow('TIER 3', 'tier-3', 'Occasional (Light)', lightLoads);

        // Safe combos
        if (invRatio < 1) {
            body += `<h4>Safe Load Combinations</h4>`;
            body += `<div style="margin-bottom:6px;">Max simultaneous load: <strong>${safeSimW}W</strong></div>`;
            if (safeCombos.length > 0) {
                body += `<div class="combo-safe">&#10003; ${safeCombos.map(c => `${c.name} (${c.w}W)`).join(' + ')} = ${comboW}W [SAFE]</div>`;
            }
            if (heavyNonCrit.length >= 2) {
                const h1 = heavyNonCrit[0], h2 = heavyNonCrit[1];
                const uw = h1.ratedPowerW * h1.quantity + h2.ratedPowerW * h2.quantity;
                body += `<div class="combo-danger" style="margin-top:4px;">&#10007; ${h1.name} + ${h2.name} = ${uw}W [DANGER]</div>`;
            }
        }

        // Survival rules
        body += `<h4>Survival Rules</h4>`;
        body += `<ol style="margin:0; padding-left:20px;">`;
        body += `<li>NEVER run more than ONE Tier 2 appliance at a time</li>`;
        body += `<li>Turn off ALL Tier 2 loads by 4:00pm — battery only after sunset</li>`;
        body += `<li>If inverter trips: turn off last appliance started, wait 30s, restart</li>`;
        body += `<li>On cloudy days: Tier 1 loads only — no heavy loads at all</li>`;
        body += `<li>After 6pm: Tier 1 + Tier 3 only (lights, fan, TV, phone charging)</li>`;
        body += `</ol>`;

        // Upgrade nudge
        body += `<div style="margin-top:16px; padding:10px; background:var(--bg-color); border-radius:6px; font-size:0.82rem; border-left:3px solid ${scoreColor};">`;
        body += `<strong>Upgrade path:</strong> For full load comfort, upgrade to `;
        body += inv.autoSuggestedSizeVA ? `${inv.autoSuggestedSizeVA}VA inverter` : 'the auto-recommended inverter';
        body += autoAh > batt.totalCapacityAh ? ` and ${Math.round(autoAh)}Ah battery bank` : '';
        body += `. This eliminates all load management constraints.`;
        body += `</div>`;

        document.getElementById('copingModalTitle').textContent = `Coping Score: ${copingScore}% — ${scoreLabel}`;
        document.getElementById('copingModalBody').innerHTML = body;
        document.getElementById('copingModalOverlay').classList.add('active');
    },

    /**
     * Close coping score modal
     */
    closeCopingModal() {
        document.getElementById('copingModalOverlay').classList.remove('active');
    },

    /**
     * Convert battery kWh input to Ah based on bank voltage
     */
    convertBatteryKwhToAh() {
        const kwhInput = document.getElementById('batteryManualKwh');
        const ahInput = document.getElementById('batteryManualAh');
        const voltSelect = document.getElementById('batteryManualVoltage');
        const noteEl = document.getElementById('batteryConversionNote');
        const kwh = parseFloat(kwhInput.value);

        if (!kwh || kwh <= 0) {
            if (noteEl) noteEl.textContent = '';
            return;
        }

        // Determine voltage: use manual selection or default 48V
        let voltage = 48;
        if (voltSelect.value !== 'auto') {
            voltage = parseInt(voltSelect.value);
        }

        const ah = Math.round((kwh * 1000) / voltage * 10) / 10;
        ahInput.value = ah;

        if (noteEl) {
            noteEl.textContent = `${kwh} kWh ÷ ${voltage}V = ${ah} Ah`;
        }
    },

    /**
     * Convert battery Ah input to kWh for display
     */
    convertBatteryAhToKwh() {
        const kwhInput = document.getElementById('batteryManualKwh');
        const ahInput = document.getElementById('batteryManualAh');
        const voltSelect = document.getElementById('batteryManualVoltage');
        const noteEl = document.getElementById('batteryConversionNote');
        const ah = parseFloat(ahInput.value);

        if (!ah || ah <= 0) {
            if (noteEl) noteEl.textContent = '';
            return;
        }

        let voltage = 48;
        if (voltSelect.value !== 'auto') {
            voltage = parseInt(voltSelect.value);
        }

        const kwh = Math.round((ah * voltage) / 1000 * 100) / 100;
        kwhInput.value = kwh;

        if (noteEl) {
            noteEl.textContent = `${ah} Ah × ${voltage}V = ${kwh} kWh`;
        }
    },

    /**
     * Toggle mismatch panel details visibility and run analysis
     */
    toggleMismatchDetails() {
        const enabled = document.getElementById('pvMismatchEnabled').value === 'yes';
        const section = document.getElementById('pvMismatchSection');
        if (enabled) {
            section.classList.remove('hidden');
        } else {
            section.classList.add('hidden');
            document.getElementById('pvMismatchAnalysis').innerHTML = '';
        }
    },

    /**
     * Analyze mixed panel wattages for mismatch tolerance
     * Industry standard: panels within 5% of each other in the same string are acceptable
     * Same voltage class is critical for series strings; wattage variation matters less in parallel
     */
    analyzePanelMismatch() {
        const input = document.getElementById('pvMismatchList').value.trim();
        const analysisEl = document.getElementById('pvMismatchAnalysis');
        if (!input) {
            analysisEl.innerHTML = '';
            return null;
        }

        const wattages = input.split(',').map(w => parseFloat(w.trim())).filter(w => w > 0 && !isNaN(w));
        if (wattages.length < 2) {
            analysisEl.innerHTML = '<div class="alert alert-warning"><span class="alert-icon">&#9888;</span><div class="alert-content">Enter at least 2 panel wattages separated by commas.</div></div>';
            return null;
        }

        const minW = Math.min(...wattages);
        const maxW = Math.max(...wattages);
        const avgW = wattages.reduce((a, b) => a + b, 0) / wattages.length;
        const spread = ((maxW - minW) / avgW) * 100;
        const totalW = wattages.reduce((a, b) => a + b, 0);

        // Group by wattage
        const groups = {};
        wattages.forEach(w => { groups[w] = (groups[w] || 0) + 1; });
        const groupStr = Object.entries(groups).map(([w, c]) => `${c}x ${w}W`).join(' + ');

        let html = `<div style="font-size: 0.88rem; margin-bottom: 8px;"><strong>Panels:</strong> ${groupStr} = <strong>${totalW}W total</strong> (${wattages.length} panels, avg ${avgW.toFixed(0)}W)</div>`;

        if (spread <= 5) {
            html += `<div class="alert alert-info"><span class="alert-icon">&#10003;</span><div class="alert-content"><strong>Mismatch is ACCEPTABLE (${spread.toFixed(1)}% spread)</strong> — Within industry 5% tolerance. Safe to wire in the same string. The string output will be limited by the weakest panel's current, but energy loss is minimal (under 3%).</div></div>`;
        } else if (spread <= 10) {
            html += `<div class="alert alert-warning"><span class="alert-icon">&#9888;</span><div class="alert-content"><strong>Mismatch is MARGINAL (${spread.toFixed(1)}% spread)</strong> — Exceeds the ideal 5% but may still work. Expected energy loss: 5-8%. Best practice: put similar wattage panels in the same string, different strings can have different wattages. If all must be in one string, the weakest panel limits the entire string current.</div></div>`;
        } else {
            html += `<div class="alert alert-error"><span class="alert-icon">&#9888;</span><div class="alert-content"><strong>Mismatch is EXCESSIVE (${spread.toFixed(1)}% spread)</strong> — ${minW}W and ${maxW}W panels should NOT be in the same series string. The ${minW}W panel will bottleneck the entire string, wasting 10-20% of the larger panels' capacity. Solution: Group by wattage into separate strings (e.g., all ${minW}W in one string, all ${maxW}W in another) and wire strings in parallel. If using a dual-MPPT inverter, assign each wattage group to a different MPPT input.</div></div>`;
        }

        // Practical note about Vmp matching
        html += `<div style="font-size: 0.82rem; color: var(--text-muted); margin-top: 6px;"><strong>Note:</strong> Wattage mismatch tolerance assumes panels have similar Vmp (voltage at max power). If mixing different panel models, check that Vmp values are within 2V of each other for series strings. Different Imp (current) is acceptable in parallel strings.</div>`;

        analysisEl.innerHTML = html;

        return {
            wattages,
            totalW,
            avgW,
            spread,
            count: wattages.length,
            acceptable: spread <= 10
        };
    },

    /**
     * Toggle MPPT label for hybrid inverters (inputs always visible)
     */
    toggleMPPTSection() {
        const hasBuiltinMPPT = document.getElementById('inverterHasBuiltinMPPT').value === 'yes';
        const mpptNote = document.getElementById('mpptHybridNote');

        if (hasBuiltinMPPT) {
            mpptNote.classList.remove('hidden');
            mpptNote.textContent = '(Built-in to Hybrid Inverter - enter its MPPT specs below)';
        } else {
            mpptNote.classList.add('hidden');
        }
    },

    /**
     * Toggle visibility of additional MPPT input sections when count changes
     */
    toggleMultiMPPT() {
        const count = parseInt(document.getElementById('mpptInputCount').value) || 1;
        const additionalSection = document.getElementById('mpptAdditionalSection');
        const mppt3Section = document.getElementById('mppt3Section');

        if (count >= 2) {
            additionalSection.classList.remove('hidden');
        } else {
            additionalSection.classList.add('hidden');
        }

        if (count >= 3) {
            mppt3Section.classList.remove('hidden');
        } else {
            mppt3Section.classList.add('hidden');
        }
    },

    /**
     * Handle system type change (hybrid detection)
     * Never dims or hides MPPT inputs - just shows informational label
     */
    onSystemTypeChange() {
        const systemType = document.getElementById('systemType').value;
        const mpptNote = document.getElementById('mpptHybridNote');
        const gridSection = document.getElementById('gridChargingSection');

        if (systemType === 'hybrid') {
            mpptNote.classList.remove('hidden');
            mpptNote.textContent = '(Built-in to Hybrid Inverter - enter its MPPT specs below)';
            if (gridSection) gridSection.classList.remove('hidden');
        } else if (systemType === 'grid_tie') {
            mpptNote.classList.remove('hidden');
            mpptNote.textContent = '(Built-in to Grid-Tie Inverter - enter its MPPT specs below)';
            if (gridSection) gridSection.classList.remove('hidden');
        } else {
            mpptNote.classList.add('hidden');
            if (gridSection) gridSection.classList.add('hidden');
        }
    },

    /**
     * Edit appliance - populate form with existing values
     */
    editAppliance(index) {
        const app = LoadEngine.appliances[index];
        if (!app) return;

        // Populate form
        document.getElementById('appName').value = app.name;
        document.getElementById('appQuantity').value = app.quantity;
        document.getElementById('appPower').value = app.ratedPowerW;
        document.getElementById('appHours').value = app.dailyUsageHours;
        document.getElementById('appDutyCycle').value = app.dutyCycle;
        document.getElementById('appLoadType').value = app.loadType;
        document.getElementById('appStartMethod').value = app.startMethod || 'dol';
        document.getElementById('appSurgeFactor').value = app.surgeFactor;
        document.getElementById('appPowerFactor').value = app.powerFactor;
        document.getElementById('appDaytimeRatio').value = app.daytimeRatio;
        document.getElementById('appSimultaneous').checked = app.isSimultaneous;

        // Restore motor sub-type and show/hide motor fields
        this.updateLoadTypeDefaults();
        if (app.loadType === 'motor' && app.motorSubType) {
            document.getElementById('appMotorSubType').value = app.motorSubType;
            this.onMotorSubTypeChange();
        }

        // Mark as editing
        this.editingIndex = index;

        // Change button to "Update"
        const btn = document.getElementById('addApplianceBtn');
        if (btn) {
            btn.textContent = 'Update Appliance';
            btn.style.background = 'var(--warning-color)';
        }

        // Scroll to form
        document.getElementById('appName').focus();
        document.getElementById('appName').scrollIntoView({ behavior: 'smooth', block: 'center' });
    },

    /**
     * Clear all appliances
     */
    clearAllAppliances() {
        if (confirm('Are you sure you want to remove all appliances?')) {
            LoadEngine.appliances = [];
            this.renderApplianceList();
        }
    },

    /**
     * Save to localStorage
     */
    saveToLocalStorage() {
        const data = {
            appliances: LoadEngine.appliances,
            config: this.getConfig(),
            panel: this.getPanel(),
            mppt: this.getMPPT(),
            cableLengths: this.getCableLengths(),
            batteryChemistry: document.getElementById('batteryChemistry').value,
            savedAt: new Date().toISOString()
        };
        localStorage.setItem('pvCalculatorData', JSON.stringify(data));
        alert('Data saved to browser storage!');
    },

    /**
     * Load from localStorage
     */
    loadFromLocalStorage() {
        const saved = localStorage.getItem('pvCalculatorData');
        if (!saved) {
            alert('No saved data found.');
            return;
        }

        try {
            const data = JSON.parse(saved);

            // Restore appliances
            LoadEngine.appliances = data.appliances || [];
            this.renderApplianceList();

            // Restore config
            if (data.config) {
                document.getElementById('location').value = data.config.location || 'lagos';
                document.getElementById('systemType').value = data.config.systemType || 'off_grid';
                document.getElementById('acVoltage').value = data.config.acVoltage || 230;
                document.getElementById('avgPSH').value = data.config.avgPSH || 4.5;
                document.getElementById('autonomyDays').value = data.config.autonomyDays || 2;
                document.getElementById('designMargin').value = data.config.designMargin || 125;
            }

            // Restore panel
            if (data.panel) {
                document.getElementById('panelWattage').value = data.panel.wattage || 400;
                document.getElementById('panelVmp').value = data.panel.vmp || 41;
                document.getElementById('panelVoc').value = data.panel.voc || 49;
                document.getElementById('panelImp').value = data.panel.imp || 9.76;
                document.getElementById('panelIsc').value = data.panel.isc || 10.36;
            }

            alert(`Data loaded! (Saved: ${new Date(data.savedAt).toLocaleString()})`);
            this.validatePanelSpecs();
        } catch (e) {
            alert('Error loading saved data: ' + e.message);
        }
    },

    /**
     * Handle staggered motor start toggle
     */
    onStaggerToggle() {
        const cb = document.getElementById('staggerMotorStarts');
        if (!cb) return;
        // Store preference
        this._staggerMotorStarts = cb.checked;
        // Re-calculate to reflect the choice
        this.calculate();
    },

    /**
     * Auto-suggest panel electrical specs based on wattage (auto mode only)
     */
    autoSuggestPanelSpecs() {
        const isManual = document.getElementById('manualMode').checked;
        if (isManual) return;

        const wattage = parseInt(document.getElementById('panelWattage').value) || 0;
        if (wattage <= 0) return;

        // Find exact match or interpolate from presets
        const presets = DEFAULTS.PANEL_PRESETS;
        const sizes = Object.keys(presets).map(Number).sort((a, b) => a - b);

        let specs = null;
        if (presets[wattage]) {
            specs = { ...presets[wattage] };
        } else {
            // Interpolate between nearest presets
            let lower = sizes[0], upper = sizes[sizes.length - 1];
            for (let i = 0; i < sizes.length - 1; i++) {
                if (sizes[i] <= wattage && sizes[i + 1] >= wattage) {
                    lower = sizes[i];
                    upper = sizes[i + 1];
                    break;
                }
            }
            if (wattage <= lower) {
                specs = { ...presets[lower] };
            } else if (wattage >= upper) {
                specs = { ...presets[upper] };
                // Scale current for higher wattage
                specs.imp = Math.round(wattage / specs.vmp * 100) / 100;
                specs.isc = Math.round(specs.imp * 1.06 * 100) / 100;
            } else {
                const ratio = (wattage - lower) / (upper - lower);
                const lo = presets[lower], hi = presets[upper];
                specs = {
                    vmp: Math.round((lo.vmp + ratio * (hi.vmp - lo.vmp)) * 10) / 10,
                    voc: Math.round((lo.voc + ratio * (hi.voc - lo.voc)) * 10) / 10,
                    imp: 0, isc: 0,
                    tempCoeffPmax: Math.round((lo.tempCoeffPmax + ratio * (hi.tempCoeffPmax - lo.tempCoeffPmax)) * 100) / 100,
                    tempCoeffVoc: Math.round((lo.tempCoeffVoc + ratio * (hi.tempCoeffVoc - lo.tempCoeffVoc)) * 100) / 100
                };
                // Derive Imp from wattage / Vmp, then Isc
                specs.imp = Math.round(wattage / specs.vmp * 100) / 100;
                specs.isc = Math.round(specs.imp * 1.06 * 100) / 100;
            }
        }

        if (specs) {
            document.getElementById('panelVmp').value = specs.vmp;
            document.getElementById('panelVoc').value = specs.voc;
            document.getElementById('panelImp').value = specs.imp;
            document.getElementById('panelIsc').value = specs.isc;
            document.getElementById('panelTempCoeffPmax').value = specs.tempCoeffPmax;
            document.getElementById('panelTempCoeffVoc').value = specs.tempCoeffVoc;

            // Show auto-suggest indicator
            const msg = document.getElementById('panelValidationMsg');
            if (msg) {
                msg.innerHTML = '<div class="validation-message validation-success" style="background: rgba(34,197,94,0.08);">Auto-suggested specs for ' + wattage + 'Wp panel. Switch to Manual mode to enter your own specs.</div>';
            }
            const badge = document.getElementById('panelValidationBadge');
            if (badge) {
                badge.innerHTML = '<span class="spec-badge match">AUTO</span>';
            }

            // Run validation to confirm
            this.validatePanelSpecs();
        }
    },

    /**
     * Auto-suggest MPPT controller specs based on inverter VA rating (auto mode only)
     */
    autoSuggestMPPTSpecs(inverterVA) {
        const isManual = document.getElementById('manualMode').checked;
        if (isManual) return;
        if (!inverterVA || inverterVA <= 0) return;

        const presets = DEFAULTS.MPPT_PRESETS;
        const sizes = Object.keys(presets).map(Number).sort((a, b) => a - b);

        // Find the closest match (equal or next larger)
        let matchSize = sizes[sizes.length - 1];
        for (const size of sizes) {
            if (size >= inverterVA) {
                matchSize = size;
                break;
            }
        }

        const specs = presets[matchSize];
        if (!specs) return;

        document.getElementById('mpptMaxVoltage').value = specs.maxVoltage;
        document.getElementById('mpptMaxCurrent').value = specs.maxCurrent;
        document.getElementById('mpptMaxPower').value = specs.maxPower;
        document.getElementById('mpptMinVoltage').value = specs.minVoltage;
        document.getElementById('mpptMaxOperatingVoltage').value = specs.maxOperating;
        document.getElementById('mpptMaxChargeCurrent').value = specs.maxCharge;
    },

    /**
     * Simulate adding a new load (Phase 10 UI)
     */
    simulateUpgrade() {
        if (!this.results) {
            alert('Please calculate the base system first.');
            return;
        }

        const name = document.getElementById('simAppName').value.trim();
        const power = parseFloat(document.getElementById('simAppPower').value) || 0;
        const hours = parseFloat(document.getElementById('simAppHours').value) || 4;
        const loadType = document.getElementById('simAppType').value;

        if (!name || power <= 0) {
            alert('Please enter appliance name and power.');
            return;
        }

        const newAppliance = {
            name,
            quantity: 1,
            ratedPowerW: power,
            dailyUsageHours: hours,
            dutyCycle: 100,
            loadType,
            surgeFactor: loadType === 'motor' ? 6 : 1,
            powerFactor: loadType === 'motor' ? 0.8 : (loadType === 'electronic' ? 0.95 : 1),
            daytimeRatio: 50,
            isSimultaneous: true,
            isAC: true,
            efficiency: loadType === 'motor' ? 0.85 : 1.0
        };

        // Run simulation
        const result = UpgradeSimulator.simulateLoadAddition(this.results, newAppliance, this.getConfig());

        // Display results
        const container = document.getElementById('upgradeSimResults');
        container.classList.remove('hidden');

        if (result.canAccommodate) {
            container.innerHTML = `
                <div class="alert alert-success">
                    <span class="alert-icon">&#10003;</span>
                    <div class="alert-content">
                        <div class="alert-title">System CAN accommodate ${name}</div>
                        <p>New daily energy: ${Math.round(result.newDailyEnergy)} Wh (+${Math.round(result.newDailyEnergy - this.results.aggregation.dailyEnergyWh)} Wh)</p>
                        <p>New peak load: ${Math.round(result.newPeakLoad)} VA</p>
                    </div>
                </div>
            `;
        } else {
            let upgradeHtml = '<ul>';
            result.upgrades.forEach(u => {
                upgradeHtml += `<li><strong>${u.component}:</strong> ${u.current} → ${u.required} (${u.reason})</li>`;
            });
            upgradeHtml += '</ul>';

            container.innerHTML = `
                <div class="alert alert-warning">
                    <span class="alert-icon">&#9888;</span>
                    <div class="alert-content">
                        <div class="alert-title">Upgrades Required for ${name}</div>
                        ${upgradeHtml}
                        <p style="margin-top: 8px;">New daily energy: ${Math.round(result.newDailyEnergy)} Wh</p>
                    </div>
                </div>
            `;
        }
    },

    /**
     * Export to PDF using jsPDF
     */
    async exportPDF() {
        if (!this.results) {
            alert('No results to export. Please calculate first.');
            return;
        }

        const spinner = document.getElementById('pdfSpinnerOverlay');
        if (spinner) spinner.classList.add('active');

        // Small delay to let spinner render before heavy PDF work
        await new Promise(r => setTimeout(r, 50));

        try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');
            const R = this.results;
            const agg = R.aggregation;
            const inv = R.inverter;
            const batt = R.battery;
            const pv = R.pvArray;
            const cables = R.cables;
            const prot = R.protection;
            const losses = R.losses;
            const advisories = R.advisories || [];
            const upgradePaths = R.upgradePaths || [];
            const config = R.config;
            const includeDetails = document.getElementById('pdfIncludeDetails')
                ? document.getElementById('pdfIncludeDetails').checked : true;

            const pageW = doc.internal.pageSize.getWidth();   // 210
            const pageH = doc.internal.pageSize.getHeight();  // 297
            const mL = 16, mR = 16, mT = 28, mB = 22;
            const contentW = pageW - mL - mR;
            const LH = 5.5;  // standard line height
            let y = mT;
            let pageNum = 0;

            // Color palette
            const BLUE = [37, 99, 235];
            const DARK = [30, 41, 59];
            const MUTED = [100, 116, 139];
            const RED = [220, 38, 38];
            const AMBER = [217, 119, 6];
            const GREEN = [22, 163, 74];
            const WHITE = [255, 255, 255];
            const LIGHT_BG = [248, 250, 252];
            const BLUE_BG = [219, 234, 254];
            const RED_BG = [254, 226, 226];
            const AMBER_BG = [254, 243, 199];
            const GREEN_BG = [220, 252, 231];

            // ---- SVG-to-Image capture helper (for embedding UI diagram in PDF) ----
            async function captureSvgAsImage(svgElement, maxWidthMm) {
                try {
                    // Clone SVG to avoid modifying the DOM
                    const clone = svgElement.cloneNode(true);
                    const computed = getComputedStyle(document.documentElement);

                    // Resolve CSS variables to concrete values
                    const cssVarMap = {
                        'var(--bg-color, #f8fafc)': computed.getPropertyValue('--bg-color').trim() || '#f8fafc',
                        'var(--bg-color)': computed.getPropertyValue('--bg-color').trim() || '#f8fafc',
                        'var(--card-bg, #fff)': computed.getPropertyValue('--card-bg').trim() || '#ffffff',
                        'var(--card-bg)': computed.getPropertyValue('--card-bg').trim() || '#ffffff',
                        'var(--text-color, #1e293b)': computed.getPropertyValue('--text-color').trim() || '#1e293b',
                        'var(--text-color)': computed.getPropertyValue('--text-color').trim() || '#1e293b',
                        'var(--border-color, #e2e8f0)': computed.getPropertyValue('--border-color').trim() || '#e2e8f0',
                        'var(--border-color)': computed.getPropertyValue('--border-color').trim() || '#e2e8f0',
                        'var(--text-muted, #94a3b8)': computed.getPropertyValue('--text-muted').trim() || '#94a3b8',
                        'var(--text-muted)': computed.getPropertyValue('--text-muted').trim() || '#94a3b8',
                        'var(--primary-color, #2563eb)': computed.getPropertyValue('--primary-color').trim() || '#2563eb',
                        'var(--primary-color)': computed.getPropertyValue('--primary-color').trim() || '#2563eb'
                    };

                    // Walk all elements and inline their fill/stroke/color
                    const allEls = clone.querySelectorAll('*');
                    const resolveVar = (val) => {
                        if (!val || !val.includes('var(')) return val;
                        for (const [cssVar, concrete] of Object.entries(cssVarMap)) {
                            val = val.replace(cssVar, concrete);
                        }
                        // Fallback: strip remaining var() with fallback
                        val = val.replace(/var\([^,]+,\s*([^)]+)\)/g, '$1');
                        return val;
                    };
                    allEls.forEach(el => {
                        ['fill', 'stroke', 'color', 'stop-color'].forEach(attr => {
                            const v = el.getAttribute(attr);
                            if (v && v.includes('var(')) el.setAttribute(attr, resolveVar(v));
                        });
                        if (el.style) {
                            const s = el.getAttribute('style');
                            if (s && s.includes('var(')) el.setAttribute('style', resolveVar(s));
                        }
                    });
                    // Also resolve on the root SVG itself
                    const rootStyle = clone.getAttribute('style');
                    if (rootStyle && rootStyle.includes('var(')) {
                        clone.setAttribute('style', resolveVar(rootStyle));
                    }
                    const rootFill = clone.getAttribute('fill');
                    if (rootFill && rootFill.includes('var(')) {
                        clone.setAttribute('fill', resolveVar(rootFill));
                    }

                    // Get viewBox dimensions
                    const vb = clone.getAttribute('viewBox');
                    if (!vb) return null;
                    const [, , vbW, vbH] = vb.split(/[\s,]+/).map(Number);
                    if (!vbW || !vbH) return null;

                    // Force light background for PDF (always light theme in print)
                    const bgRect = clone.querySelector('rect:first-child');
                    if (bgRect) {
                        bgRect.setAttribute('fill', '#f8fafc');
                        bgRect.setAttribute('stroke', '#e2e8f0');
                    }

                    // Set explicit dimensions for canvas render
                    const scale = 2; // 2x for sharpness
                    const canvasW = vbW * scale;
                    const canvasH = vbH * scale;
                    clone.setAttribute('width', canvasW);
                    clone.setAttribute('height', canvasH);
                    clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                    clone.removeAttribute('style'); // Remove max-width etc that could interfere

                    // Ensure all text elements have explicit font-family for canvas rendering
                    clone.querySelectorAll('text').forEach(t => {
                        if (!t.getAttribute('font-family')) {
                            t.setAttribute('font-family', 'Arial, Helvetica, sans-serif');
                        }
                    });

                    // Serialize to data URL
                    const svgData = new XMLSerializer().serializeToString(clone);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);

                    // Render to canvas
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            canvas.width = canvasW;
                            canvas.height = canvasH;
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = '#f8fafc';
                            ctx.fillRect(0, 0, canvasW, canvasH);
                            ctx.drawImage(img, 0, 0, canvasW, canvasH);
                            URL.revokeObjectURL(url);

                            const dataUrl = canvas.toDataURL('image/png');
                            // Calculate PDF dimensions (mm)
                            const pdfW = Math.min(maxWidthMm, contentW);
                            const pdfH = pdfW * (vbH / vbW);
                            resolve({ dataUrl, pdfW, pdfH, format: 'PNG' });
                        };
                        img.onerror = () => {
                            URL.revokeObjectURL(url);
                            resolve(null);
                        };
                        img.src = url;
                    });
                } catch (err) {
                    console.warn('SVG capture failed:', err);
                    return null;
                }
            }

            // Pre-capture the overview SVG before generating pages
            const overviewSvg = document.querySelector('#tab-overview svg');
            let svgImageData = null;
            if (overviewSvg) {
                svgImageData = await captureSvgAsImage(overviewSvg, contentW);
            }

            // Location name
            const locKey = document.getElementById('location') ? document.getElementById('location').value : 'lagos';
            const locName = (DEFAULTS.LOCATIONS[locKey] || {}).name || 'Custom Location';
            const dateStr = new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
            const timeStr = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            const systemTypeLabel = (document.getElementById('systemType') || {}).value === 'hybrid' ? 'Hybrid' : 'Off-Grid';

            // ── HELPER FUNCTIONS ──

            function setColor(rgb) { doc.setTextColor(rgb[0], rgb[1], rgb[2]); }
            function setDrawColor(rgb) { doc.setDrawColor(rgb[0], rgb[1], rgb[2]); }
            function setFillColor(rgb) { doc.setFillColor(rgb[0], rgb[1], rgb[2]); }

            function addPageHeader() {
                // Top accent bar
                setFillColor(BLUE);
                doc.rect(0, 0, pageW, 3.5, 'F');
                // Logo text
                setFillColor(BLUE);
                doc.roundedRect(mL, 6, 26, 10, 2, 2, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                setColor(WHITE);
                doc.text('PV CALC', mL + 13, 12.5, { align: 'center' });
                // Title right of logo
                doc.setFontSize(8);
                setColor(MUTED);
                doc.setFont('helvetica', 'normal');
                doc.text('Advanced Photovoltaic System Design Report', mL + 30, 10);
                doc.setFontSize(7);
                doc.text(`${locName}  |  ${dateStr}`, mL + 30, 14.5);
                // Thin separator
                setDrawColor(BLUE);
                doc.setLineWidth(0.3);
                doc.line(mL, 19, pageW - mR, 19);
            }

            function addPageFooter() {
                pageNum++;
                const footY = pageH - 10;
                // Separator line
                setDrawColor([226, 232, 240]);
                doc.setLineWidth(0.2);
                doc.line(mL, footY - 3, pageW - mR, footY - 3);
                // Footer text
                doc.setFontSize(6.5);
                doc.setFont('helvetica', 'italic');
                setColor(MUTED);
                doc.text('Guidance only — real performance varies (dust, shading, temperature). Professional installation required for safety.', mL, footY);
                doc.text(`Leebartea  |  v2.3.0  |  Page ${pageNum}`, pageW - mR, footY, { align: 'right' });
            }

            function newPage() {
                addPageFooter();
                doc.addPage();
                addPageHeader();
                y = mT;
            }

            function checkSpace(needed) {
                if (y + needed > pageH - mB - 5) {
                    newPage();
                    return true;
                }
                return false;
            }

            function sectionTitle(title) {
                checkSpace(16);
                y += 4;
                setFillColor(BLUE);
                doc.rect(mL, y - 4.5, 2.5, 7, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(13);
                setColor(DARK);
                doc.text(title, mL + 6, y + 0.5);
                y += 8;
                // Thin line under
                setDrawColor([226, 232, 240]);
                doc.setLineWidth(0.15);
                doc.line(mL, y - 2, pageW - mR, y - 2);
            }

            function subTitle(title) {
                checkSpace(10);
                y += 2;
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9.5);
                setColor(BLUE);
                doc.text(title, mL, y);
                y += 5;
                setColor(DARK);
            }

            function bodyText(text, indent) {
                indent = indent || 0;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8.5);
                setColor(DARK);
                const lines = doc.splitTextToSize(text, contentW - indent);
                lines.forEach(line => {
                    checkSpace(LH);
                    doc.text(line, mL + indent, y);
                    y += LH;
                });
            }

            function mutedText(text, indent) {
                indent = indent || 0;
                doc.setFont('helvetica', 'italic');
                doc.setFontSize(7.5);
                setColor(MUTED);
                const lines = doc.splitTextToSize(text, contentW - indent);
                lines.forEach(line => {
                    checkSpace(LH);
                    doc.text(line, mL + indent, y);
                    y += LH - 0.5;
                });
                setColor(DARK);
            }

            function labelValue(label, value, indent) {
                indent = indent || 0;
                checkSpace(LH);
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8.5);
                setColor(MUTED);
                doc.text(label, mL + indent, y);
                doc.setFont('helvetica', 'bold');
                setColor(DARK);
                doc.text(String(value), mL + indent + 62, y);
                y += LH;
            }

            function bulletItem(text, severity, indent) {
                indent = indent || 0;
                const marker = severity === 'critical' ? 'X ' : severity === 'warning' ? '! ' : '- ';
                doc.setFont('helvetica', severity === 'critical' ? 'bold' : 'normal');
                doc.setFontSize(8);
                if (severity === 'critical') setColor(RED);
                else if (severity === 'warning') setColor(AMBER);
                else setColor(DARK);
                const lines = doc.splitTextToSize(marker + text, contentW - indent - 4);
                lines.forEach((line, i) => {
                    checkSpace(LH);
                    doc.text(line, mL + indent + (i > 0 ? 4 : 0), y);
                    y += LH;
                });
                setColor(DARK);
            }

            // Draw a filled rounded box with label/value (summary card)
            function summaryCard(x, yPos, w, h, label, value, accent) {
                accent = accent || BLUE;
                setFillColor(LIGHT_BG);
                doc.roundedRect(x, yPos, w, h, 2, 2, 'F');
                setFillColor(accent);
                doc.rect(x, yPos, w, 2.5, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(13);
                setColor(accent);
                doc.text(String(value), x + w / 2, yPos + 13, { align: 'center' });
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(7);
                setColor(MUTED);
                doc.text(label, x + w / 2, yPos + 19, { align: 'center' });
            }

            // Draw a simple table with header row
            function drawTable(headers, rows, colWidths, startX) {
                startX = startX || mL;
                const rowH = 6;
                const headerH = 7;

                checkSpace(headerH + rowH * Math.min(rows.length, 3) + 4);

                // Header row
                setFillColor(BLUE);
                doc.rect(startX, y - 1, colWidths.reduce((a, b) => a + b, 0), headerH, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(7.5);
                setColor(WHITE);
                let cx = startX + 2;
                headers.forEach((h, i) => {
                    doc.text(h, cx, y + 3);
                    cx += colWidths[i];
                });
                y += headerH + 1;

                // Data rows
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(7.5);
                rows.forEach((row, rIdx) => {
                    checkSpace(rowH + 2);
                    if (rIdx % 2 === 0) {
                        setFillColor(LIGHT_BG);
                        doc.rect(startX, y - 3.5, colWidths.reduce((a, b) => a + b, 0), rowH, 'F');
                    }
                    cx = startX + 2;
                    setColor(DARK);
                    row.forEach((cell, i) => {
                        const cellText = String(cell);
                        const truncated = cellText.length > Math.floor(colWidths[i] / 2.2)
                            ? cellText.substring(0, Math.floor(colWidths[i] / 2.2)) + '..'
                            : cellText;
                        doc.text(truncated, cx, y);
                        cx += colWidths[i];
                    });
                    y += rowH;
                });
                y += 2;
            }

            // Strip HTML tags from advisory messages
            function stripHTML(html) {
                return html.replace(/<br\s*\/?>/gi, ' ').replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim();
            }

            // ══════════════════════════════════════════════════════════
            // PAGE 1: COVER + SYSTEM SUMMARY
            // ══════════════════════════════════════════════════════════

            addPageHeader();

            // Cover title area
            y = 32;
            setFillColor(BLUE);
            doc.roundedRect(mL, y, contentW, 32, 3, 3, 'F');
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(20);
            setColor(WHITE);
            doc.text('PV System Design Report', pageW / 2, y + 13, { align: 'center' });
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.text(`${locName}  —  ${dateStr}, ${timeStr}`, pageW / 2, y + 22, { align: 'center' });
            doc.setFontSize(8);
            doc.text(`${systemTypeLabel} System  |  Generated by Advanced PV Calculator v2.3.0`, pageW / 2, y + 28, { align: 'center' });
            y += 40;

            // Summary cards (2 rows of 3)
            const cardW = (contentW - 12) / 3;
            const cardH = 22;
            const cardsRow1 = [
                { label: 'Daily Energy (Wh)', value: Math.round(agg.dailyEnergyWh), accent: BLUE },
                { label: 'Peak Load (VA)', value: Math.round(agg.peakSimultaneousVA), accent: BLUE },
                { label: inv.isManualOverride ? `Inverter (VA) Manual` : 'Inverter (VA)', value: inv.recommendedSizeVA, accent: inv.isManualOverride ? AMBER : BLUE }
            ];
            const cardsRow2 = [
                { label: `Battery (Ah) ${batt.chemistryName}`, value: Math.round(batt.totalCapacityAh), accent: batt.isManualOverride ? AMBER : BLUE },
                { label: `PV Array (Wp) ${pv.totalPanels} panels`, value: pv.arrayWattage, accent: GREEN },
                { label: 'System Efficiency', value: losses.overallSystemEfficiency + '%', accent: losses.overallSystemEfficiency >= 75 ? GREEN : AMBER }
            ];

            cardsRow1.forEach((c, i) => {
                summaryCard(mL + i * (cardW + 6), y, cardW, cardH, c.label, c.value, c.accent);
            });
            y += cardH + 5;
            cardsRow2.forEach((c, i) => {
                summaryCard(mL + i * (cardW + 6), y, cardW, cardH, c.label, c.value, c.accent);
            });
            y += cardH + 8;

            // Detailed summary rows
            sectionTitle('System Configuration');
            labelValue('System Type:', `${systemTypeLabel}  |  ${config.acVoltage || 230}V AC`);
            labelValue('Location Profile:', `${locName}  |  PSH: ${config.avgPSH}h  |  Temp: ${config.ambientTempMin}–${config.ambientTempMax}°C`);
            labelValue('Autonomy:', `${config.autonomyDays} day(s)  |  Design Margin: ${config.designMargin}%`);
            labelValue('DC Bus Voltage:', `${inv.dcBusVoltage}V`);
            if (inv.isManualOverride) {
                labelValue('Inverter (Your Input):', `${inv.recommendedSizeVA} VA  (${InverterSizingEngine.formatMarketRange(inv.recommendedSizeVA)})`);
                labelValue('Inverter (Auto-Rec):', `${inv.autoSuggestedSizeVA} VA  (${InverterSizingEngine.formatMarketRange(inv.autoSuggestedSizeVA)})`);
                // Validation status line
                const invUnderCont = inv.recommendedSizeVA * 0.8 < (inv.continuousVARequired || 0);
                const invStatus = invUnderCont ? 'UNDERSIZED — cannot handle continuous load' : inv.recommendedSizeVA < (inv.autoSuggestedSizeVA || 0) ? 'UNDERSIZED — less headroom than recommended' : 'MEETS requirements';
                const statusColor = invUnderCont ? RED : inv.recommendedSizeVA < (inv.autoSuggestedSizeVA || 0) ? AMBER : GREEN;
                checkSpace(LH);
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(8.5);
                setColor(statusColor);
                doc.text(`Validation: ${invStatus}`, mL + 62, y);
                y += LH;
                setColor(DARK);
            } else {
                labelValue('Inverter:', `${inv.recommendedSizeVA} VA  (${InverterSizingEngine.formatMarketRange(inv.recommendedSizeVA)})`);
            }
            if (batt.isManualOverride || batt.isUnitCountOverride) {
                labelValue('Battery (Your Input):', `${Math.round(batt.totalCapacityAh)} Ah  |  ${batt.cellsInSeries}S${batt.stringsInParallel}P  |  ${batt.chemistryName}  |  ${Math.round(batt.totalCapacityWh)}Wh`);
                if (batt.autoSuggestedAh || batt.autoSuggestedStrings) {
                    const autoAh = batt.autoSuggestedAh || (batt.autoSuggestedStrings ? batt.autoSuggestedStrings * batt.recommendedAhPerCell : 0);
                    if (autoAh > 0) labelValue('Battery (Auto-Rec):', `${Math.round(autoAh)} Ah  (auto-calculated for ${config.autonomyDays} day autonomy)`);
                }
            } else {
                labelValue('Battery Bank:', `${Math.round(batt.totalCapacityAh)} Ah  |  ${batt.cellsInSeries}S${batt.stringsInParallel}P  |  ${batt.chemistryName}  |  ${Math.round(batt.totalCapacityWh)}Wh`);
            }
            labelValue('PV Array:', `${pv.arrayWattage} Wp  |  ${pv.panelsInSeries}S × ${pv.stringsInParallel}P = ${pv.totalPanels} panels`);
            labelValue('MPPT Validation:', R.mpptValidation.isValid ? 'PASS — All checks within limits' : 'ISSUES — See warnings below');
            labelValue('Total Appliances:', `${LoadEngine.appliances.length}  |  Daily: ${Math.round(agg.dailyEnergyWh)} Wh`);

            // Grid charging specs (if hybrid with grid params)
            const gridMaxA_pdf = parseFloat((document.getElementById('gridMaxChargeA') || {}).value) || 0;
            const gridVRange_pdf = (document.getElementById('gridInputVoltageRange') || {}).value || '';
            if (gridMaxA_pdf > 0) {
                labelValue('Grid Charge Current:', `${gridMaxA_pdf}A max`);
                if (gridVRange_pdf) labelValue('Grid Input Range:', `${gridVRange_pdf} VAC`);
            }

            // Manual override notes
            if (inv.isManualOverride || batt.isManualOverride || (pv.isManualOverride)) {
                y += 2;
                mutedText('Manual overrides active — values reflect your inputs. Auto-Rec values show what the calculator would suggest. See Warnings (Page 3) and Coping Strategies (Page 4) for details.');
            }

            // Expert mode badge
            const isExpertPdf = document.getElementById('expertMode')?.checked || false;
            if (isExpertPdf) {
                checkSpace(12);
                y += 2;
                setFillColor(AMBER_BG);
                doc.roundedRect(mL, y - 3, contentW, 8, 2, 2, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(8);
                setColor(AMBER);
                doc.text('\u26A0  Expert Mode Active — Auto-rec hard blocks suppressed. Manual specs validated instead.', mL + 3, y + 1.5);
                y += 8;
                setColor(DARK);
            }

            // ══════════════════════════════════════════════════════════
            // PAGE 2: SYSTEM DIAGRAM (SVG image + fallback text diagram)
            // ══════════════════════════════════════════════════════════

            newPage();
            sectionTitle('System Overview Diagram');
            y += 2;

            // Try to embed the captured SVG from the UI Overview tab
            let svgEmbedded = false;
            if (svgImageData && svgImageData.dataUrl) {
                try {
                    // Calculate image dimensions to fit page width, capped height
                    let imgW = svgImageData.pdfW;
                    const maxImgH = pageH - mT - mB - 40; // leave room for header/footer/cable table
                    let imgH = svgImageData.pdfH;
                    if (imgH > maxImgH) {
                        // Scale down proportionally to maintain aspect ratio
                        const scaleFactor = maxImgH / imgH;
                        imgH = maxImgH;
                        imgW = imgW * scaleFactor;
                    }
                    const imgX = mL + (contentW - imgW) / 2; // centered

                    doc.addImage(svgImageData.dataUrl, svgImageData.format, imgX, y, imgW, imgH);
                    y += imgH + 4;
                    svgEmbedded = true;

                    // Caption
                    doc.setFontSize(6.5);
                    doc.setFont('helvetica', 'italic');
                    setColor(MUTED);
                    doc.text('Full system diagram — shows every panel and battery unit with wiring, protection devices, and cable specs.', mL, y);
                    y += 6;
                } catch (imgErr) {
                    console.warn('SVG image embed failed, using fallback diagram:', imgErr);
                    svgEmbedded = false;
                }
            }

            // Fallback: text-based block diagram (also used if SVG is too tall and we have space issues)
            if (!svgEmbedded) {
                subTitle('System Block Diagram');
                y += 2;

                const diagramCenterX = pageW / 2;
                const boxW = 58, boxH = 18;
                const smallBoxH = 14;

                // PV Array box
                setFillColor(GREEN_BG);
                setDrawColor(GREEN);
                doc.setLineWidth(0.4);
                doc.roundedRect(diagramCenterX - boxW / 2, y, boxW, boxH, 2, 2, 'FD');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                setColor(GREEN);
                doc.text('SOLAR PANELS', diagramCenterX, y + 6, { align: 'center' });
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(7.5);
                setColor(DARK);
                doc.text(`${pv.totalPanels} x ${config.panelWattage || Math.round(pv.arrayWattage / pv.totalPanels)}W = ${pv.arrayWattage}Wp`, diagramCenterX, y + 11.5, { align: 'center' });
                doc.text(`${pv.panelsInSeries}S x ${pv.stringsInParallel}P  |  Voc(cold): ${Math.round(pv.stringVocCold || 0)}V`, diagramCenterX, y + 15, { align: 'center' });
                y += boxH;

                // Arrow down
                setDrawColor(RED);
                doc.setLineWidth(0.5);
                doc.line(diagramCenterX, y, diagramCenterX, y + 6);
                y += 6;
                doc.setFontSize(6);
                setColor(RED);
                doc.text(`Isc: ${(pv.arrayIsc || 0).toFixed(1)}A`, diagramCenterX + 8, y - 2);

                // MPPT / Charge Controller box
                setFillColor(BLUE_BG);
                setDrawColor(BLUE);
                doc.setLineWidth(0.4);
                doc.roundedRect(diagramCenterX - boxW / 2, y, boxW, boxH, 2, 2, 'FD');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                setColor(BLUE);
                const mpptLabel = systemTypeLabel === 'Hybrid' ? 'HYBRID INVERTER' : 'MPPT CONTROLLER';
                doc.text(mpptLabel, diagramCenterX, y + 6, { align: 'center' });
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(7.5);
                setColor(DARK);
                const mpptSpec = R.config.mpptMaxVoltage ? `Max: ${R.config.mpptMaxVoltage}V / ${R.config.mpptMaxCurrent}A` : '';
                doc.text(mpptSpec || `Matched to ${inv.recommendedSizeVA}VA inverter`, diagramCenterX, y + 11.5, { align: 'center' });
                doc.text(`Max Power: ${R.config.mpptMaxPower || 'Auto'}W`, diagramCenterX, y + 15, { align: 'center' });
                y += boxH;

                // Arrow down to split
                setDrawColor(RED);
                doc.setLineWidth(0.5);
                doc.line(diagramCenterX, y, diagramCenterX, y + 4);
                y += 4;

                const sideOffset = 38;

                // Battery box (left)
                const battX = diagramCenterX - sideOffset - boxW / 2 + 8;
                setFillColor(AMBER_BG);
                setDrawColor(AMBER);
                doc.setLineWidth(0.4);
                doc.roundedRect(battX, y, boxW, boxH, 2, 2, 'FD');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                setColor(AMBER);
                doc.text('BATTERY BANK', battX + boxW / 2, y + 6, { align: 'center' });
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(7.5);
                setColor(DARK);
                doc.text(`${Math.round(batt.totalCapacityAh)}Ah @ ${batt.bankVoltage}V  |  ${batt.chemistryName}`, battX + boxW / 2, y + 11.5, { align: 'center' });
                doc.text(`${batt.cellsInSeries}S x ${batt.stringsInParallel}P = ${batt.totalCells} units  |  ${Math.round(batt.totalCapacityWh)}Wh`, battX + boxW / 2, y + 15, { align: 'center' });

                // Inverter box (right)
                const invX = diagramCenterX + sideOffset - boxW / 2 - 8;
                setFillColor(BLUE_BG);
                setDrawColor(BLUE);
                doc.roundedRect(invX, y, boxW, boxH, 2, 2, 'FD');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                setColor(BLUE);
                doc.text('INVERTER', invX + boxW / 2, y + 6, { align: 'center' });
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(7.5);
                setColor(DARK);
                doc.text(`${inv.recommendedSizeVA} VA  |  ${inv.dcBusVoltage}V DC`, invX + boxW / 2, y + 11.5, { align: 'center' });
                doc.text(`Surge: ${Math.round(inv.recommendedSizeVA * (config.inverterSurgeMultiplier || 2))}VA (${config.inverterSurgeMultiplier || 2}x)`, invX + boxW / 2, y + 15, { align: 'center' });

                // Connecting lines
                setDrawColor([100, 116, 139]);
                doc.setLineWidth(0.4);
                doc.line(battX + boxW / 2, y - 0.5, invX + boxW / 2, y - 0.5);
                doc.line(battX + boxW / 2, y - 0.5, battX + boxW / 2, y);
                doc.line(invX + boxW / 2, y - 0.5, invX + boxW / 2, y);

                y += boxH + 4;

                // AC Loads box
                setDrawColor(BLUE);
                doc.setLineWidth(0.5);
                doc.line(invX + boxW / 2, y - 4, invX + boxW / 2, y);
                setDrawColor(AMBER);
                doc.line(battX + boxW, y - boxH / 2 - 4, invX, y - boxH / 2 - 4);

                setFillColor(LIGHT_BG);
                setDrawColor(DARK);
                doc.setLineWidth(0.4);
                doc.roundedRect(invX, y, boxW, smallBoxH, 2, 2, 'FD');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                setColor(DARK);
                doc.text('AC LOADS', invX + boxW / 2, y + 5.5, { align: 'center' });
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(7.5);
                setColor(MUTED);
                doc.text(`${LoadEngine.appliances.length} appliances  |  ${Math.round(agg.dailyEnergyWh)}Wh/day`, invX + boxW / 2, y + 10, { align: 'center' });
                y += smallBoxH + 6;

                doc.setFontSize(6.5);
                doc.setFont('helvetica', 'italic');
                setColor(MUTED);
                doc.text('Wire labels: DC cables (red), AC cables (blue). All currents include NEC 125% continuous factor.', mL, y);
                y += 8;
            }

            // Cable summary under diagram (always shown, whether SVG or fallback)
            checkSpace(40);
            subTitle('Cable Sizing Summary');
            const allCableRuns = [...(cables.dcRuns || []), ...(cables.acRuns || [])];
            if (allCableRuns.length > 0) {
                const cableHeaders = ['Cable Run', 'Current (A)', 'Size (mm²)', 'V-Drop (%)', 'Status'];
                const cableRows = allCableRuns.map(r => [
                    r.name.replace(/\(.*\)/, '').trim().substring(0, 28),
                    r.current.toFixed(1),
                    r.sizeRangeDisplay || `${r.recommendedMm2}mm²`,
                    r.actualVoltageDropPercent.toFixed(2) + '%',
                    r.voltageDropOK && r.ampacityOK ? 'PASS' : 'WARN'
                ]);
                drawTable(cableHeaders, cableRows, [52, 24, 32, 26, 20]);
            }

            // ══════════════════════════════════════════════════════════
            // PAGE 3: WARNINGS & HARD BLOCKS
            // ══════════════════════════════════════════════════════════

            newPage();
            const allBlocks = OutputGenerator.collectAllBlocks(R);
            const allWarnings = OutputGenerator.collectAllWarnings(R);

            if (allBlocks.length > 0) {
                sectionTitle('Hard Blocks — Action Required');
                y += 1;
                setFillColor(RED_BG);
                doc.roundedRect(mL, y - 2, contentW, Math.min(allBlocks.length * 14 + 6, 60), 2, 2, 'F');
                allBlocks.forEach(block => {
                    bulletItem(block, 'critical', 2);
                    y += 1;
                });
                y += 4;
            }

            sectionTitle('Warnings & Notices');
            if (allWarnings.length === 0) {
                bodyText('No warnings — system design is within all limits.');
            } else {
                allWarnings.forEach((w, i) => {
                    // Alternate severity hint based on content
                    const sev = /HARD BLOCK|exceeds|undersized|impractical|dangerous/i.test(w) ? 'critical'
                        : /warning|surge|smaller|limited|high/i.test(w) ? 'warning' : 'info';
                    bulletItem(w, sev, 2);
                    if (i < allWarnings.length - 1) y += 0.5;
                });
            }

            // Suggestions if any
            const defense = DefenseNotes.checkForBlocks(R);
            if (defense.suggestions && defense.suggestions.length > 0) {
                y += 4;
                subTitle('Suggested Solutions');
                defense.suggestions.forEach(s => {
                    bulletItem(s, 'info', 2);
                });
            }

            // Coping Score in PDF (if undersized)
            if (inv.isManualOverride || batt.isManualOverride) {
                const invUsableW_pdf = (inv.recommendedSizeVA || 0) * DEFAULTS.INVERTER_DERATING;
                const contNeeded_pdf = agg.designContinuousVA || agg.peakSimultaneousVA || 0;
                const invRatio_pdf = contNeeded_pdf > 0 ? Math.min(invUsableW_pdf / contNeeded_pdf, 1.0) : 1.0;
                const surgeNeeded_pdf = agg.highestSurgeVA || agg.designSurgeVA || 0;
                const surgeCap_pdf = (inv.recommendedSizeVA || 0) * (R.config?.inverterSurgeMultiplier || 2.0);
                const surgeRatio_pdf = surgeNeeded_pdf > 0 ? Math.min(surgeCap_pdf / surgeNeeded_pdf, 1.0) : 1.0;
                const autoAh_pdf = batt.autoSuggestedAh || batt.totalCapacityAh;
                const battRatio_pdf = autoAh_pdf > 0 ? Math.min(batt.totalCapacityAh / autoAh_pdf, 1.0) : 1.0;
                const copingScore_pdf = Math.round((invRatio_pdf * 0.40 + surgeRatio_pdf * 0.25 + battRatio_pdf * 0.35) * 100);

                if (copingScore_pdf < 95) {
                    checkSpace(20);
                    y += 4;
                    const scoreColor_pdf = copingScore_pdf >= 75 ? [22, 163, 74] : copingScore_pdf >= 50 ? [217, 119, 6] : [220, 38, 38];
                    const scoreLabel_pdf = copingScore_pdf >= 75 ? 'Manageable' : copingScore_pdf >= 50 ? 'Tight' : 'Critical';
                    doc.setFillColor(...scoreColor_pdf);
                    doc.roundedRect(mL, y, contentW, 14, 2, 2, 'F');
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(255, 255, 255);
                    doc.text(`Coping Score: ${copingScore_pdf}% — ${scoreLabel_pdf} (with load management)`, mL + contentW / 2, y + 9, { align: 'center' });
                    y += 18;
                }
            }

            // ══════════════════════════════════════════════════════════
            // PAGE 4: ADVISORY — PRACTICAL TIPS
            // ══════════════════════════════════════════════════════════

            newPage();
            sectionTitle('Advisory — Practical Usage Tips');
            y += 1;

            // Coping score bar at top of advisory page
            {
                const invUsableW_adv = (inv.recommendedSizeVA || 0) * DEFAULTS.INVERTER_DERATING;
                const contNeeded_adv = agg.designContinuousVA || agg.peakSimultaneousVA || 0;
                const invRatio_adv = contNeeded_adv > 0 ? Math.min(invUsableW_adv / contNeeded_adv, 1.0) : 1.0;
                const surgeNeeded_adv = agg.highestSurgeVA || agg.designSurgeVA || 0;
                const surgeCap_adv = (inv.recommendedSizeVA || 0) * (R.config?.inverterSurgeMultiplier || 2.0);
                const surgeRatio_adv = surgeNeeded_adv > 0 ? Math.min(surgeCap_adv / surgeNeeded_adv, 1.0) : 1.0;
                const autoAh_adv = batt.autoSuggestedAh || batt.totalCapacityAh;
                const battRatio_adv = autoAh_adv > 0 ? Math.min(batt.totalCapacityAh / autoAh_adv, 1.0) : 1.0;
                const copingPct = Math.round((invRatio_adv * 0.40 + surgeRatio_adv * 0.25 + battRatio_adv * 0.35) * 100);
                const barColor = copingPct >= 75 ? GREEN : copingPct >= 50 ? AMBER : RED;
                const barLabel = copingPct >= 75 ? 'Manageable' : copingPct >= 50 ? 'Tight' : 'Critical';

                checkSpace(18);
                // Background track
                setFillColor([226, 232, 240]);
                doc.roundedRect(mL, y, contentW, 6, 2, 2, 'F');
                // Filled portion
                const fillW = Math.max(4, contentW * copingPct / 100);
                setFillColor(barColor);
                doc.roundedRect(mL, y, fillW, 6, 2, 2, 'F');
                // Label
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(7.5);
                setColor(WHITE);
                const barText = `Coping Score: ${copingPct}% — ${barLabel}`;
                doc.text(barText, mL + contentW / 2, y + 4.2, { align: 'center' });
                y += 10;
                setColor(DARK);
            }

            // Group advisories by category
            const advByCategory = {};
            advisories.forEach(adv => {
                const cat = adv.category || 'General';
                if (!advByCategory[cat]) advByCategory[cat] = [];
                advByCategory[cat].push(adv);
            });

            // Priority order for categories
            const catOrder = ['Coping Strategies', 'Daily Routine', 'Load Management', 'Heating Appliances', 'Battery', 'Grid Charging', 'PV Array', 'General'];
            const sortedCats = catOrder.filter(c => advByCategory[c]).concat(
                Object.keys(advByCategory).filter(c => !catOrder.includes(c))
            );

            let advisoryCount = 0;
            const maxAdvisories = 18; // Limit to prevent PDF from being too long
            for (const cat of sortedCats) {
                if (advisoryCount >= maxAdvisories) break;
                const catAdvs = advByCategory[cat];
                subTitle(cat);

                for (const adv of catAdvs) {
                    if (advisoryCount >= maxAdvisories) break;
                    checkSpace(16);

                    // Severity badge
                    const badgeColor = adv.severity === 'critical' ? RED : adv.severity === 'warning' ? AMBER : BLUE;
                    const badgeBg = adv.severity === 'critical' ? RED_BG : adv.severity === 'warning' ? AMBER_BG : BLUE_BG;
                    setFillColor(badgeBg);
                    doc.roundedRect(mL + 2, y - 3.5, contentW - 4, 5, 1, 1, 'F');
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(8);
                    setColor(badgeColor);
                    doc.text(adv.title, mL + 4, y);
                    y += 4;

                    // Message (stripped of HTML)
                    const cleanMsg = stripHTML(adv.message);
                    // Truncate very long messages to keep PDF reasonable
                    const truncMsg = cleanMsg.length > 350 ? cleanMsg.substring(0, 347) + '...' : cleanMsg;
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(7.5);
                    setColor(DARK);
                    const msgLines = doc.splitTextToSize(truncMsg, contentW - 8);
                    msgLines.forEach(line => {
                        checkSpace(LH);
                        doc.text(line, mL + 4, y);
                        y += LH - 0.3;
                    });
                    y += 3;
                    advisoryCount++;
                }
            }

            if (advisoryCount >= maxAdvisories && advisories.length > maxAdvisories) {
                mutedText(`Showing ${maxAdvisories} of ${advisories.length} advisories. See on-screen results for the complete list.`);
            }

            // ══════════════════════════════════════════════════════════
            // PAGE 5: UPGRADE PATHS
            // ══════════════════════════════════════════════════════════

            newPage();
            sectionTitle('Upgrade & Expansion Paths');
            y += 1;
            mutedText('Future-proofing your system — what you can add and when you will need upgrades.');
            y += 3;

            if (upgradePaths && upgradePaths.length > 0) {
                upgradePaths.forEach(path => {
                    checkSpace(20);
                    subTitle(path.category);
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(8);
                    setColor(MUTED);
                    doc.text('Current: ' + (path.current || ''), mL + 2, y);
                    y += LH + 1;

                    if (path.options && path.options.length > 0) {
                        path.options.slice(0, 3).forEach(opt => {
                            checkSpace(16);
                            // Colored badge background for feasibility
                            const feasIcon = opt.feasible ? '\u2713 OK' : '\u26A0 Upgrade';
                            const feasColor = opt.feasible ? GREEN : RED;
                            const feasBg = opt.feasible ? GREEN_BG : RED_BG;
                            setFillColor(feasBg);
                            doc.roundedRect(mL + 2, y - 3.2, opt.feasible ? 14 : 20, 4.5, 1, 1, 'F');
                            doc.setFont('helvetica', 'bold');
                            doc.setFontSize(6.5);
                            setColor(feasColor);
                            doc.text(feasIcon, mL + 3, y);
                            // Label in dark or amber depending on feasibility
                            setColor(opt.feasible ? DARK : AMBER);
                            doc.setFont('helvetica', 'normal');
                            doc.setFontSize(7.5);
                            doc.text(opt.label, mL + (opt.feasible ? 18 : 24), y);
                            y += LH;
                            if (opt.detail) {
                                doc.setFontSize(7);
                                // Color detail text: orange for non-feasible, muted for feasible
                                setColor(opt.feasible ? MUTED : AMBER);
                                const detailLines = doc.splitTextToSize(opt.detail, contentW - 16);
                                detailLines.slice(0, 2).forEach(dl => {
                                    checkSpace(LH);
                                    doc.text(dl, mL + 12, y);
                                    y += LH - 0.5;
                                });
                            }
                            if (opt.impact) {
                                doc.setFontSize(7);
                                setColor(opt.feasible ? GREEN : RED);
                                doc.setFont('helvetica', 'bold');
                                const impLines = doc.splitTextToSize(opt.impact, contentW - 16);
                                impLines.slice(0, 1).forEach(il => {
                                    checkSpace(LH);
                                    doc.text(il, mL + 12, y);
                                    y += LH - 0.5;
                                });
                                doc.setFont('helvetica', 'normal');
                            }
                            y += 2;
                        });
                    }
                    y += 2;
                });
            } else {
                bodyText('No upgrade analysis data available. Run calculation with appliances to generate upgrade paths.');
            }

            // ══════════════════════════════════════════════════════════
            // CONDITIONAL DETAILED PAGES (if checkbox is checked)
            // ══════════════════════════════════════════════════════════

            if (includeDetails) {

                // ── LOAD TABLE ──
                newPage();
                sectionTitle('Load Analysis — Appliance Breakdown');
                y += 1;

                // Summary row
                labelValue('Total Real Power:', `${Math.round(agg.totalRealPowerW || agg.designContinuousVA * 0.85)} W`);
                labelValue('Total Apparent Power:', `${Math.round(agg.totalApparentPowerVA || agg.designContinuousVA)} VA`);
                labelValue('Daily Energy:', `${Math.round(agg.dailyEnergyWh)} Wh`);
                labelValue('Daytime Energy:', `${Math.round(agg.daytimeEnergyWh || 0)} Wh  (${Math.round((agg.daytimeEnergyWh || 0) / agg.dailyEnergyWh * 100)}%)`);
                labelValue('Nighttime Energy:', `${Math.round(agg.nighttimeEnergyWh || agg.dailyEnergyWh)} Wh`);
                labelValue('Worst-Case Surge:', `${Math.round(agg.highestSurgeVA || agg.designSurgeVA)} VA`);
                if (agg.designStaggeredSurgeVA) {
                    labelValue('Staggered Surge:', `${Math.round(agg.designStaggeredSurgeVA)} VA`);
                }
                if (agg.complianceRisk && agg.complianceRisk !== 'low') {
                    labelValue('Compliance Risk:', `${agg.complianceRisk.toUpperCase()} — ${agg.complianceNote || ''}`);
                }
                y += 3;

                // Appliance table
                if (LoadEngine.appliances.length > 0) {
                    subTitle('Appliance List');
                    const appHeaders = ['Appliance', 'Qty', 'Watts', 'Hours', 'Duty%', 'Type', 'Daily Wh'];
                    const appRows = LoadEngine.appliances.map(a => [
                        a.name.substring(0, 20),
                        a.quantity,
                        a.ratedPowerW,
                        a.dailyUsageHours,
                        a.dutyCycle + '%',
                        a.loadType.substring(0, 6),
                        Math.round(LoadEngine.calculateDailyEnergyWh(a))
                    ]);
                    drawTable(appHeaders, appRows, [38, 14, 22, 18, 18, 22, 24]);
                }

                // ── INVERTER DETAIL ──
                checkSpace(60);
                sectionTitle('Inverter Sizing Detail');
                y += 1;

                // Three-tier table
                subTitle('Three-Tier Inverter Recommendation');
                const tierHeaders = ['Tier', 'Size (VA)', 'Market Range', 'Basis'];
                const tierRows = [
                    ['Conservative', inv.recommendedSizeVA + ' VA', InverterSizingEngine.formatMarketRange(inv.recommendedSizeVA), 'Worst-case surge (all motors start together)'],
                    ['Recommended', (inv.recommendedBalancedSizeVA || inv.recommendedSizeVA) + ' VA',
                        InverterSizingEngine.formatMarketRange(inv.recommendedBalancedSizeVA || inv.recommendedSizeVA),
                        'Compliance-aware balance + motor buffer'],
                    ['Optimized', (inv.staggeredSizeVA || inv.recommendedSizeVA) + ' VA',
                        InverterSizingEngine.formatMarketRange(inv.staggeredSizeVA || inv.recommendedSizeVA),
                        'Staggered motor starts (30s apart)']
                ];
                drawTable(tierHeaders, tierRows, [30, 26, 34, 68]);

                labelValue('DC Bus Voltage:', `${inv.dcBusVoltage}V`);
                labelValue('DC Current (continuous):', `${inv.dcInputCurrentContinuous} A`);
                labelValue('DC Current (surge):', `${inv.dcInputCurrentSurge} A`);
                labelValue('Motor Buffer:', `${inv.motorBufferPct || 0}%`);
                if (inv.complianceRisk && inv.complianceRisk !== 'low') {
                    labelValue('Compliance Risk:', `${inv.complianceRisk.toUpperCase()} (+${inv.complianceBuffer || 0}% buffer applied)`);
                }

                // ── BATTERY DETAIL ──
                checkSpace(50);
                sectionTitle('Battery Sizing Detail');
                y += 1;
                labelValue('Chemistry:', batt.chemistryName);
                labelValue('Bank Voltage:', `${batt.bankVoltage}V`);
                labelValue('Total Capacity:', `${Math.round(batt.totalCapacityAh)} Ah  (${Math.round(batt.totalCapacityWh)} Wh)`);
                labelValue('Usable Capacity:', `${Math.round(batt.usableCapacityWh)} Wh  (${Math.round(DEFAULTS.BATTERY_SPECS[batt.chemistry].maxDoD * 100)}% DoD)`);
                labelValue('Configuration:', `${batt.cellsInSeries}S x ${batt.stringsInParallel}P = ${batt.totalCells} cells/units`);
                labelValue('Ah per Unit:', `${batt.recommendedAhPerCell} Ah`);
                labelValue('Max Discharge:', `${batt.maxDischargeCurrent} A  (${DEFAULTS.BATTERY_SPECS[batt.chemistry].maxDischargeRate}C)`);
                labelValue('Max Charge:', `${batt.maxChargeCurrent} A  (${DEFAULTS.BATTERY_SPECS[batt.chemistry].maxChargeRate}C)`);
                labelValue('Cycle Life:', `${DEFAULTS.BATTERY_SPECS[batt.chemistry].cycleLife}+ cycles at ${Math.round(DEFAULTS.BATTERY_SPECS[batt.chemistry].maxDoD * 100)}% DoD`);

                // Design basis and tier recommendations in PDF
                if (batt.designBasis && !batt.isManualOverride) {
                    y += 3;
                    const db = batt.designBasis;
                    subTitle('Battery Design Basis');
                    labelValue('Required Nominal:', `${db.requiredNominalKWh} kWh`);
                    mutedText(`= (${(db.dailyLoadWh / 1000).toFixed(2)} kWh daily × ${db.autonomyDays} day${db.autonomyDays > 1 ? 's' : ''}) ÷ (${Math.round(db.dod * 100)}% DoD × ${Math.round(db.dischargeEfficiency * 100)}% eff) × ${db.designMargin}% margin`);
                    y += 1;
                }

                if (batt.tiers && !batt.isManualOverride) {
                    y += 2;
                    subTitle('Battery Sizing Tiers');
                    const tierList = [
                        { t: batt.tiers.economy, c: AMBER },
                        { t: batt.tiers.balanced, c: BLUE },
                        { t: batt.tiers.expansion, c: GREEN }
                    ];
                    const tierHeaders = ['Tier', 'Nominal', 'Actual', 'Module / Config'];
                    const tierRows = tierList.map(({ t }) => [
                        t.label,
                        `${t.nominalKWh} kWh`,
                        `${t.kWh} kWh (${t.ah} Ah${t.strings > 1 ? ', ' + t.strings + 'P' : ''})`,
                        t.module ? (t.module.stackCount > 1 ? `${t.module.stackCount}× ${t.module.stackUnit ? t.module.stackUnit.kWh + ' kWh' : t.module.label}` : t.module.label) : '—'
                    ]);
                    drawTable(tierHeaders, tierRows, [38, 24, 40, 56]);

                    if (batt.moduleMatch && batt.isLithium) {
                        mutedText(`Recommended module: ${batt.moduleMatch.label} — ${batt.moduleMatch.note}. Standard: 51.2V (16S × 3.2V).`);
                    }
                    if (batt.capacityRange) {
                        mutedText(`Capacity range: ${batt.capacityRange.minKWh}–${batt.capacityRange.maxKWh} kWh  (${batt.capacityRange.min}–${batt.capacityRange.max} Ah)`);
                    }
                }

                // ── PV ARRAY DETAIL ──
                checkSpace(50);
                sectionTitle('PV Array Detail');
                y += 1;
                labelValue('Array Wattage:', `${pv.arrayWattage} Wp  (${pv.totalPanels} panels)`);
                labelValue('Panel Wattage:', `${Math.round(pv.arrayWattage / pv.totalPanels)} Wp`);
                labelValue('Configuration:', `${pv.panelsInSeries}S x ${pv.stringsInParallel}P`);
                labelValue('String Vmp:', `${(pv.stringVmp || 0).toFixed(1)} V`);
                labelValue('String Voc (cold):', `${(pv.stringVocCold || 0).toFixed(1)} V`);
                labelValue('Array Imp:', `${(pv.arrayImp || 0).toFixed(1)} A`);
                labelValue('Array Isc:', `${(pv.arrayIsc || 0).toFixed(1)} A`);
                labelValue('Daily PV Energy:', `${Math.round(pv.dailyEnergyWh || pv.arrayWattage * (config.avgPSH || 4.5) * 0.8)} Wh`);
                if (pv.isManualOverride && pv.autoSuggested) {
                    mutedText(`Auto-suggested: ${pv.autoSuggested.totalPanels} panels (${pv.autoSuggested.panelsInSeries}S x ${pv.autoSuggested.stringsInParallel}P = ${pv.autoSuggested.arrayWattage}Wp)`);
                }

                // ── PROTECTION DEVICES ──
                checkSpace(40);
                sectionTitle('Protection Devices');
                y += 1;

                const protSections = [
                    { title: 'PV Side', devices: prot.pvSide || [] },
                    { title: 'Battery Side', devices: prot.batterySide || [] },
                    { title: 'AC Side', devices: prot.acSide || [] },
                    { title: 'Earthing', devices: prot.earthing || [] }
                ];

                protSections.forEach(section => {
                    if (section.devices.length > 0) {
                        subTitle(section.title);
                        const protHeaders = ['Device', 'Type / Rating', 'Location'];
                        const protRows = section.devices.map(d => [
                            d.name.substring(0, 26),
                            (`${d.type || ''} ${d.rating || ''}`).substring(0, 38),
                            (d.location || '').substring(0, 34)
                        ]);
                        drawTable(protHeaders, protRows, [42, 60, 56]);
                    }
                });

                // ── SYSTEM LOSSES ──
                checkSpace(40);
                sectionTitle('System Losses & Efficiency');
                y += 1;
                const lossHeaders = ['Component', 'Value'];
                const lossRows = [
                    ['PV Temperature Derating', losses.pvTempDerating + '%'],
                    ['PV Soiling Loss', losses.pvSoilingLoss + '%'],
                    ['PV Mismatch Loss', losses.pvMismatchLoss + '%'],
                    ['DC Cable Loss', losses.dcCableLoss + '%'],
                    ['MPPT Efficiency', losses.mpptEfficiency + '%'],
                    ['Battery Round-Trip', losses.batteryRoundTripEfficiency + '%'],
                    ['Inverter Efficiency', losses.inverterEfficiency + '%'],
                    ['AC Cable Loss', losses.acCableLoss + '%'],
                    ['─────────────────────', '─────'],
                    ['Overall System Efficiency', losses.overallSystemEfficiency + '%'],
                    ['Net Available Energy', losses.netAvailableEnergyDaily + ' Wh/day'],
                    ['Energy Margin', (losses.energyMarginPercent >= 0 ? '+' : '') + losses.energyMarginPercent + '%']
                ];
                drawTable(lossHeaders, lossRows, [66, 40]);

            } // end includeDetails

            // ══════════════════════════════════════════════════════════
            // FINAL PAGE: DISCLAIMER
            // ══════════════════════════════════════════════════════════

            checkSpace(55);
            y += 6;
            sectionTitle('Disclaimer & Engineering Caveats');
            y += 1;

            setFillColor(AMBER_BG);
            doc.roundedRect(mL, y - 2, contentW, 46, 2, 2, 'F');
            y += 2;

            const disclaimers = [
                'Estimates Only: All values are calculated estimates based on manufacturer specifications and standard engineering formulas. Real-world performance varies due to weather, shading, panel orientation, wiring quality, temperature extremes, and component aging.',
                'Not a Substitute for Professional Design: This tool assists with system sizing but does not replace a professional site survey, structural assessment, or electrical design by a certified solar installer.',
                'Battery Performance: Battery capacity degrades over time. Actual usable capacity will be less than rated after 1-2 years. Temperature significantly affects battery life.',
                'Solar Variability: Peak sun hours are annual averages. Daily output varies by season and weather. Rainy season output can be 40-60% less than dry season.',
                'Safety: All electrical work must be performed by qualified personnel. Incorrect wiring or undersized components can cause fire, equipment damage, or electric shock.'
            ];

            disclaimers.forEach(d => {
                checkSpace(12);
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(7);
                setColor(DARK);
                const lines = doc.splitTextToSize('• ' + d, contentW - 8);
                lines.forEach(line => {
                    doc.text(line, mL + 4, y);
                    y += 4;
                });
                y += 1;
            });

            // Final footer
            addPageFooter();

            // Add total page count to all pages
            const totalPages = doc.getNumberOfPages();
            for (let i = 1; i <= totalPages; i++) {
                doc.setPage(i);
                doc.setFontSize(6.5);
                doc.setFont('helvetica', 'italic');
                // Overwrite the page number area with white rect first
                doc.setFillColor(255, 255, 255);
                doc.rect(pageW - mR - 50, pageH - 14, 52, 8, 'F');
                doc.setTextColor(148, 163, 184);
                doc.text(`Leebartea  |  v2.3.0  |  Page ${i} of ${totalPages}`, pageW - mR, pageH - 10, { align: 'right' });
            }

            // Save
            const fileName = `PV_System_Design_${locName.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().slice(0, 10)}.pdf`;
            doc.save(fileName);

        } catch (e) {
            console.error('PDF export error:', e);
            alert('PDF export failed. jsPDF may not be loaded. Error: ' + e.message);
        } finally {
            const spinnerEl = document.getElementById('pdfSpinnerOverlay');
            if (spinnerEl) spinnerEl.classList.remove('active');
        }
    },

    /**
     * Apply location-specific defaults
     */
    applyLocationDefaults() {
        const location = document.getElementById('location').value;
        const defaults = DEFAULTS.LOCATIONS[location];

        if (defaults) {
            document.getElementById('avgPSH').value = defaults.avgPSH;
            document.getElementById('ambientTempMin').value = defaults.ambientTempMin;
            document.getElementById('ambientTempMax').value = defaults.ambientTempMax;
            document.getElementById('acVoltage').value = defaults.acVoltage;
        }
    },

    /**
     * Update load type defaults when selection changes
     */
    updateLoadTypeDefaults() {
        const loadType = document.getElementById('appLoadType').value;
        const defaults = DEFAULTS.LOAD_TYPES[loadType];

        if (defaults) {
            document.getElementById('appSurgeFactor').value = defaults.surgeFactor;
            document.getElementById('appPowerFactor').value = defaults.powerFactor;
        }

        // Show/hide motor-specific fields based on load type
        const motorStartGroup = document.getElementById('appStartMethod').parentElement;
        const motorSubTypeGroup = document.getElementById('appMotorSubType').parentElement;
        if (loadType === 'motor') {
            motorStartGroup.style.display = 'block';
            motorSubTypeGroup.style.display = 'block';
            const startMethod = document.getElementById('appStartMethod').value;
            document.getElementById('appSurgeFactor').value = DEFAULTS.MOTOR_START_SURGE[startMethod];
        } else {
            motorStartGroup.style.display = 'none';
            motorSubTypeGroup.style.display = 'none';
            // Clear sub-type when not motor
            document.getElementById('appMotorSubType').value = '';
        }
    },

    /**
     * Handle motor start method change — update surge factor
     */
    onStartMethodChange() {
        const loadType = document.getElementById('appLoadType').value;
        if (loadType === 'motor') {
            const startMethod = document.getElementById('appStartMethod').value;
            document.getElementById('appSurgeFactor').value = DEFAULTS.MOTOR_START_SURGE[startMethod];
        }
    },

    /**
     * Handle motor sub-type selection — sets efficiency, surge, power factor, start method
     */
    onMotorSubTypeChange() {
        const subType = document.getElementById('appMotorSubType').value;
        if (!subType) return;

        const specs = DEFAULTS.MOTOR_SUBTYPES[subType];
        if (!specs) return;

        document.getElementById('appStartMethod').value = specs.startMethod;
        document.getElementById('appSurgeFactor').value = specs.surgeFactor;
        document.getElementById('appPowerFactor').value = specs.powerFactor;

        // Show sub-type hint
        const hintEl = document.getElementById('motorSubTypeHint');
        if (hintEl) hintEl.innerHTML = specs.hint;

        // If servo selected on a sewing machine, show upgrade tip
        const name = (document.getElementById('appName').value || '').toLowerCase();
        const hintDiv = document.getElementById('appAutoHint');
        if (hintDiv && /sew/.test(name)) {
            if (subType === 'servo') {
                hintDiv.innerHTML = '<strong>Servo sewing machine:</strong> Excellent for PV! Uses 40-60% less energy than clutch. Low surge (1.5x) allows smaller inverter. Recommended for solar setups.';
                hintDiv.style.display = 'block';
                hintDiv.style.borderLeftColor = '#22c55e';
                hintDiv.style.background = '#f0fdf4';
                hintDiv.style.color = '#166534';
            } else if (subType === 'clutch') {
                hintDiv.innerHTML = '<strong>Clutch sewing machine:</strong> Common and affordable, but uses 40-60% more energy than servo. Higher surge (3-4x). <em>Upgrade tip: Switch to servo motor — drops energy use ~40% and reduces required inverter size by ~20%.</em>';
                hintDiv.style.display = 'block';
                hintDiv.style.borderLeftColor = '#f59e0b';
                hintDiv.style.background = '#fffbeb';
                hintDiv.style.color = '#92400e';
            }
        }
    },

    /**
     * Auto-detect appliance from name and fill in defaults
     */
    autoDetectAppliance() {
        const nameInput = document.getElementById('appName');
        const name = (nameInput?.value || '').toLowerCase().trim();
        const hintDiv = document.getElementById('appAutoHint');

        if (!name || name.length < 2) {
            if (hintDiv) hintDiv.style.display = 'none';
            return;
        }

        let bestMatch = null;
        for (const [pattern, preset] of Object.entries(DEFAULTS.APPLIANCE_PRESETS)) {
            try {
                if (new RegExp(pattern, 'i').test(name)) {
                    bestMatch = preset;
                    break;
                }
            } catch(e) {}
        }

        if (!bestMatch) {
            if (hintDiv) hintDiv.style.display = 'none';
            return;
        }

        // Auto-fill wattage only if user hasn't typed a value
        const powerInput = document.getElementById('appPower');
        if (powerInput && !powerInput.value) {
            powerInput.value = bestMatch.watt;
        } else if (powerInput && powerInput.value) {
            powerInput.placeholder = 'Suggested: ' + bestMatch.watt + 'W';
        }

        document.getElementById('appLoadType').value = bestMatch.loadType;
        document.getElementById('appStartMethod').value = bestMatch.startMethod;
        document.getElementById('appSurgeFactor').value = bestMatch.surgeFactor;
        document.getElementById('appPowerFactor').value = bestMatch.powerFactor;
        document.getElementById('appDutyCycle').value = bestMatch.dutyCycle;
        document.getElementById('appHours').value = bestMatch.hours;

        // Auto-set motor sub-type based on appliance name
        const subTypeEl = document.getElementById('appMotorSubType');
        if (bestMatch.loadType === 'motor' && subTypeEl) {
            if (/sew/i.test(name)) {
                // Sewing machine: default to clutch, detect servo
                if (/servo/i.test(name)) {
                    subTypeEl.value = 'servo';
                } else {
                    subTypeEl.value = 'clutch';
                }
                // Apply sub-type specs
                this.onMotorSubTypeChange();
            } else if (/fridge|freezer|refrigerator|a\.?c\.?|air\s*con|split/i.test(name)) {
                subTypeEl.value = 'compressor';
                this.onMotorSubTypeChange();
            } else if (/pump|borehole/i.test(name)) {
                subTypeEl.value = 'pump';
                this.onMotorSubTypeChange();
            } else if (/fan|blower/i.test(name)) {
                subTypeEl.value = 'fan';
                this.onMotorSubTypeChange();
            } else {
                subTypeEl.value = 'general';
                this.onMotorSubTypeChange();
            }
        } else if (subTypeEl) {
            subTypeEl.value = ''; // Clear for non-motor loads
        }

        // Show/hide motor start method
        this.updateLoadTypeDefaults();
        // Override surge back to sub-type/preset (updateLoadTypeDefaults may have changed it)
        document.getElementById('appSurgeFactor').value = bestMatch.surgeFactor;

        // Build hint with industrial/domestic detection
        let hintText = '<strong>Auto-detected:</strong> ' + bestMatch.hint;
        const userWatt = parseFloat(document.getElementById('appPower').value) || bestMatch.watt;
        if (/sew/i.test(name)) {
            if (userWatt > 400) {
                hintText += '<br><strong style="color: #dc2626;">Industrial use detected</strong> (' + userWatt + 'W). Surge: 4-7x (2000-5000VA peak). Sizing uses higher surge and compliance buffer for reliability.';
            } else if (userWatt > 250) {
                hintText += '<br><em style="color: #d97706;">Medium sewing machine (' + userWatt + 'W). If this is industrial (tailoring shop), consider entering 400-750W for proper surge calculation.</em>';
            } else {
                hintText += '<br><em>Domestic/light sewing machine (' + userWatt + 'W, ~⅓HP). Surge: 3-4x (~750-1000VA peak). Comfortable for 2000VA+ inverter with staggering.</em>';
            }
        }

        if (hintDiv) {
            hintDiv.innerHTML = hintText;
            hintDiv.style.display = 'block';
            hintDiv.style.borderLeftColor = '#3b82f6';
            hintDiv.style.background = '#eff6ff';
            hintDiv.style.color = '#1e40af';
        }
    },

    /**
     * Add appliance to list
     */
    addAppliance() {
        const motorSubType = document.getElementById('appMotorSubType').value;

        // Require motor sub-type for motor loads
        const loadType = document.getElementById('appLoadType').value;
        if (loadType === 'motor' && !motorSubType) {
            alert('Motor Sub-Type is required for accurate surge and efficiency sizing.\n\nSelect the motor sub-type (clutch, servo, compressor, pump, fan, or general) to proceed.\n\nWhy it matters:\n• Clutch motor: 3-4x surge, ~60% efficiency\n• Servo motor: 1.5x surge, ~90% efficiency\n• Compressor: 5-7x surge (fridge/freezer/AC)\n\nThis directly impacts inverter and battery sizing.');
            document.getElementById('appMotorSubType').focus();
            return;
        }

        const appliance = {
            name: document.getElementById('appName').value.trim(),
            quantity: parseInt(document.getElementById('appQuantity').value) || 1,
            ratedPowerW: parseFloat(document.getElementById('appPower').value) || 0,
            dailyUsageHours: parseFloat(document.getElementById('appHours').value) || 1,
            dutyCycle: parseFloat(document.getElementById('appDutyCycle').value) || 100,
            loadType: loadType,
            startMethod: document.getElementById('appStartMethod').value,
            surgeFactor: parseFloat(document.getElementById('appSurgeFactor').value) || 1,
            powerFactor: parseFloat(document.getElementById('appPowerFactor').value) || 1,
            daytimeRatio: parseFloat(document.getElementById('appDaytimeRatio').value) || 50,
            isSimultaneous: document.getElementById('appSimultaneous').checked,
            isAC: true,
            efficiency: 1.0,
            motorSubType: loadType === 'motor' ? motorSubType : null
        };

        // Set motor efficiency from sub-type (precise) or fallback
        if (appliance.loadType === 'motor') {
            const subTypeSpecs = DEFAULTS.MOTOR_SUBTYPES[motorSubType];
            appliance.efficiency = subTypeSpecs ? subTypeSpecs.efficiency : 0.85;

            // Flag industrial sewing machines (>400W clutch = industrial tailoring)
            const nameLower = appliance.name.toLowerCase();
            if (/sew/.test(nameLower)) {
                appliance.isSewingMachine = true;
                appliance.isIndustrialSewing = appliance.ratedPowerW > 400;
                appliance.sewingType = appliance.ratedPowerW > 400 ? 'industrial' : 'domestic';
            }
        }

        // Validate
        const errors = LoadEngine.validateAppliance(appliance);
        if (errors.length > 0) {
            alert('Validation errors:\n' + errors.join('\n'));
            return;
        }

        // Check if we're editing or adding new
        if (this.editingIndex !== null) {
            // Update existing appliance
            LoadEngine.appliances[this.editingIndex] = appliance;
            this.editingIndex = null;  // Reset editing state
        } else {
            // Add new appliance
            LoadEngine.appliances.push(appliance);
        }

        this.renderApplianceList();
        this.clearApplianceForm();
        this.saveToLocalStorageAuto();  // Auto-save
    },

    /**
     * Remove appliance from list
     */
    removeAppliance(index) {
        LoadEngine.appliances.splice(index, 1);
        this.renderApplianceList();
    },

    /**
     * Render the appliance list table
     */
    renderApplianceList() {
        const container = document.getElementById('applianceListContainer');

        if (LoadEngine.appliances.length === 0) {
            container.innerHTML = '<p class="text-muted">No appliances added yet.</p>';
            return;
        }

        let totalPower = 0;
        let totalEnergy = 0;

        let html = `
            <table class="appliance-table">
                <thead>
                    <tr>
                        <th>Appliance</th>
                        <th>Qty</th>
                        <th>Power (W)</th>
                        <th>Hours</th>
                        <th>Energy (Wh)</th>
                        <th>Type</th>
                        <th>Simul.</th>
                        <th class="no-print">Actions</th>
                    </tr>
                </thead>
                <tbody>
        `;

        LoadEngine.appliances.forEach((app, index) => {
            const nameplatePower = app.ratedPowerW * app.quantity;
            const energy = LoadEngine.calculateDailyEnergyWh(app);
            totalPower += nameplatePower;
            totalEnergy += energy;

            html += `
                <tr>
                    <td>${app.name}</td>
                    <td>${app.quantity}</td>
                    <td>${Math.round(nameplatePower)}</td>
                    <td>${app.dailyUsageHours}</td>
                    <td>${Math.round(energy)}</td>
                    <td>${app.loadType}${app.motorSubType ? ' <small style="color:var(--primary-color);">(' + app.motorSubType + ')</small>' : ''}</td>
                    <td>${app.isSimultaneous ? 'Yes' : 'No'}</td>
                    <td class="actions no-print">
                        <button class="btn btn-small btn-primary" onclick="PVCalculator.editAppliance(${index})">Edit</button>
                        <button class="btn btn-small btn-secondary" onclick="PVCalculator.removeAppliance(${index})">Remove</button>
                    </td>
                </tr>
            `;
        });

        html += `
                </tbody>
                <tfoot>
                    <tr style="font-weight: bold; background: var(--bg-color);">
                        <td colspan="2">TOTAL</td>
                        <td>${Math.round(totalPower)} W</td>
                        <td></td>
                        <td>${Math.round(totalEnergy)} Wh</td>
                        <td colspan="3"></td>
                    </tr>
                </tfoot>
            </table>
        `;

        container.innerHTML = html;
    },

    /**
     * Clear the appliance input form
     */
    clearApplianceForm() {
        document.getElementById('appName').value = '';
        document.getElementById('appQuantity').value = '1';
        document.getElementById('appPower').value = '';
        document.getElementById('appHours').value = '8';
        document.getElementById('appDutyCycle').value = '100';
        document.getElementById('appLoadType').value = 'resistive';
        document.getElementById('appSurgeFactor').value = '1';
        document.getElementById('appPowerFactor').value = '1.0';
        document.getElementById('appDaytimeRatio').value = '50';
        document.getElementById('appSimultaneous').checked = true;
        document.getElementById('appMotorSubType').value = '';
        // Hide motor-specific fields
        document.getElementById('appMotorSubType').parentElement.style.display = 'none';
        document.getElementById('appStartMethod').parentElement.style.display = 'none';
        // Clear auto-detect hint
        const hintDiv = document.getElementById('appAutoHint');
        if (hintDiv) hintDiv.style.display = 'none';
        const subTypeHint = document.getElementById('motorSubTypeHint');
        if (subTypeHint) subTypeHint.innerHTML = 'Required for motors. Clutch vs Servo directly affects sizing.';
        // Reset button back to "Add"
        this.editingIndex = null;
        const btn = document.getElementById('addApplianceBtn');
        if (btn) {
            btn.textContent = 'Add Appliance';
            btn.style.background = '';
        }
    },

    /**
     * Auto-save to localStorage (silent)
     */
    saveToLocalStorageAuto() {
        try {
            const data = {
                appliances: LoadEngine.appliances,
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('pvCalculatorAutoSave', JSON.stringify(data));
        } catch (e) {
            // Silent fail for auto-save
        }
    },

    /**
     * Check for auto-saved data on load
     */
    checkAutoSave() {
        const saved = localStorage.getItem('pvCalculatorAutoSave');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (data.appliances && data.appliances.length > 0) {
                    const savedTime = new Date(data.savedAt).toLocaleString();
                    if (confirm(`Found auto-saved data from ${savedTime} with ${data.appliances.length} appliances. Load it?`)) {
                        LoadEngine.appliances = data.appliances;
                        this.renderApplianceList();
                    }
                }
            } catch (e) {
                // Ignore errors
            }
        }
    },

    /**
     * Load sample appliances for testing
     */
    loadSampleAppliances() {
        const samples = [
            { name: 'LED Lights', quantity: 10, ratedPowerW: 12, dailyUsageHours: 6, dutyCycle: 100, loadType: 'electronic', surgeFactor: 1.2, powerFactor: 0.95, daytimeRatio: 20, isSimultaneous: true, isAC: true, efficiency: 1.0 },
            { name: 'Ceiling Fan', quantity: 3, ratedPowerW: 75, dailyUsageHours: 8, dutyCycle: 100, loadType: 'motor', startMethod: 'dol', surgeFactor: 3, powerFactor: 0.65, daytimeRatio: 50, isSimultaneous: true, isAC: true, efficiency: 0.85, motorSubType: 'fan' },
            { name: 'Refrigerator', quantity: 1, ratedPowerW: 150, dailyUsageHours: 24, dutyCycle: 40, loadType: 'motor', startMethod: 'dol', surgeFactor: 5, powerFactor: 0.65, daytimeRatio: 50, isSimultaneous: true, isAC: true, efficiency: 0.85, motorSubType: 'compressor' },
            { name: 'TV (LED)', quantity: 1, ratedPowerW: 100, dailyUsageHours: 5, dutyCycle: 100, loadType: 'electronic', surgeFactor: 1.2, powerFactor: 0.95, daytimeRatio: 30, isSimultaneous: true, isAC: true, efficiency: 1.0 },
            { name: 'Laptop Charger', quantity: 2, ratedPowerW: 65, dailyUsageHours: 4, dutyCycle: 100, loadType: 'electronic', surgeFactor: 1.2, powerFactor: 0.95, daytimeRatio: 50, isSimultaneous: true, isAC: true, efficiency: 1.0 },
            { name: 'Water Pump', quantity: 1, ratedPowerW: 750, dailyUsageHours: 1, dutyCycle: 100, loadType: 'motor', startMethod: 'dol', surgeFactor: 5, powerFactor: 0.70, daytimeRatio: 80, isSimultaneous: false, isAC: true, efficiency: 0.80, motorSubType: 'pump' },
            { name: 'Phone Chargers', quantity: 4, ratedPowerW: 20, dailyUsageHours: 3, dutyCycle: 100, loadType: 'electronic', surgeFactor: 1, powerFactor: 0.95, daytimeRatio: 50, isSimultaneous: true, isAC: true, efficiency: 1.0 }
        ];

        LoadEngine.appliances = samples;
        this.renderApplianceList();
    },

    /**
     * Get configuration from form
     */
    getConfig() {
        return {
            location: document.getElementById('location').value,
            systemType: document.getElementById('systemType').value,
            acVoltage: parseFloat(document.getElementById('acVoltage').value) || 230,
            avgPSH: parseFloat(document.getElementById('avgPSH').value) || 4.5,
            autonomyDays: parseFloat(document.getElementById('autonomyDays').value) || 2,
            ambientTempMin: parseFloat(document.getElementById('ambientTempMin').value) || 20,
            ambientTempMax: parseFloat(document.getElementById('ambientTempMax').value) || 35,
            designMargin: parseFloat(document.getElementById('designMargin').value) || 125,
            inverterSurgeMultiplier: parseFloat(document.getElementById('inverterSurgeMultiplier').value) || 2.0
        };
    },

    /**
     * Get panel specifications from form
     */
    getPanel() {
        return {
            wattage: parseFloat(document.getElementById('panelWattage').value) || 400,
            vmp: parseFloat(document.getElementById('panelVmp').value) || 41,
            voc: parseFloat(document.getElementById('panelVoc').value) || 49,
            imp: parseFloat(document.getElementById('panelImp').value) || 9.76,
            isc: parseFloat(document.getElementById('panelIsc').value) || 10.36,
            tempCoeffPmax: parseFloat(document.getElementById('panelTempCoeffPmax').value) || -0.35,
            tempCoeffVoc: parseFloat(document.getElementById('panelTempCoeffVoc').value) || -0.27
        };
    },

    /**
     * Get MPPT specifications from form
     */
    getMPPT() {
        const inputCount = parseInt(document.getElementById('mpptInputCount').value) || 1;

        // Primary MPPT (always present)
        const primary = {
            maxVoltage: parseFloat(document.getElementById('mpptMaxVoltage').value) || 500,
            minVoltage: parseFloat(document.getElementById('mpptMinVoltage').value) || 95,
            maxOperatingVoltage: parseFloat(document.getElementById('mpptMaxOperatingVoltage').value) || 450,
            maxCurrent: parseFloat(document.getElementById('mpptMaxCurrent').value) || 27,
            maxPower: parseFloat(document.getElementById('mpptMaxPower').value) || 7500,
            maxChargeCurrent: parseFloat(document.getElementById('mpptMaxChargeCurrent').value) || 120,
            inputCount: inputCount,
            label: 'MPPT 1'
        };

        // Build array of all MPPTs
        const allMPPTs = [primary];

        if (inputCount >= 2) {
            allMPPTs.push({
                maxVoltage: parseFloat(document.getElementById('mppt2MaxVoltage').value) || 500,
                minVoltage: parseFloat(document.getElementById('mppt2MinVoltage').value) || 60,
                maxOperatingVoltage: parseFloat(document.getElementById('mppt2MaxOperatingVoltage').value) || 450,
                maxCurrent: parseFloat(document.getElementById('mppt2MaxCurrent').value) || 18,
                maxPower: parseFloat(document.getElementById('mppt2MaxPower').value) || 3000,
                maxChargeCurrent: parseFloat(document.getElementById('mppt2MaxChargeCurrent').value) || 60,
                label: 'MPPT 2'
            });
        }

        if (inputCount >= 3) {
            allMPPTs.push({
                maxVoltage: parseFloat(document.getElementById('mppt3MaxVoltage').value) || 500,
                minVoltage: parseFloat(document.getElementById('mppt3MinVoltage').value) || 60,
                maxOperatingVoltage: parseFloat(document.getElementById('mppt3MaxOperatingVoltage').value) || 450,
                maxCurrent: parseFloat(document.getElementById('mppt3MaxCurrent').value) || 18,
                maxPower: parseFloat(document.getElementById('mppt3MaxPower').value) || 3000,
                maxChargeCurrent: parseFloat(document.getElementById('mppt3MaxChargeCurrent').value) || 60,
                label: 'MPPT 3'
            });
        }

        // Attach the full array to the primary for backward compatibility
        // All existing code uses mppt.maxVoltage etc (primary specs)
        // Multi-MPPT aware code uses mppt.allMPPTs[]
        primary.allMPPTs = allMPPTs;
        primary.totalMaxPower = allMPPTs.reduce((sum, m) => sum + m.maxPower, 0);
        primary.totalMaxCurrent = allMPPTs.reduce((sum, m) => sum + m.maxCurrent, 0);

        return primary;
    },

    /**
     * Get cable lengths from form
     */
    getCableLengths() {
        return {
            pvToMPPT: parseFloat(document.getElementById('cablePVtoMPPT').value) || 10,
            mpptToBatt: parseFloat(document.getElementById('cableMPPTtoBatt').value) || 2,
            battToInv: parseFloat(document.getElementById('cableBattToInv').value) || 1.5,
            invToLoad: parseFloat(document.getElementById('cableInvToLoad').value) || 10
        };
    },

    /**
     * Main calculation function
     */
    calculate() {
        if (LoadEngine.appliances.length === 0) {
            alert('Please add at least one appliance before calculating.');
            return;
        }

        try {
            const config = this.getConfig();
            const panel = this.getPanel();
            const mppt = this.getMPPT();
            const cableLengths = this.getCableLengths();
            const batteryChemistry = document.getElementById('batteryChemistry').value;
            const isManualMode = document.getElementById('manualMode').checked;
            const isExpertMode = isManualMode && (document.getElementById('expertMode')?.checked || false);

            // Validate panel specs first
            const panelCheck = this.validatePanelSpecs();
            if (!panelCheck.valid) {
                if (!confirm('Panel specifications have errors:\n' + (panelCheck.errors || []).join('\n') + '\n\nContinue anyway?')) {
                    return;
                }
            }

            // Phase 2: Aggregation
            const aggregation = AggregationEngine.calculate(LoadEngine.appliances, config);

            // Phase 3: Inverter Sizing (auto or manual)
            let inverter = InverterSizingEngine.calculate(aggregation, config);

            // Apply stagger preference if user opted in
            // Activate when: stagger gives a smaller inverter OR meaningfully less surge (>5%)
            if (this._staggerMotorStarts && inverter.motorCount >= 2 &&
                (inverter.staggeredSizeVA < inverter.recommendedSizeVA ||
                 inverter.staggeredSurgeVA < inverter.surgeVARequired * 0.95)) {
                inverter.isStaggerMode = true;
                inverter.safeRecommendedSizeVA = inverter.recommendedSizeVA;
                // Use the smaller inverter if staggering makes it possible
                if (inverter.staggeredSizeVA < inverter.recommendedSizeVA) {
                    inverter.recommendedSizeVA = inverter.staggeredSizeVA;
                }
                // Recalculate DC currents using staggered surge
                const dcV = inverter.dcBusVoltage;
                inverter.dcInputCurrentContinuous = Math.round(inverter.continuousVARequired / dcV * 10) / 10;
                inverter.dcInputCurrentSurge = Math.round(inverter.staggeredSurgeVA / dcV * 10) / 10;
            }

            // Auto-suggest MPPT specs based on inverter size (auto mode only)
            if (!isManualMode) {
                this.autoSuggestMPPTSpecs(inverter.recommendedSizeVA);
            }

            // Apply manual inverter overrides if set
            if (isManualMode) {
                const manualVA = parseFloat(document.getElementById('inverterManualVA').value);
                const manualVoltage = document.getElementById('inverterManualVoltage').value;

                if (manualVA > 0) {
                    const autoSize = inverter.recommendedSizeVA;
                    inverter.recommendedSizeVA = manualVA;
                    inverter.isManualOverride = true;
                    inverter.autoSuggestedSizeVA = autoSize;

                    // Warn if undersized
                    if (manualVA < inverter.continuousVARequired) {
                        if (isExpertMode) {
                            // Expert mode: convert hard block to warning
                            inverter.warnings.push(
                                `EXPERT OVERRIDE: Your ${manualVA}VA inverter is undersized. Continuous load requires ${Math.round(inverter.continuousVARequired)}VA minimum. Hard block suppressed — proceed with caution.`
                            );
                        } else {
                            inverter.blocks.push(
                                `HARD BLOCK: Your ${manualVA}VA inverter is undersized. Continuous load requires ${Math.round(inverter.continuousVARequired)}VA minimum.`
                            );
                        }
                        inverter.suggestions.push(
                            `Auto-suggested size: ${autoSize}VA. Upgrade to at least ${autoSize}VA.`
                        );
                    } else if (manualVA < autoSize) {
                        inverter.warnings.push(
                            `Your ${manualVA}VA inverter is smaller than recommended ${autoSize}VA. It may handle the load but with less headroom.`
                        );
                    }

                    // Check surge capability of manual inverter
                    const surgeCap = manualVA * config.inverterSurgeMultiplier;
                    if (inverter.surgeVARequired > surgeCap) {
                        inverter.warnings.push(
                            `Surge warning: Your ${manualVA}VA inverter has ${Math.round(surgeCap)}VA surge capacity (${config.inverterSurgeMultiplier}x). Motor starting requires ${Math.round(inverter.surgeVARequired)}VA. Consider soft-start on motors.`
                        );
                    }
                }

                if (manualVoltage !== 'auto') {
                    const manualV = parseInt(manualVoltage);
                    inverter.dcBusVoltage = manualV;

                    // REALISTIC VOLTAGE/SIZE VALIDATION
                    const sizeVA = inverter.recommendedSizeVA;
                    if (manualV === 12 && sizeVA > 1500) {
                        inverter.warnings.push(
                            `WARNING: 12V DC bus with ${sizeVA}VA inverter is unrealistic. 12V systems are practical up to ~1500VA. DC currents would be ${Math.round(sizeVA/12)}A which requires extremely thick cables and is dangerous.`
                        );
                    } else if (manualV === 24 && sizeVA > 3500) {
                        inverter.warnings.push(
                            `WARNING: 24V DC bus with ${sizeVA}VA inverter is impractical. 24V systems are typically limited to ~3000-3500VA. DC current would be ${Math.round(sizeVA/24)}A. Recommend 48V for this load.`
                        );
                    }

                    // Recalculate DC currents with new voltage
                    inverter.dcInputCurrentContinuous = Math.round(inverter.continuousVARequired / manualV * 10) / 10;
                    inverter.dcInputCurrentSurge = Math.round(inverter.surgeVARequired / manualV * 10) / 10;
                }
            }

            // Also validate auto-selected voltage/size combos
            if (!isManualMode) {
                const v = inverter.dcBusVoltage;
                const s = inverter.recommendedSizeVA;
                if (v === 12 && s > 1500) {
                    inverter.warnings.push(
                        `12V bus selected for ${s}VA. DC current (${Math.round(s/12)}A) is very high. Consider 24V or 48V bus.`
                    );
                } else if (v === 24 && s > 3500) {
                    inverter.warnings.push(
                        `24V bus with ${s}VA system. DC current (${Math.round(s/24)}A) is high. 48V recommended.`
                    );
                }
            }

            // Phase 4: Battery Sizing (auto or manual)
            let battery = BatterySizingEngine.calculate(aggregation, inverter, config, batteryChemistry);

            // Apply optional battery unit count override (works in both auto and manual)
            const userBatteryUnitCount = parseInt(document.getElementById('batteryUnitCount').value);
            if (userBatteryUnitCount > 0) {
                const unitAh = battery.recommendedAhPerCell;
                const unitV = DEFAULTS.BATTERY_SPECS[batteryChemistry].cellVoltage;
                const cellsPerUnit = Math.round(battery.bankVoltage / unitV);
                const autoStrings = battery.stringsInParallel;

                battery.stringsInParallel = userBatteryUnitCount;
                battery.totalCapacityAh = Math.round(userBatteryUnitCount * unitAh * 10) / 10;
                battery.totalCapacityWh = Math.round(battery.totalCapacityAh * battery.bankVoltage * 10) / 10;
                battery.totalCells = cellsPerUnit * userBatteryUnitCount;

                const specs = DEFAULTS.BATTERY_SPECS[batteryChemistry];
                battery.usableCapacityWh = Math.round(battery.totalCapacityWh * specs.maxDoD * 10) / 10;
                battery.maxDischargeCurrent = Math.round(battery.totalCapacityAh * specs.maxDischargeRate * 10) / 10;
                battery.maxChargeCurrent = Math.round(battery.totalCapacityAh * specs.maxChargeRate * 10) / 10;

                battery.isUnitCountOverride = true;
                battery.autoSuggestedStrings = autoStrings;

                // Warn if undersized
                if (userBatteryUnitCount < autoStrings) {
                    battery.warnings.push(
                        `You selected ${userBatteryUnitCount} battery unit(s) (${battery.totalCapacityAh}Ah). Auto-suggested: ${autoStrings} units (${autoStrings * unitAh}Ah). Autonomy and cycle life may be reduced.`
                    );
                }

                // Update the note
                const noteEl = document.getElementById('batteryUnitCountNote');
                if (noteEl) {
                    noteEl.innerHTML = `<strong>${userBatteryUnitCount}x ${unitAh}Ah</strong> = ${battery.totalCapacityAh}Ah total (${battery.totalCapacityWh}Wh). `
                        + `Auto would use ${autoStrings} unit(s).`;
                }
            } else {
                const noteEl = document.getElementById('batteryUnitCountNote');
                if (noteEl) noteEl.innerHTML = '';
            }

            // Apply manual battery overrides if set
            if (isManualMode) {
                const manualAh = parseFloat(document.getElementById('batteryManualAh').value);
                const manualBattV = document.getElementById('batteryManualVoltage').value;

                if (manualAh > 0) {
                    const autoAh = battery.totalCapacityAh;
                    battery.isManualOverride = true;
                    battery.autoSuggestedAh = autoAh;
                    battery.totalCapacityAh = manualAh;
                    battery.totalCapacityWh = Math.round(manualAh * battery.bankVoltage * 10) / 10;

                    const specs = DEFAULTS.BATTERY_SPECS[batteryChemistry];
                    battery.maxDischargeCurrent = Math.round(manualAh * specs.maxDischargeRate * 10) / 10;
                    battery.maxChargeCurrent = Math.round(manualAh * specs.maxChargeRate * 10) / 10;

                    // Warn if undersized
                    if (manualAh < autoAh * 0.8) {
                        battery.warnings.push(
                            `Your ${manualAh}Ah battery is smaller than recommended ${autoAh}Ah. Autonomy and cycle life may be reduced.`
                        );
                    }
                }

                if (manualBattV !== 'auto') {
                    battery.bankVoltage = parseInt(manualBattV);
                }
            }

            // Phase 5: PV Array (auto calculation)
            let pvArray = PVArrayEngine.calculate(aggregation, battery, config, panel, mppt);

            // Manual PV override (if manual mode + fields filled)
            let configComparison = null;
            if (isManualMode) {
                const manualCount = parseInt(document.getElementById('pvManualCount').value);
                const manualSeries = parseInt(document.getElementById('pvManualSeries').value);
                const manualParallel = parseInt(document.getElementById('pvManualParallel').value);

                if (manualCount > 0 && manualSeries > 0 && manualParallel > 0) {
                    // Validate user's configuration
                    const userConfig = ConfigurationComparisonEngine.validateUserConfig(
                        manualSeries, manualParallel, manualCount, panel, mppt, config
                    );

                    // Generate comparison with alternatives
                    configComparison = ConfigurationComparisonEngine.compare(manualCount, panel, mppt, config);
                    configComparison.userConfig = userConfig;

                    // Override PV array with user's config values
                    const autoPV = { ...pvArray };
                    pvArray.isManualOverride = true;
                    pvArray.autoSuggested = {
                        panelsInSeries: autoPV.panelsInSeries,
                        stringsInParallel: autoPV.stringsInParallel,
                        totalPanels: autoPV.totalPanels,
                        arrayWattage: autoPV.arrayWattage
                    };
                    pvArray.panelsInSeries = manualSeries;
                    pvArray.stringsInParallel = manualParallel;
                    pvArray.totalPanels = manualSeries * manualParallel;
                    pvArray.arrayWattage = pvArray.totalPanels * panel.wattage;
                    pvArray.stringVmp = Math.round(manualSeries * panel.vmp * 100) / 100;
                    pvArray.stringVoc = Math.round(manualSeries * panel.voc * 100) / 100;

                    const tempDeltaCold = config.ambientTempMin - DEFAULTS.STC_TEMP;
                    const vocTempFactor = 1 + (panel.tempCoeffVoc / 100 * tempDeltaCold);
                    pvArray.stringVocCold = Math.round(manualSeries * panel.voc * vocTempFactor * 100) / 100;
                    pvArray.arrayImp = Math.round(manualParallel * panel.imp * 100) / 100;
                    pvArray.arrayIsc = Math.round(manualParallel * panel.isc * 100) / 100;

                    // Replace auto blocks/warnings/suggestions with user config's own validation
                    // Auto-calc blocks are stale (computed for auto series/parallel, not user's override)
                    pvArray.blocks = userConfig.blocks || [];
                    pvArray.warnings = userConfig.warnings || [];
                    pvArray.suggestions = userConfig.suggestions || [];
                }
            }

            // Check if user specified a desired panel count (works in both modes)
            const desiredCount = parseInt(document.getElementById('pvDesiredCount').value);
            if (!configComparison && desiredCount > 0) {
                // User specified panel count in auto mode — recalculate PV array with that count
                configComparison = ConfigurationComparisonEngine.compare(desiredCount, panel, mppt, config);

                // If there's a recommended valid config, use it for the PV array
                const recIdx = configComparison.recommended;
                if (recIdx >= 0 && configComparison.configurations[recIdx]) {
                    const rec = configComparison.configurations[recIdx];
                    pvArray.panelsInSeries = rec.series;
                    pvArray.stringsInParallel = rec.parallel;
                    pvArray.totalPanels = rec.totalPanels;
                    pvArray.arrayWattage = rec.totalPower;
                    pvArray.stringVmp = rec.stringVmp;
                    pvArray.stringVoc = rec.stringVoc;
                    pvArray.stringVocCold = rec.stringVocCold;
                    pvArray.arrayImp = rec.arrayImp;
                    pvArray.arrayIsc = rec.arrayIsc;
                    pvArray.userSpecifiedCount = desiredCount;
                }
            }

            // Auto mode: also generate configuration comparison
            if (!configComparison) {
                configComparison = ConfigurationComparisonEngine.compare(pvArray.totalPanels, panel, mppt, config);

                // Sync pvArray with the recommended valid config so all tabs are consistent
                const recIdx = configComparison.recommended;
                if (recIdx >= 0 && configComparison.configurations[recIdx]) {
                    const rec = configComparison.configurations[recIdx];
                    if (rec.series !== pvArray.panelsInSeries || rec.parallel !== pvArray.stringsInParallel) {
                        pvArray.autoOriginal = {
                            panelsInSeries: pvArray.panelsInSeries,
                            stringsInParallel: pvArray.stringsInParallel,
                            totalPanels: pvArray.totalPanels,
                            arrayWattage: pvArray.arrayWattage
                        };
                        pvArray.panelsInSeries = rec.series;
                        pvArray.stringsInParallel = rec.parallel;
                        pvArray.totalPanels = rec.totalPanels;
                        pvArray.arrayWattage = rec.totalPower;
                        pvArray.stringVmp = rec.stringVmp;
                        pvArray.stringVoc = rec.stringVoc;
                        pvArray.stringVocCold = rec.stringVocCold;
                        pvArray.arrayImp = rec.arrayImp;
                        pvArray.arrayIsc = rec.arrayIsc;
                    }
                }
            }

            // Multi-MPPT Distribution (when more than 1 MPPT input)
            let multiMPPTResult = null;
            if (mppt.inputCount > 1) {
                const panelCountForDistribution = desiredCount > 0 ? desiredCount : pvArray.totalPanels;
                multiMPPTResult = MultiMPPTDistributor.distribute(panelCountForDistribution, panel, mppt, config);

                // If multi-MPPT found a valid distribution, update PV array to use it
                if (multiMPPTResult && multiMPPTResult.recommended >= 0) {
                    const bestDist = multiMPPTResult.distributions[multiMPPTResult.recommended];
                    pvArray.multiMPPT = bestDist;
                    pvArray.totalPanels = bestDist.totalActualPanels;
                    pvArray.arrayWattage = bestDist.totalActualPanels * panel.wattage;

                    // Use the first MPPT's config for primary electrical values (for cable/protection sizing)
                    const primaryAssignment = bestDist.mpptAssignments.find(a => !a.unused);
                    if (primaryAssignment && primaryAssignment.config) {
                        pvArray.panelsInSeries = primaryAssignment.config.series;
                        pvArray.stringsInParallel = primaryAssignment.config.parallel;
                        pvArray.stringVmp = primaryAssignment.config.stringVmp;
                        pvArray.stringVocCold = primaryAssignment.config.stringVocCold;
                        pvArray.arrayIsc = primaryAssignment.config.arrayIscTol;
                    }

                    // Calculate combined Isc for cable/protection sizing (sum of all MPPT currents)
                    pvArray.combinedArrayIsc = bestDist.mpptAssignments
                        .filter(a => !a.unused && a.config)
                        .reduce((sum, a) => sum + a.config.arrayIscTol, 0);
                }
            }

            // Phase 6: MPPT Validation (uses final PV config)
            const mpptValidation = ChargeControllerValidator.validate(pvArray, mppt);

            // Phase 7: Cable Sizing
            const cables = CableSizingEngine.calculate(inverter, battery, pvArray, config, cableLengths, panel, mppt);

            // Phase 8: Protection (with manual breaker support)
            const manualBreakers = {
                pvDC: parseFloat(document.getElementById('breakerPVDC').value) || 0,
                battDC: parseFloat(document.getElementById('breakerBattDC').value) || 0,
                ac: parseFloat(document.getElementById('breakerAC').value) || 0
            };
            const protection = ProtectionEngine.design(inverter, battery, pvArray, config, manualBreakers);

            // Phase 9: System Losses
            const losses = SystemLossEngine.calculate(aggregation, battery, pvArray, cables, config);

            // Panel mismatch analysis (if enabled)
            let mismatchData = null;
            if (document.getElementById('pvMismatchEnabled').value === 'yes') {
                mismatchData = this.analyzePanelMismatch();
            }

            // Smart Advisory
            const advisories = SmartAdvisoryEngine.generate({
                config, aggregation, inverter, battery, pvArray, mpptValidation, cables, protection, losses, mismatchData
            });

            // Phase 10: Upgrade Path Analysis
            const upgradePaths = UpgradeSimulator.analyzeUpgradePaths(
                { aggregation, inverter, battery, pvArray, cables, protection, losses },
                panel, mppt, config
            );

            // Store results
            this.results = {
                config,
                aggregation,
                inverter,
                battery,
                pvArray,
                mpptValidation,
                cables,
                protection,
                losses,
                configComparison,
                advisories,
                manualBreakers,
                multiMPPTResult,
                upgradePaths
            };

            // Phase 11 & 12: Generate output and check for blocks
            const report = OutputGenerator.generateReport(this.results);
            const defense = DefenseNotes.checkForBlocks(this.results);

            // Render results
            this.renderResults(report, defense);

        } catch (error) {
            console.error('Calculation error:', error);
            alert('Calculation error: ' + error.message);
        }
    },

    /**
     * Render calculation results
     */
    renderResults(report, defense) {
        const container = document.getElementById('resultsContainer');

        let html = '';

        // HARD BLOCKS - Show prominently at top
        if (defense.hasBlocks) {
            html += `
                <div class="card">
                    <h2 style="color: var(--error-color);">SYSTEM DESIGN BLOCKED</h2>
                    ${defense.blocks.map(block => `
                        <div class="alert alert-error">
                            <span class="alert-icon">&#9888;</span>
                            <div class="alert-content">
                                <div class="alert-title">Hard Block</div>
                                <p>${block}</p>
                            </div>
                        </div>
                    `).join('')}
                    ${defense.suggestions.length > 0 ? `
                        <h3>Suggested Solutions</h3>
                        ${defense.suggestions.map(sug => `
                            <div class="alert alert-info">
                                <span class="alert-icon">&#128161;</span>
                                <div class="alert-content">${sug}</div>
                            </div>
                        `).join('')}
                    ` : ''}
                </div>
            `;
        }

        // SUMMARY
        const inv = report.details.inverter;
        const batt = report.details.battery;
        const agg = report.details.aggregation;
        const hasManual = inv.isManualOverride || batt.isManualOverride;

        // Calculate Coping Score when undersized equipment detected
        let copingScoreHtml = '';
        if (hasManual) {
            const invUsableW = (inv.recommendedSizeVA || 0) * DEFAULTS.INVERTER_DERATING;
            const contNeeded = agg.designContinuousVA || agg.peakSimultaneousVA || 0;
            const invRatio = contNeeded > 0 ? Math.min(invUsableW / contNeeded, 1.0) : 1.0;

            const surgeNeeded = agg.highestSurgeVA || agg.designSurgeVA || 0;
            const surgeCap = (inv.recommendedSizeVA || 0) * (report.details.config?.inverterSurgeMultiplier || 2.0);
            const surgeRatio = surgeNeeded > 0 ? Math.min(surgeCap / surgeNeeded, 1.0) : 1.0;

            const autoAh = batt.autoSuggestedAh || batt.totalCapacityAh;
            const battRatio = autoAh > 0 ? Math.min(batt.totalCapacityAh / autoAh, 1.0) : 1.0;

            // Weighted score: inverter continuous 40%, surge 25%, battery 35%
            const rawScore = (invRatio * 0.40 + surgeRatio * 0.25 + battRatio * 0.35) * 100;
            const copingScore = Math.round(rawScore);
            const isUndersize = copingScore < 95;

            if (isUndersize) {
                const scoreColor = copingScore >= 75 ? '#16a34a' : copingScore >= 50 ? '#d97706' : '#dc2626';
                const scoreLabel = copingScore >= 75 ? 'Manageable' : copingScore >= 50 ? 'Tight' : 'Critical';

                // Build tooltip quick-summary
                const invPct = Math.round(invRatio * 100);
                const surgePct = Math.round(surgeRatio * 100);
                const battPct = Math.round(battRatio * 100);
                const tooltipHtml = `
                    <div class="coping-tooltip">
                        <strong>Score Breakdown</strong><br>
                        Inverter capacity: ${invPct}% ${invPct < 100 ? '&#9888;' : '&#10003;'}<br>
                        Surge handling: ${surgePct}% ${surgePct < 100 ? '&#9888;' : '&#10003;'}<br>
                        Battery capacity: ${battPct}% ${battPct < 100 ? '&#9888;' : '&#10003;'}<br>
                        <span style="color: var(--text-muted); font-size: 0.7rem; margin-top: 4px; display: block;">Click for full breakdown &amp; safe combos</span>
                    </div>
                `;

                copingScoreHtml = `
                    <div class="summary-card coping-card" style="border: 2px solid ${scoreColor}; background: ${scoreColor}11;"
                         onclick="PVCalculator.openCopingModal()">
                        <div class="value" style="color: ${scoreColor}; font-size: 1.4rem;">${copingScore}%</div>
                        <div class="label" style="color: ${scoreColor}; font-weight: 600;">Coping: ${scoreLabel}</div>
                        <div style="font-size: 0.65rem; color: var(--text-muted); margin-top: 2px;">Click for details</div>
                        ${tooltipHtml}
                    </div>
                `;
            }
        }

        html += `
            <div class="card">
                <h2>System Summary${hasManual ? ' <span style="font-size: 0.75rem; color: var(--warning-color);">(Manual Override Active)</span>' : ''}</h2>
                <div class="summary-grid">
                    <div class="summary-card">
                        <div class="value">${Math.round(report.summary.totalDailyEnergy)}</div>
                        <div class="label">Daily Energy (Wh)</div>
                    </div>
                    <div class="summary-card">
                        <div class="value">${Math.round(report.summary.peakLoad)}</div>
                        <div class="label">Peak Load (VA)</div>
                    </div>
                    <div class="summary-card${inv.isManualOverride ? '" style="border: 2px solid var(--warning-color);"' : ''}">
                        <div class="value">${report.summary.inverterSize}</div>
                        <div class="label">Inverter (VA)${inv.isManualOverride ? ' &#128295;' : ''}</div>
                    </div>
                    <div class="summary-card${batt.isManualOverride ? '" style="border: 2px solid var(--warning-color);"' : ''}">
                        <div class="value">${Math.round(report.summary.batteryCapacity)}</div>
                        <div class="label">Battery (Ah)${batt.isManualOverride ? ' &#128295;' : ''}</div>
                    </div>
                    <div class="summary-card">
                        <div class="value">${Math.round(report.summary.pvArraySize)}</div>
                        <div class="label">PV Array (W)</div>
                    </div>
                    <div class="summary-card">
                        <div class="value">${report.summary.totalPanels}</div>
                        <div class="label">Solar Panels</div>
                    </div>
                    ${copingScoreHtml}
                </div>
            </div>
        `;

        // WARNINGS
        if (report.warnings.length > 0) {
            html += `
                <div class="card">
                    <h2>Warnings</h2>
                    ${report.warnings.map(warning => `
                        <div class="alert alert-warning">
                            <span class="alert-icon">&#9888;</span>
                            <div class="alert-content">${warning}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // DETAILED RESULTS WITH TABS
        html += `
            <div class="card">
                <h2>Detailed Results</h2>
                <div class="tabs" style="flex-wrap: wrap;">
                    <div class="tab active" onclick="PVCalculator.showTab('overview')">Overview</div>
                    <div class="tab" onclick="PVCalculator.showTab('load')">Load</div>
                    <div class="tab" onclick="PVCalculator.showTab('inverter')">Inverter</div>
                    <div class="tab" onclick="PVCalculator.showTab('battery')">Battery</div>
                    <div class="tab" onclick="PVCalculator.showTab('battconfig')">Batt Config</div>
                    <div class="tab" onclick="PVCalculator.showTab('pv')">PV Array</div>
                    <div class="tab" onclick="PVCalculator.showTab('pvconfig')">PV Config</div>
                    <div class="tab" onclick="PVCalculator.showTab('cables')">Cables</div>
                    <div class="tab" onclick="PVCalculator.showTab('protection')">Protection</div>
                    <div class="tab" onclick="PVCalculator.showTab('losses')">Losses</div>
                    <div class="tab" onclick="PVCalculator.showTab('upgrade')">Upgrade</div>
                    <div class="tab" onclick="PVCalculator.showTab('advisory')">Advisory</div>
                </div>

                <div id="tab-overview" class="tab-content active">
                    ${this.renderOverviewTab(report.details)}
                </div>
                <div id="tab-load" class="tab-content">
                    ${this.renderLoadTab(report.details.aggregation)}
                </div>
                <div id="tab-inverter" class="tab-content">
                    ${this.renderInverterTab(report.details.inverter)}
                </div>
                <div id="tab-battery" class="tab-content">
                    ${this.renderBatteryTab(report.details.battery)}
                </div>
                <div id="tab-battconfig" class="tab-content">
                    ${this.renderBatteryConfigTab(report.details.battery)}
                </div>
                <div id="tab-pv" class="tab-content">
                    ${this.renderPVTab(report.details.pvArray)}
                </div>
                <div id="tab-pvconfig" class="tab-content">
                    ${this.renderConfigTab(report.details.configComparison, this.getPanel(), report.details.multiMPPTResult)}
                </div>
                <div id="tab-cables" class="tab-content">
                    ${this.renderCablesTab(report.details.cables)}
                </div>
                <div id="tab-protection" class="tab-content">
                    ${this.renderProtectionTab(report.details.protection)}
                </div>
                <div id="tab-losses" class="tab-content">
                    ${this.renderLossesTab(report.details.losses)}
                </div>
                <div id="tab-upgrade" class="tab-content">
                    ${this.renderUpgradeTab(report.details.upgradePaths)}
                </div>
                <div id="tab-advisory" class="tab-content">
                    ${this.renderAdvisoryTab(report.details.advisories)}
                </div>
            </div>
        `;

        // RISK DISCLAIMER
        html += `
            <div class="card" style="border-left: 4px solid var(--warning-color); background: rgba(245,158,11,0.03);">
                <h3 style="color: var(--warning-color); margin-bottom: 8px;">Disclaimer &amp; Important Caveats</h3>
                <div style="font-size: 0.88rem; line-height: 1.6; color: var(--text-muted);">
                    <p style="margin-bottom: 8px;"><strong>Estimates Only:</strong> All values in this report are calculated estimates based on manufacturer specifications and standard engineering formulas. Real-world performance varies due to weather, shading, panel orientation, wiring quality, temperature extremes, and component aging.</p>
                    <p style="margin-bottom: 8px;"><strong>Not a Substitute for Professional Design:</strong> This tool assists with system sizing and component selection but does not replace a professional site survey, structural assessment, or electrical design by a certified solar installer. Local electrical codes, mounting requirements, and grid-tie regulations are not covered.</p>
                    <p style="margin-bottom: 8px;"><strong>Battery Performance:</strong> Battery capacity degrades over time. Actual usable capacity will be less than rated after 1-2 years. Temperature significantly affects battery life — hot climates accelerate degradation. Cycle life figures assume proper charge/discharge management.</p>
                    <p style="margin-bottom: 8px;"><strong>Solar Variability:</strong> Peak sun hours (PSH) are annual averages. Daily output varies by season, weather, and atmospheric conditions. Rainy season output can be 40-60% less than dry season. Plan for worst-case scenarios.</p>
                    <p style="margin: 0;"><strong>Safety:</strong> All electrical work must be performed by qualified personnel. Incorrect wiring, inadequate protection, or undersized components can cause fire, equipment damage, or electric shock. Always install appropriate breakers, fuses, and earthing as specified.</p>
                </div>
            </div>
        `;

        // EXPORT/PRINT BUTTONS
        html += `
            <div class="card no-print">
                <h2>Export</h2>
                <div style="margin-bottom: 12px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.9rem;">
                        <input type="checkbox" id="pdfIncludeDetails" checked style="width: 18px; height: 18px; cursor: pointer;">
                        <span><strong>Include detailed breakdown in PDF</strong> (load table, cables, protection, losses, inverter/battery/PV specs)</span>
                    </label>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="window.print()">Print Report</button>
                    <button class="btn btn-success" onclick="PVCalculator.exportPDF()">Export PDF</button>
                    <button class="btn btn-secondary" onclick="PVCalculator.exportJSON()">Export JSON</button>
                </div>
            </div>
        `;

        container.innerHTML = html;
    },

    /**
     * System Overview — comprehensive SVG + full spec sheets for every component
     */
    renderOverviewTab(details) {
        const config = this.getConfig();
        const pv = details.pvArray;
        const inv = details.inverter;
        const batt = details.battery;
        const cables = details.cables;
        const protection = details.protection;
        const losses = details.losses;
        const mppt = this.getMPPT();
        const panel = this.getPanel();
        const specs = DEFAULTS.BATTERY_SPECS[batt.chemistry] || DEFAULTS.BATTERY_SPECS.lifepo4;
        const isHybrid = config.systemType === 'hybrid' || config.systemType === 'grid_tie';

        // Get breaker ratings from protection data
        const pvBreaker = protection.pvSide?.find(d => d.name?.includes('Isolator') || d.name?.includes('DC'));
        const battBreaker = protection.batterySide?.find(d => d.name?.includes('MCCB') || d.name?.includes('Fuse') || d.name?.includes('DC'));
        const acBreaker = protection.acSide?.find(d => d.name?.includes('MCB') || d.name?.includes('AC'));
        const pvBreakerLabel = pvBreaker ? pvBreaker.rating : 'Auto';
        const battBreakerLabel = battBreaker ? battBreaker.rating : 'Auto';
        const acBreakerLabel = acBreaker ? acBreaker.rating : 'Auto';

        // Battery unit info (uses flexible voltage/Ah)
        const unitVoltage = this.getBatteryUnitVoltage();
        const formAh = this.getBatteryUnitAh(null);
        const selectedAh = this._selectedBatteryUnitAh || formAh || 200;
        const batteriesInSeries = Math.max(1, Math.round(batt.bankVoltage / unitVoltage));
        const parallelStrings = Math.ceil(batt.totalCapacityAh / selectedAh);
        const totalBatteries = batteriesInSeries * parallelStrings;

        // Cable info for wire labels
        const pvCable = cables?.dcRuns?.find(r => r.name?.includes('PV'));
        const battCable = cables?.dcRuns?.find(r => r.name?.includes('Batt') || r.name?.includes('MPPT'));
        const acCable = cables?.acRuns?.[0];
        const pvCableLabel = pvCable ? `${pvCable.marketMm2 || pvCable.recommendedMm2}mm\u00B2` : '';
        const battCableLabel = battCable ? `${battCable.marketMm2 || battCable.recommendedMm2}mm\u00B2` : '';
        const acCableLabel = acCable ? `${acCable.marketMm2 || acCable.recommendedMm2}mm\u00B2` : '';

        const surgeMultiplier = config.inverterSurgeMultiplier || 2.0;
        const surgeCap = Math.round(inv.recommendedSizeVA * surgeMultiplier);
        const actualBankAh = parallelStrings * selectedAh;

        // ===== FULL VISUAL SYSTEM OVERVIEW =====
        // Shows every panel and every battery individually, like PV Config & Batt Config tabs

        // Panel grid dimensions
        const panelW = 54, panelH = 32, panelGapX = 5, panelGapY = 10;
        const s = pv.panelsInSeries, p = pv.stringsInParallel;

        // Battery grid dimensions — compact when many parallel strings
        const battW = parallelStrings > 3 ? 55 : parallelStrings > 2 ? 62 : 70;
        const battH = parallelStrings > 3 ? 30 : parallelStrings > 2 ? 34 : 40;
        const battGapX = parallelStrings > 3 ? 8 : 12;
        const battGapY = parallelStrings > 3 ? 8 : parallelStrings > 2 ? 10 : 14;
        const battFontV = parallelStrings > 3 ? 7.5 : 9;
        const battFontAh = parallelStrings > 3 ? 7 : 8;
        const battTextYV = parallelStrings > 3 ? 13 : 16;
        const battTextYAh = parallelStrings > 3 ? 23 : 30;

        // Pre-calculate all column widths to determine total SVG width up front
        const pvGridW = s * (panelW + panelGapX);
        const battGridTotalWPre = batteriesInSeries * (battW + battGapX);
        const battGridActualW = batteriesInSeries * battW + Math.max(0, batteriesInSeries - 1) * battGapX;
        // Minimum box width ensures title/spec text never overflows (280px holds ~52 chars at font 8.5)
        const battBoxWPre = Math.max(battGridTotalWPre + 40, 280);
        const rightColWPre = 220; // widest right-side component
        const colGapPre = 30;
        const twoColW = battBoxWPre + colGapPre + rightColWPre + 60; // total with margins
        const W = Math.max(900, pvGridW + 120, twoColW);
        const cx = W / 2;
        const boxR = 8;

        let Y = 0;
        let svg = '';

        // ===== SECTION 1: PV ARRAY — Full Panel Grid =====
        const pvPadX = Math.max(30, (W - pvGridW) / 2);
        const pvGridH = p * (panelH + panelGapY);
        const pvSectionH = pvGridH + 80; // title + labels + grid
        Y = 42;
        const pvBoxX = pvPadX - 16, pvBoxW = pvGridW + 32;
        svg += `<rect x="${pvBoxX}" y="${Y}" width="${pvBoxW}" height="${pvSectionH}" rx="${boxR}" fill="#fef9c3" stroke="#ca8a04" stroke-width="2"/>`;
        svg += `<text x="${pvBoxX + pvBoxW/2}" y="${Y+16}" text-anchor="middle" font-size="12" font-weight="bold" fill="#92400e">PV Array \u2014 ${pv.totalPanels} x ${panel.wattage}Wp = ${pv.arrayWattage}Wp (${pv.panelsInSeries}S x ${pv.stringsInParallel}P)</text>`;

        // Draw every panel
        const pvGridStartY = Y + 26;
        for (let row = 0; row < p; row++) {
            for (let col = 0; col < s; col++) {
                const px = pvPadX + col * (panelW + panelGapX);
                const py = pvGridStartY + row * (panelH + panelGapY);
                svg += `<rect x="${px}" y="${py}" width="${panelW}" height="${panelH}" rx="3" fill="#fde68a" stroke="#a16207" stroke-width="1.2"/>`;
                // Cell lines for realism
                svg += `<line x1="${px + panelW/3}" y1="${py}" x2="${px + panelW/3}" y2="${py + panelH}" stroke="#a16207" stroke-width="0.3" opacity="0.4"/>`;
                svg += `<line x1="${px + 2*panelW/3}" y1="${py}" x2="${px + 2*panelW/3}" y2="${py + panelH}" stroke="#a16207" stroke-width="0.3" opacity="0.4"/>`;
                svg += `<text x="${px + panelW/2}" y="${py + panelH/2 + 4}" text-anchor="middle" font-size="8" fill="#78350f">${panel.wattage}W</text>`;
                // Series wires between panels in same row
                if (col < s - 1) {
                    svg += `<line x1="${px + panelW}" y1="${py + panelH/2}" x2="${px + panelW + panelGapX}" y2="${py + panelH/2}" stroke="#f59e0b" stroke-width="1.5"/>`;
                }
            }
            // String label
            svg += `<text x="${pvPadX + pvGridW + 4}" y="${pvGridStartY + row * (panelH + panelGapY) + panelH/2 + 3}" font-size="8" fill="#92400e">String ${row+1}</text>`;
            // Parallel lines between rows
            if (row < p - 1) {
                const lineY1 = pvGridStartY + row * (panelH + panelGapY) + panelH;
                const lineY2 = pvGridStartY + (row+1) * (panelH + panelGapY);
                svg += `<line x1="${pvPadX + 8}" y1="${lineY1}" x2="${pvPadX + 8}" y2="${lineY2}" stroke="#dc2626" stroke-width="1" stroke-dasharray="3"/>`;
                svg += `<line x1="${pvPadX + pvGridW - panelGapX - 8}" y1="${lineY1}" x2="${pvPadX + pvGridW - panelGapX - 8}" y2="${lineY2}" stroke="#2563eb" stroke-width="1" stroke-dasharray="3"/>`;
            }
        }
        // Voltage/current labels below panel grid
        const pvLabelY = pvGridStartY + pvGridH + 4;
        svg += `<text x="${pvBoxX + 8}" y="${pvLabelY + 10}" font-size="9" fill="#92400e">Vmp: ${pv.stringVmp}V | Voc: ${pv.stringVoc}V | Voc(cold): ${pv.stringVocCold}V</text>`;
        svg += `<text x="${pvBoxX + 8}" y="${pvLabelY + 24}" font-size="9" fill="#92400e">Imp: ${pv.arrayImp}A | Isc: ${pv.arrayIsc}A | Derated: ${pv.deratedOutput}W | Daily: ${pv.dailyEnergyWh}Wh</text>`;
        svg += `<text x="${pvBoxX + 8}" y="${pvLabelY + 38}" font-size="8" fill="#b45309">Panel: ${panel.vmp}V/${panel.voc}V/${panel.imp}A/${panel.isc}A | TempCoeff: ${panel.tempCoeffPmax}%/\u00B0C</text>`;

        Y += pvSectionH;

        // Wire: PV Array → PV DC Isolator
        svg += `<line x1="${cx}" y1="${Y}" x2="${cx}" y2="${Y+24}" stroke="#dc2626" stroke-width="2.5"/>`;
        if (pvCableLabel) svg += `<text x="${cx+10}" y="${Y+16}" font-size="8" fill="#dc2626">DC ${pvCableLabel}</text>`;
        Y += 24;

        // ===== PV DC BREAKER =====
        const brkW = 180, brkH = 40, brkX = cx - brkW/2;
        svg += `<rect x="${brkX}" y="${Y}" width="${brkW}" height="${brkH}" rx="4" fill="#fee2e2" stroke="#dc2626" stroke-width="1.5"/>`;
        svg += `<text x="${cx}" y="${Y+16}" text-anchor="middle" font-size="10" font-weight="bold" fill="#991b1b">PV DC Isolator</text>`;
        svg += `<text x="${cx}" y="${Y+30}" text-anchor="middle" font-size="9" fill="#b91c1c">${pvBreakerLabel}</text>`;
        Y += brkH;

        // Wire: Breaker → MPPT/Inverter
        svg += `<line x1="${cx}" y1="${Y}" x2="${cx}" y2="${Y+20}" stroke="#dc2626" stroke-width="2.5"/>`;
        Y += 20;

        if (isHybrid) {
            // ===== HYBRID INVERTER (MPPT inside) =====
            const hybW = Math.min(500, W - 60), hybH = 160, hybX = (W - hybW) / 2;
            svg += `<rect x="${hybX}" y="${Y}" width="${hybW}" height="${hybH}" rx="${boxR}" fill="#eff6ff" stroke="#2563eb" stroke-width="2.5"/>`;
            svg += `<text x="${cx}" y="${Y+17}" text-anchor="middle" font-size="12" font-weight="bold" fill="#1e40af">Hybrid Inverter \u2014 ${inv.recommendedSizeVA}VA</text>`;

            // MPPT sub-box (left)
            const mW = Math.floor(hybW/2 - 28), mH = 100, mX = hybX + 14, mY = Y + 28;
            svg += `<rect x="${mX}" y="${mY}" width="${mW}" height="${mH}" rx="6" fill="#dbeafe" stroke="#3b82f6" stroke-width="1.5" stroke-dasharray="4 2"/>`;
            svg += `<text x="${mX+mW/2}" y="${mY+15}" text-anchor="middle" font-size="10" font-weight="bold" fill="#1d4ed8">Built-in MPPT</text>`;
            svg += `<text x="${mX+mW/2}" y="${mY+29}" text-anchor="middle" font-size="9" fill="#2563eb">Max PV: ${mppt.maxPower}W</text>`;
            svg += `<text x="${mX+mW/2}" y="${mY+42}" text-anchor="middle" font-size="8.5" fill="#3b82f6">V: ${mppt.minVoltage}\u2013${mppt.maxOperatingVoltage}\u2013${mppt.maxVoltage}V</text>`;
            svg += `<text x="${mX+mW/2}" y="${mY+55}" text-anchor="middle" font-size="8.5" fill="#3b82f6">Imax: ${mppt.maxCurrent}A | Charge: ${mppt.maxChargeCurrent}A</text>`;
            svg += `<text x="${mX+mW/2}" y="${mY+68}" text-anchor="middle" font-size="8" fill="#60a5fa">${mppt.inputCount > 1 ? mppt.inputCount + ' MPPT inputs' : '1 MPPT input'}</text>`;
            svg += `<text x="${mX+mW/2}" y="${mY+82}" text-anchor="middle" font-size="7.5" fill="#93c5fd">Voc(cold) ${pv.stringVocCold}V ${pv.stringVocCold <= mppt.maxVoltage ? '\u2714' : '\u2718'} | Isc ${pv.arrayIsc}A ${pv.arrayIsc <= mppt.maxCurrent ? '\u2714' : '\u2718'}</text>`;

            // Inverter sub-box (right)
            const iW = mW, iX = hybX + hybW - 14 - iW, iY = mY;
            svg += `<rect x="${iX}" y="${iY}" width="${iW}" height="${mH}" rx="6" fill="#dbeafe" stroke="#3b82f6" stroke-width="1.5" stroke-dasharray="4 2"/>`;
            svg += `<text x="${iX+iW/2}" y="${iY+15}" text-anchor="middle" font-size="10" font-weight="bold" fill="#1d4ed8">DC \u2192 AC Inverter</text>`;
            svg += `<text x="${iX+iW/2}" y="${iY+29}" text-anchor="middle" font-size="9" fill="#2563eb">${inv.recommendedSizeVA} VA continuous</text>`;
            svg += `<text x="${iX+iW/2}" y="${iY+42}" text-anchor="middle" font-size="8.5" fill="#3b82f6">Surge: ${surgeCap}VA (${surgeMultiplier}x)</text>`;
            svg += `<text x="${iX+iW/2}" y="${iY+55}" text-anchor="middle" font-size="8.5" fill="#3b82f6">DC In: ${inv.dcInputCurrentContinuous}A / ${inv.dcInputCurrentSurge}A</text>`;
            svg += `<text x="${iX+iW/2}" y="${iY+68}" text-anchor="middle" font-size="8.5" fill="#3b82f6">${inv.dcBusVoltage}VDC \u2192 ${config.acVoltage}VAC</text>`;
            svg += `<text x="${iX+iW/2}" y="${iY+82}" text-anchor="middle" font-size="8" fill="#60a5fa">Pure Sine Wave</text>`;

            // Arrow MPPT → Inverter
            svg += `<line x1="${mX+mW}" y1="${mY+mH/2}" x2="${iX}" y2="${iY+mH/2}" stroke="#3b82f6" stroke-width="1.5"/>`;
            svg += `<polygon points="${iX-1},${iY+mH/2-4} ${iX-1},${iY+mH/2+4} ${iX+5},${iY+mH/2}" fill="#3b82f6"/>`;

            const hybBottom = Y + hybH;
            Y = hybBottom;

            // --- Pre-calculate column widths to prevent overlap ---
            // Position branches using pre-calculated widths (W already accounts for these)
            const totalColW_h = battBoxWPre + colGapPre + rightColWPre;
            const colStartX_h = (W - totalColW_h) / 2;
            const leftBranchX = colStartX_h + battBoxWPre / 2;
            const rightBranchX = colStartX_h + battBoxWPre + colGapPre + rightColWPre / 2;

            svg += `<line x1="${leftBranchX}" y1="${Y}" x2="${leftBranchX}" y2="${Y+22}" stroke="#dc2626" stroke-width="2.5"/>`;
            svg += `<line x1="${rightBranchX}" y1="${Y}" x2="${rightBranchX}" y2="${Y+22}" stroke="#7c3aed" stroke-width="2.5"/>`;
            if (battCableLabel) svg += `<text x="${leftBranchX-8}" y="${Y+14}" text-anchor="end" font-size="7.5" fill="#dc2626">DC ${battCableLabel}</text>`;
            if (acCableLabel) svg += `<text x="${rightBranchX+8}" y="${Y+14}" font-size="7.5" fill="#7c3aed">AC ${acCableLabel}</text>`;
            Y += 22;

            // Battery DC MCCB (left)
            const bbW = 140, bbH = 36;
            svg += `<rect x="${leftBranchX-bbW/2}" y="${Y}" width="${bbW}" height="${bbH}" rx="4" fill="#fee2e2" stroke="#dc2626" stroke-width="1.5"/>`;
            svg += `<text x="${leftBranchX}" y="${Y+14}" text-anchor="middle" font-size="9" font-weight="bold" fill="#991b1b">Battery DC MCCB</text>`;
            svg += `<text x="${leftBranchX}" y="${Y+28}" text-anchor="middle" font-size="8.5" fill="#b91c1c">${battBreakerLabel}</text>`;

            // AC MCB (right)
            svg += `<rect x="${rightBranchX-bbW/2}" y="${Y}" width="${bbW}" height="${bbH}" rx="4" fill="#f3e8ff" stroke="#7c3aed" stroke-width="1.5"/>`;
            svg += `<text x="${rightBranchX}" y="${Y+14}" text-anchor="middle" font-size="9" font-weight="bold" fill="#5b21b6">AC MCB</text>`;
            svg += `<text x="${rightBranchX}" y="${Y+28}" text-anchor="middle" font-size="8.5" fill="#7c3aed">${acBreakerLabel}</text>`;
            Y += bbH;

            // Wires down to battery bank and AC loads
            svg += `<line x1="${leftBranchX}" y1="${Y}" x2="${leftBranchX}" y2="${Y+18}" stroke="#dc2626" stroke-width="2.5"/>`;
            svg += `<line x1="${rightBranchX}" y1="${Y}" x2="${rightBranchX}" y2="${Y+18}" stroke="#7c3aed" stroke-width="2.5"/>`;
            Y += 18;

            // ===== BATTERY BANK — Full Grid (left) =====
            const battGridTotalH = parallelStrings * (battH + battGapY);
            const battBoxW = battBoxWPre, battBoxH = battGridTotalH + 72;
            const battBoxX = leftBranchX - battBoxW/2;
            const battClipId1 = 'battClip1';
            svg += `<defs><clipPath id="${battClipId1}"><rect x="${battBoxX}" y="${Y}" width="${battBoxW}" height="${battBoxH}" rx="${boxR}"/></clipPath></defs>`;
            svg += `<rect x="${battBoxX}" y="${Y}" width="${battBoxW}" height="${battBoxH}" rx="${boxR}" fill="#dcfce7" stroke="#16a34a" stroke-width="2"/>`;
            svg += `<g clip-path="url(#${battClipId1})">`;
            // Adaptive title font: smaller when box is narrow
            const battTitleFont = battBoxW < 300 ? 9 : 11;
            svg += `<text x="${leftBranchX}" y="${Y+15}" text-anchor="middle" font-size="${battTitleFont}" font-weight="bold" fill="#166534">Battery Bank \u2014 ${batt.chemistryName} | ${batt.bankVoltage}V / ${actualBankAh}Ah</text>`;

            // Draw every battery — centered within the (possibly wider) box
            const battPadX = Math.max(20, (battBoxW - battGridActualW) / 2);
            const battStartX = battBoxX + battPadX, battStartY = Y + 24;
            for (let bRow = 0; bRow < parallelStrings; bRow++) {
                for (let bCol = 0; bCol < batteriesInSeries; bCol++) {
                    const bx = battStartX + bCol * (battW + battGapX);
                    const by = battStartY + bRow * (battH + battGapY);
                    svg += `<rect x="${bx}" y="${by}" width="${battW}" height="${battH}" rx="4" fill="#bbf7d0" stroke="#15803d" stroke-width="1.2"/>`;
                    // Terminals
                    svg += `<rect x="${bx-2}" y="${by + battH/2 - 4}" width="4" height="8" rx="1.5" fill="#dc2626"/>`;
                    svg += `<rect x="${bx + battW - 2}" y="${by + battH/2 - 4}" width="4" height="8" rx="1.5" fill="#2563eb"/>`;
                    svg += `<text x="${bx + battW/2}" y="${by + battTextYV}" text-anchor="middle" font-size="${battFontV}" fill="#15803d" font-weight="bold">${unitVoltage}V</text>`;
                    svg += `<text x="${bx + battW/2}" y="${by + battTextYAh}" text-anchor="middle" font-size="${battFontAh}" fill="#555">${selectedAh}Ah</text>`;
                    // Series wires
                    if (bCol < batteriesInSeries - 1) {
                        svg += `<line x1="${bx + battW + 2}" y1="${by + battH/2}" x2="${bx + battW + battGapX - 2}" y2="${by + battH/2}" stroke="#f59e0b" stroke-width="2"/>`;
                    }
                }
                if (parallelStrings > 1) {
                    svg += `<text x="${battStartX - 4}" y="${battStartY + bRow * (battH + battGapY) + battH/2 + 3}" text-anchor="end" font-size="7" fill="#666">S${bRow+1}</text>`;
                }
            }
            // Parallel bus bars (if multiple strings)
            if (parallelStrings > 1) {
                const busLX = battStartX - 10;
                const busRX = battStartX + (batteriesInSeries - 1) * (battW + battGapX) + battW + 10;
                const busTopY = battStartY + battH/2;
                const busBotY = battStartY + (parallelStrings - 1) * (battH + battGapY) + battH/2;
                svg += `<line x1="${busLX}" y1="${busTopY}" x2="${busLX}" y2="${busBotY}" stroke="#dc2626" stroke-width="3"/>`;
                svg += `<line x1="${busRX}" y1="${busTopY}" x2="${busRX}" y2="${busBotY}" stroke="#2563eb" stroke-width="3"/>`;
                for (let bRow = 0; bRow < parallelStrings; bRow++) {
                    const y = battStartY + bRow * (battH + battGapY) + battH/2;
                    svg += `<line x1="${busLX}" y1="${y}" x2="${battStartX - 2}" y2="${y}" stroke="#dc2626" stroke-width="1.5"/>`;
                    svg += `<line x1="${battStartX + (batteriesInSeries-1)*(battW+battGapX) + battW + 2}" y1="${y}" x2="${busRX}" y2="${y}" stroke="#2563eb" stroke-width="1.5"/>`;
                }
                svg += `<text x="${busLX}" y="${busBotY + 12}" text-anchor="middle" font-size="7" fill="#dc2626" font-weight="bold">+</text>`;
                svg += `<text x="${busRX}" y="${busBotY + 12}" text-anchor="middle" font-size="7" fill="#2563eb" font-weight="bold">\u2212</text>`;
            }
            // Battery specs under grid — split into 3 compact lines to prevent overflow
            const battSpecY = battStartY + battGridTotalH + 2;
            const bSpecFont = battBoxW < 300 ? 7.5 : 8.5;
            const bSpecLine = battBoxW < 300 ? 10 : 12;
            svg += `<text x="${leftBranchX}" y="${battSpecY + bSpecLine}" text-anchor="middle" font-size="${bSpecFont}" fill="#16a34a">${totalBatteries}x ${unitVoltage}V/${selectedAh}Ah (${batteriesInSeries}S${parallelStrings > 1 ? ' x ' + parallelStrings + 'P' : ''})</text>`;
            svg += `<text x="${leftBranchX}" y="${battSpecY + bSpecLine*2}" text-anchor="middle" font-size="${bSpecFont}" fill="#16a34a">Usable: ${batt.usableCapacityWh}Wh (${(specs.maxDoD*100).toFixed(0)}% DoD)</text>`;
            svg += `<text x="${leftBranchX}" y="${battSpecY + bSpecLine*3}" text-anchor="middle" font-size="${bSpecFont - 0.5}" fill="#22c55e">Charge: ${batt.maxChargeCurrent}A | Discharge: ${batt.maxDischargeCurrent}A | ${specs.cycleLife} cycles</text>`;
            svg += `</g>`; // close battery clipPath group

            // AC Loads box (right)
            const ldW = rightColWPre, ldH = 90, ldX = rightBranchX - ldW/2;
            svg += `<rect x="${ldX}" y="${Y}" width="${ldW}" height="${ldH}" rx="${boxR}" fill="#faf5ff" stroke="#7c3aed" stroke-width="2"/>`;
            svg += `<text x="${rightBranchX}" y="${Y+16}" text-anchor="middle" font-size="11" font-weight="bold" fill="#5b21b6">AC Loads</text>`;
            svg += `<text x="${rightBranchX}" y="${Y+32}" text-anchor="middle" font-size="9.5" fill="#7c3aed">${config.acVoltage}V AC | Distribution Board</text>`;
            svg += `<text x="${rightBranchX}" y="${Y+46}" text-anchor="middle" font-size="9" fill="#8b5cf6">Daily: ${details.aggregation?.dailyEnergyWh || '\u2014'}Wh</text>`;
            svg += `<text x="${rightBranchX}" y="${Y+60}" text-anchor="middle" font-size="9" fill="#8b5cf6">Peak: ${details.aggregation?.peakSimultaneousVA || '\u2014'}VA</text>`;
            svg += `<text x="${rightBranchX}" y="${Y+74}" text-anchor="middle" font-size="8" fill="#a78bfa">Continuous: ${inv.continuousVARequired}VA needed</text>`;
            svg += `<text x="${rightBranchX}" y="${Y+86}" text-anchor="middle" font-size="8" fill="#a78bfa">Surge: ${inv.surgeVARequired}VA needed</text>`;

            Y += Math.max(battBoxH, ldH);

        } else {
            // ===== OFF-GRID: Separate MPPT + Inverter =====
            const mpptW = Math.min(380, W - 60), mpptH = 100, mpptX = (W - mpptW) / 2;
            svg += `<rect x="${mpptX}" y="${Y}" width="${mpptW}" height="${mpptH}" rx="${boxR}" fill="#dbeafe" stroke="#3b82f6" stroke-width="2"/>`;
            svg += `<text x="${cx}" y="${Y+16}" text-anchor="middle" font-size="12" font-weight="bold" fill="#1d4ed8">MPPT Charge Controller</text>`;
            svg += `<text x="${cx}" y="${Y+30}" text-anchor="middle" font-size="9" fill="#3b82f6">Standalone | Max PV: ${mppt.maxPower}W</text>`;
            svg += `<text x="${cx}" y="${Y+44}" text-anchor="middle" font-size="8.5" fill="#2563eb">V: ${mppt.minVoltage}\u2013${mppt.maxOperatingVoltage}\u2013${mppt.maxVoltage}V | I: ${mppt.maxCurrent}A | Charge: ${mppt.maxChargeCurrent}A</text>`;
            svg += `<text x="${cx}" y="${Y+58}" text-anchor="middle" font-size="8" fill="#60a5fa">${mppt.inputCount > 1 ? mppt.inputCount + ' inputs' : '1 input'} | Voc(cold) ${pv.stringVocCold}V ${pv.stringVocCold <= mppt.maxVoltage ? '\u2714' : '\u2718'} | Isc ${pv.arrayIsc}A ${pv.arrayIsc <= mppt.maxCurrent ? '\u2714' : '\u2718'}</text>`;
            Y += mpptH;

            // Wire to DC bus
            svg += `<line x1="${cx}" y1="${Y}" x2="${cx}" y2="${Y+14}" stroke="#dc2626" stroke-width="2.5"/>`;
            Y += 14;

            // Position branches using pre-calculated widths (W already accounts for these)
            const totalColW = battBoxWPre + colGapPre + rightColWPre;
            const colStartX = (W - totalColW) / 2;
            const battBranchX = colStartX + battBoxWPre / 2;
            const invBranchX = colStartX + battBoxWPre + colGapPre + rightColWPre / 2;
            const bbW = 140, bbH = 36;

            // DC Bus line spans both branches
            const busLeft = Math.min(battBranchX - battBoxWPre/2 - 10, W/2 - 20);
            const busRight = Math.max(invBranchX + rightColWPre/2 + 10, W/2 + 20);
            svg += `<line x1="${busLeft}" y1="${Y}" x2="${busRight}" y2="${Y}" stroke="#dc2626" stroke-width="3"/>`;
            svg += `<text x="${(busLeft+busRight)/2}" y="${Y-5}" text-anchor="middle" font-size="8.5" font-weight="bold" fill="#dc2626">${batt.bankVoltage}V DC Bus</text>`;

            svg += `<line x1="${battBranchX}" y1="${Y}" x2="${battBranchX}" y2="${Y+22}" stroke="#dc2626" stroke-width="2.5"/>`;
            svg += `<line x1="${invBranchX}" y1="${Y}" x2="${invBranchX}" y2="${Y+22}" stroke="#dc2626" stroke-width="2.5"/>`;
            if (battCableLabel) svg += `<text x="${battBranchX-8}" y="${Y+14}" text-anchor="end" font-size="7.5" fill="#dc2626">${battCableLabel}</text>`;
            Y += 22;

            // Battery DC MCCB (left)
            svg += `<rect x="${battBranchX-bbW/2}" y="${Y}" width="${bbW}" height="${bbH}" rx="4" fill="#fee2e2" stroke="#dc2626" stroke-width="1.5"/>`;
            svg += `<text x="${battBranchX}" y="${Y+14}" text-anchor="middle" font-size="9" font-weight="bold" fill="#991b1b">Battery DC MCCB</text>`;
            svg += `<text x="${battBranchX}" y="${Y+28}" text-anchor="middle" font-size="8.5" fill="#b91c1c">${battBreakerLabel}</text>`;

            // Inverter (right)
            const iW = rightColWPre, iH = 90, iX = invBranchX - iW/2;
            svg += `<rect x="${iX}" y="${Y}" width="${iW}" height="${iH}" rx="${boxR}" fill="#eff6ff" stroke="#2563eb" stroke-width="2"/>`;
            svg += `<text x="${invBranchX}" y="${Y+16}" text-anchor="middle" font-size="11" font-weight="bold" fill="#1e40af">Inverter</text>`;
            svg += `<text x="${invBranchX}" y="${Y+30}" text-anchor="middle" font-size="9" fill="#3b82f6">${inv.recommendedSizeVA} VA cont | Surge: ${surgeCap}VA</text>`;
            svg += `<text x="${invBranchX}" y="${Y+44}" text-anchor="middle" font-size="8.5" fill="#2563eb">DC: ${inv.dcInputCurrentContinuous}A / ${inv.dcInputCurrentSurge}A surge</text>`;
            svg += `<text x="${invBranchX}" y="${Y+58}" text-anchor="middle" font-size="8.5" fill="#3b82f6">${inv.dcBusVoltage}VDC \u2192 ${config.acVoltage}VAC Pure Sine</text>`;
            svg += `<text x="${invBranchX}" y="${Y+72}" text-anchor="middle" font-size="8" fill="#60a5fa">Need: ${inv.continuousVARequired}VA cont | ${inv.surgeVARequired}VA surge</text>`;

            // Wire from batt breaker to battery bank
            svg += `<line x1="${battBranchX}" y1="${Y+bbH}" x2="${battBranchX}" y2="${Y+bbH+16}" stroke="#dc2626" stroke-width="2.5"/>`;

            // ===== BATTERY BANK — Full Grid =====
            const battBankY = Y + bbH + 16;
            const battGridTotalH = parallelStrings * (battH + battGapY);
            const battBoxW = battBoxWPre, battBoxH = battGridTotalH + 70;
            const battBoxX = battBranchX - battBoxW/2;
            const battClipId2 = 'battClip2';
            svg += `<defs><clipPath id="${battClipId2}"><rect x="${battBoxX}" y="${battBankY}" width="${battBoxW}" height="${battBoxH}" rx="${boxR}"/></clipPath></defs>`;
            svg += `<rect x="${battBoxX}" y="${battBankY}" width="${battBoxW}" height="${battBoxH}" rx="${boxR}" fill="#dcfce7" stroke="#16a34a" stroke-width="2"/>`;
            svg += `<g clip-path="url(#${battClipId2})">`;
            const battTitleFont2 = battBoxW < 300 ? 9 : 11;
            svg += `<text x="${battBranchX}" y="${battBankY+15}" text-anchor="middle" font-size="${battTitleFont2}" font-weight="bold" fill="#166534">Battery Bank \u2014 ${batt.chemistryName} | ${batt.bankVoltage}V / ${actualBankAh}Ah</text>`;

            // Draw every battery — centered within the (possibly wider) box
            const battPadX2 = Math.max(20, (battBoxW - battGridActualW) / 2);
            const battStartX = battBoxX + battPadX2, battStartY = battBankY + 24;
            for (let bRow = 0; bRow < parallelStrings; bRow++) {
                for (let bCol = 0; bCol < batteriesInSeries; bCol++) {
                    const bx = battStartX + bCol * (battW + battGapX);
                    const by = battStartY + bRow * (battH + battGapY);
                    svg += `<rect x="${bx}" y="${by}" width="${battW}" height="${battH}" rx="4" fill="#bbf7d0" stroke="#15803d" stroke-width="1.2"/>`;
                    svg += `<rect x="${bx-2}" y="${by + battH/2 - 4}" width="4" height="8" rx="1.5" fill="#dc2626"/>`;
                    svg += `<rect x="${bx + battW - 2}" y="${by + battH/2 - 4}" width="4" height="8" rx="1.5" fill="#2563eb"/>`;
                    svg += `<text x="${bx + battW/2}" y="${by + battTextYV}" text-anchor="middle" font-size="${battFontV}" fill="#15803d" font-weight="bold">${unitVoltage}V</text>`;
                    svg += `<text x="${bx + battW/2}" y="${by + battTextYAh}" text-anchor="middle" font-size="${battFontAh}" fill="#555">${selectedAh}Ah</text>`;
                    if (bCol < batteriesInSeries - 1) {
                        svg += `<line x1="${bx + battW + 2}" y1="${by + battH/2}" x2="${bx + battW + battGapX - 2}" y2="${by + battH/2}" stroke="#f59e0b" stroke-width="2"/>`;
                    }
                }
                if (parallelStrings > 1) svg += `<text x="${battStartX - 4}" y="${battStartY + bRow * (battH + battGapY) + battH/2 + 3}" text-anchor="end" font-size="7" fill="#666">S${bRow+1}</text>`;
            }
            if (parallelStrings > 1) {
                const busLX = battStartX - 10;
                const busRX = battStartX + (batteriesInSeries - 1) * (battW + battGapX) + battW + 10;
                const busTopY = battStartY + battH/2;
                const busBotY = battStartY + (parallelStrings - 1) * (battH + battGapY) + battH/2;
                svg += `<line x1="${busLX}" y1="${busTopY}" x2="${busLX}" y2="${busBotY}" stroke="#dc2626" stroke-width="3"/>`;
                svg += `<line x1="${busRX}" y1="${busTopY}" x2="${busRX}" y2="${busBotY}" stroke="#2563eb" stroke-width="3"/>`;
                for (let bRow = 0; bRow < parallelStrings; bRow++) {
                    const y = battStartY + bRow * (battH + battGapY) + battH/2;
                    svg += `<line x1="${busLX}" y1="${y}" x2="${battStartX - 2}" y2="${y}" stroke="#dc2626" stroke-width="1.5"/>`;
                    svg += `<line x1="${battStartX + (batteriesInSeries-1)*(battW+battGapX) + battW + 2}" y1="${y}" x2="${busRX}" y2="${y}" stroke="#2563eb" stroke-width="1.5"/>`;
                }
            }
            // Battery specs under grid — split into 3 compact lines to prevent overflow
            const battSpecY2 = battStartY + battGridTotalH + 2;
            const bSpecFont2 = battBoxW < 300 ? 7.5 : 8.5;
            const bSpecLine2 = battBoxW < 300 ? 10 : 12;
            svg += `<text x="${battBranchX}" y="${battSpecY2 + bSpecLine2}" text-anchor="middle" font-size="${bSpecFont2}" fill="#16a34a">${totalBatteries}x ${unitVoltage}V/${selectedAh}Ah (${batteriesInSeries}S${parallelStrings > 1 ? ' x ' + parallelStrings + 'P' : ''})</text>`;
            svg += `<text x="${battBranchX}" y="${battSpecY2 + bSpecLine2*2}" text-anchor="middle" font-size="${bSpecFont2}" fill="#16a34a">Usable: ${batt.usableCapacityWh}Wh (${(specs.maxDoD*100).toFixed(0)}% DoD)</text>`;
            svg += `<text x="${battBranchX}" y="${battSpecY2 + bSpecLine2*3}" text-anchor="middle" font-size="${bSpecFont2 - 0.5}" fill="#22c55e">Charge: ${batt.maxChargeCurrent}A | Discharge: ${batt.maxDischargeCurrent}A | ${specs.cycleLife} cycles</text>`;
            svg += `</g>`; // close battery clipPath group

            // Wire from inverter to AC Breaker
            const invBottom = Y + iH;
            svg += `<line x1="${invBranchX}" y1="${invBottom}" x2="${invBranchX}" y2="${invBottom+18}" stroke="#7c3aed" stroke-width="2.5"/>`;
            if (acCableLabel) svg += `<text x="${invBranchX+10}" y="${invBottom+12}" font-size="7.5" fill="#7c3aed">AC ${acCableLabel}</text>`;

            // AC MCB
            const abY = invBottom + 18, abW = 140, abH = 36;
            svg += `<rect x="${invBranchX-abW/2}" y="${abY}" width="${abW}" height="${abH}" rx="4" fill="#f3e8ff" stroke="#7c3aed" stroke-width="1.5"/>`;
            svg += `<text x="${invBranchX}" y="${abY+14}" text-anchor="middle" font-size="9" font-weight="bold" fill="#5b21b6">AC MCB</text>`;
            svg += `<text x="${invBranchX}" y="${abY+28}" text-anchor="middle" font-size="8.5" fill="#7c3aed">${acBreakerLabel}</text>`;

            // Wire to AC Loads
            svg += `<line x1="${invBranchX}" y1="${abY+abH}" x2="${invBranchX}" y2="${abY+abH+16}" stroke="#7c3aed" stroke-width="2.5"/>`;

            // AC Loads
            const ldW = rightColWPre, ldH = 90, ldX = invBranchX - ldW/2, ldY = abY + abH + 16;
            svg += `<rect x="${ldX}" y="${ldY}" width="${ldW}" height="${ldH}" rx="${boxR}" fill="#faf5ff" stroke="#7c3aed" stroke-width="2"/>`;
            svg += `<text x="${invBranchX}" y="${ldY+16}" text-anchor="middle" font-size="11" font-weight="bold" fill="#5b21b6">AC Loads</text>`;
            svg += `<text x="${invBranchX}" y="${ldY+32}" text-anchor="middle" font-size="9.5" fill="#7c3aed">${config.acVoltage}V AC | Distribution Board</text>`;
            svg += `<text x="${invBranchX}" y="${ldY+46}" text-anchor="middle" font-size="9" fill="#8b5cf6">Daily: ${details.aggregation?.dailyEnergyWh || '\u2014'}Wh</text>`;
            svg += `<text x="${invBranchX}" y="${ldY+60}" text-anchor="middle" font-size="9" fill="#8b5cf6">Peak: ${details.aggregation?.peakSimultaneousVA || '\u2014'}VA</text>`;
            svg += `<text x="${invBranchX}" y="${ldY+74}" text-anchor="middle" font-size="8" fill="#a78bfa">Continuous: ${inv.continuousVARequired}VA | Surge: ${inv.surgeVARequired}VA</text>`;

            Y = Math.max(battBankY + battBoxH, ldY + ldH);
        }

        // Compute final SVG dimensions
        const svgH = Y + 20;
        svg = `<svg viewBox="0 0 ${W} ${svgH}" style="width:100%; max-width:${W}px; height:auto; display:block; margin:0 auto;">` +
              `<rect width="${W}" height="${svgH}" rx="12" fill="var(--bg-color, #f8fafc)" stroke="var(--border-color, #e2e8f0)" stroke-width="1.5"/>` +
              `<text x="${cx}" y="28" text-anchor="middle" font-size="15" font-weight="bold" fill="var(--text-color, #1e293b)">${isHybrid ? 'Hybrid' : 'Off-Grid'} Solar System \u2014 Full Configuration</text>` +
              svg + '</svg>';

        // Assemble tab content
        let html = '<div class="results-section">';
        html += svg;

        // Legend
        html += `
            <div style="display: flex; gap: 14px; flex-wrap: wrap; margin-top: 12px; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 6px; font-size: 0.8rem;">
                <div style="display:flex; align-items:center; gap:4px;"><span style="display:inline-block; width:12px; height:12px; background:#fef9c3; border:1.5px solid #ca8a04; border-radius:2px;"></span> PV Panels</div>
                <div style="display:flex; align-items:center; gap:4px;"><span style="display:inline-block; width:12px; height:12px; background:#fee2e2; border:1.5px solid #dc2626; border-radius:2px;"></span> Protection</div>
                <div style="display:flex; align-items:center; gap:4px;"><span style="display:inline-block; width:12px; height:12px; background:#dbeafe; border:1.5px solid #3b82f6; border-radius:2px;"></span> MPPT/Inverter</div>
                <div style="display:flex; align-items:center; gap:4px;"><span style="display:inline-block; width:12px; height:12px; background:#bbf7d0; border:1.5px solid #15803d; border-radius:2px;"></span> Battery Units</div>
                <div style="display:flex; align-items:center; gap:4px;"><span style="display:inline-block; width:12px; height:12px; background:#faf5ff; border:1.5px solid #7c3aed; border-radius:2px;"></span> AC Load</div>
                <div style="display:flex; align-items:center; gap:4px;"><span style="display:inline-block; width:12px; height:3px; background:#dc2626; border-radius:2px;"></span> DC Wire</div>
                <div style="display:flex; align-items:center; gap:4px;"><span style="display:inline-block; width:12px; height:3px; background:#7c3aed; border-radius:2px;"></span> AC Wire</div>
                <div style="display:flex; align-items:center; gap:4px;"><span style="display:inline-block; width:12px; height:3px; background:#f59e0b; border-radius:2px;"></span> Series Link</div>
            </div>
        `;

        html += '</div>';

        // ============ COMPONENT SPECIFICATION TABLES ============
        const sectionStyle = 'margin-top: 20px; border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden;';
        const headerStyle = (bg, color) => `padding: 10px 14px; font-size: 0.95rem; font-weight: 700; color: ${color}; background: ${bg}; border-bottom: 1px solid var(--border-color);`;
        const rowStyle = 'display: flex; justify-content: space-between; padding: 6px 14px; font-size: 0.88rem; border-bottom: 1px solid var(--border-color);';
        const labelStyle = 'color: var(--text-muted);';
        const valStyle = 'font-weight: 600; text-align: right;';
        const boldRowBg = 'background: var(--bg-color);';

        const row = (label, value, bold) => `<div style="${rowStyle} ${bold ? boldRowBg : ''}"><span style="${labelStyle}">${label}</span><span style="${valStyle}">${value}</span></div>`;

        // === 1. SOLAR PANEL & PV ARRAY ===
        html += `<div style="${sectionStyle}">`;
        html += `<div style="${headerStyle('#fef9c3', '#92400e')}">Solar Panel & PV Array</div>`;
        html += row('Panel Wattage', `${panel.wattage} Wp`, true);
        html += row('Vmp / Voc', `${panel.vmp}V / ${panel.voc}V`);
        html += row('Imp / Isc', `${panel.imp}A / ${panel.isc}A`);
        html += row('Temp Coeff Pmax', `${panel.tempCoeffPmax}%/\u00B0C`);
        html += row('Array Configuration', `${pv.panelsInSeries}S x ${pv.stringsInParallel}P = ${pv.totalPanels} panels`, true);
        html += row('Total Array Wattage', `${pv.arrayWattage} Wp`, true);
        html += row('String Vmp', `${pv.stringVmp} V`);
        html += row('String Voc', `${pv.stringVoc} V`);
        html += row('String Voc (Cold)', `${pv.stringVocCold} V`);
        html += row('Array Imp', `${pv.arrayImp} A`);
        html += row('Array Isc', `${pv.arrayIsc} A`);
        html += row('Derated Output (Hot)', `${pv.deratedOutput} W`);
        html += row('Daily Energy Production', `${pv.dailyEnergyWh} Wh`);
        html += `</div>`;

        // === 2. MPPT / CHARGE CONTROLLER ===
        html += `<div style="${sectionStyle}">`;
        html += `<div style="${headerStyle('#dbeafe', '#1e40af')}">MPPT / Charge Controller ${isHybrid ? '(Built into Hybrid Inverter)' : '(Standalone)'}</div>`;
        html += row('Max Input Voltage', `${mppt.maxVoltage} V`);
        html += row('Min Startup Voltage', `${mppt.minVoltage} V`);
        html += row('Max Operating Voltage', `${mppt.maxOperatingVoltage} V`);
        html += row('Max Input Current', `${mppt.maxCurrent} A`);
        html += row('Max PV Input Power', `${mppt.maxPower} W`, true);
        html += row('Max Charge Current', `${mppt.maxChargeCurrent} A`);
        if (mppt.inputCount > 1) html += row('MPPT Inputs', `${mppt.inputCount}`);
        html += row('Voc (Cold) vs Max Voltage', `${pv.stringVocCold}V / ${mppt.maxVoltage}V ${pv.stringVocCold <= mppt.maxVoltage ? '\u2714 OK' : '\u2718 EXCEEDS'}`, true);
        html += row('Array Isc vs Max Current', `${pv.arrayIsc}A / ${mppt.maxCurrent}A ${pv.arrayIsc <= mppt.maxCurrent ? '\u2714 OK' : '\u2718 EXCEEDS'}`);
        html += `</div>`;

        // === 3. INVERTER ===
        html += `<div style="${sectionStyle}">`;
        html += `<div style="${headerStyle('#eff6ff', '#1e40af')}">${isHybrid ? 'Hybrid ' : ''}Inverter</div>`;
        html += row('System Type', isHybrid ? 'Hybrid (MPPT built-in)' : 'Off-Grid (Separate MPPT)', true);
        html += row('Rated Size', `${InverterSizingEngine.formatMarketRange(inv.recommendedSizeVA)}`, true);
        html += row('Continuous VA Required', `${inv.continuousVARequired} VA`);
        html += row('Surge VA Required', `${inv.surgeVARequired} VA`);
        const surgeMultiplier2 = config.inverterSurgeMultiplier || 2.0;
        const surgeCap2 = Math.round(inv.recommendedSizeVA * surgeMultiplier2);
        html += row(`Surge Capacity (${surgeMultiplier2}x)`, `${surgeCap2} VA ${surgeCap2 >= inv.surgeVARequired ? '\u2714' : '\u2718'}`);
        html += row('DC Bus Voltage', `${inv.dcBusVoltage} V`);
        html += row('DC Input Current (Cont)', `${inv.dcInputCurrentContinuous} A`);
        html += row('DC Input Current (Surge)', `${inv.dcInputCurrentSurge} A`);
        html += row('AC Output Voltage', `${config.acVoltage} V`);
        html += `</div>`;

        // === 4. BATTERY BANK ===
        html += `<div style="${sectionStyle}">`;
        html += `<div style="${headerStyle('#dcfce7', '#166534')}">Battery Bank</div>`;
        html += row('Chemistry', batt.chemistryName, true);
        html += row('Bank Voltage', `${batt.bankVoltage} V`);
        html += row('Total Capacity', `${batt.totalCapacityAh} Ah (${batt.totalCapacityWh} Wh)`, true);
        html += row('Usable Capacity', `${batt.usableCapacityWh} Wh (${(specs.maxDoD * 100).toFixed(0)}% DoD)`);
        html += row('Battery Unit', `${unitVoltage}V / ${selectedAh}Ah`);
        html += row('Configuration', `${batteriesInSeries}S x ${parallelStrings}P = ${totalBatteries} batteries`, true);
        html += row('Actual Bank Ah', `${parallelStrings * selectedAh} Ah`);
        html += row('Max Charge Current', `${batt.maxChargeCurrent} A`);
        html += row('Max Discharge Current', `${batt.maxDischargeCurrent} A`);
        html += row('Cycle Life', `${specs.cycleLife.toLocaleString()} cycles`);
        html += row('Round-trip Efficiency', `${(specs.chargeEfficiency * specs.dischargeEfficiency * 100).toFixed(1)}%`);
        html += `</div>`;

        // === 5. PROTECTION DEVICES ===
        html += `<div style="${sectionStyle}">`;
        html += `<div style="${headerStyle('#fee2e2', '#991b1b')}">Protection Devices</div>`;
        const allDevices = [
            ...(protection.pvSide || []).map(d => ({ ...d, side: 'PV DC' })),
            ...(protection.batterySide || []).map(d => ({ ...d, side: 'Battery DC' })),
            ...(protection.acSide || []).map(d => ({ ...d, side: 'AC' })),
            ...(protection.earthing || []).map(d => ({ ...d, side: 'Earth' }))
        ];
        allDevices.forEach(d => {
            const mandatory = d.mandatory ? '<span style="color: var(--error-color); font-size: 0.78rem;"> (Required)</span>' : '<span style="color: var(--text-muted); font-size: 0.78rem;"> (Recommended)</span>';
            html += row(`${d.name}${mandatory}`, `${d.rating}`, d.mandatory);
        });
        html += `</div>`;

        // === 6. CABLES ===
        html += `<div style="${sectionStyle}">`;
        html += `<div style="${headerStyle('#fef3c7', '#92400e')}">Cable Sizing</div>`;
        if (cables) {
            const allRuns = [...(cables.dcRuns || []), ...(cables.acRuns || [])];
            allRuns.forEach(run => {
                const marketSize = run.marketMm2 || run.recommendedMm2;
                const parallelLabel = run.parallelCables > 1 ? ` x ${run.parallelCables} runs` : '';
                html += row(run.name, `${marketSize}mm\u00B2 (${run.recommendedAWG} AWG)${parallelLabel} | ${run.current}A | Drop: ${run.actualVoltageDropPercent}%`);
            });
            html += row('Total Cable Length', `${cables.totalCopperLengthM} m`, true);
            html += row('Est. Copper Weight', `${cables.estimatedCopperKg} kg`);
        }
        html += `</div>`;

        // === 7. SYSTEM LOSSES ===
        if (losses) {
            html += `<div style="${sectionStyle}">`;
            html += `<div style="${headerStyle('#fef3c7', '#92400e')}">System Losses & Efficiency</div>`;
            html += row('Inverter Efficiency', `${losses.inverterEfficiency}%`);
            html += row('Battery Round-Trip', `${losses.batteryRoundTripEfficiency}%`);
            html += row('MPPT Efficiency', `${losses.mpptEfficiency}%`);
            html += row('PV Temp Derating', `${losses.pvTempDerating}%`);
            html += row('Total System Efficiency', `${losses.overallSystemEfficiency}%`, true);
            html += `</div>`;
        }

        // === 8. ENVIRONMENT ===
        html += `<div style="${sectionStyle}">`;
        html += `<div style="${headerStyle('#f0fdf4', '#166534')}">Environment & Design Parameters</div>`;
        html += row('Location', DEFAULTS.LOCATIONS[config.location]?.name || config.location);
        html += row('System Type', isHybrid ? 'Hybrid (MPPT built into inverter)' : 'Off-Grid (Separate MPPT + Inverter)', true);
        html += row('Peak Sun Hours', `${config.avgPSH} hrs`);
        html += row('Ambient Temp Range', `${config.ambientTempMin}\u00B0C to ${config.ambientTempMax}\u00B0C`);
        html += row('Autonomy', `${config.autonomyDays} day(s)`);
        html += row('Design Margin', `${config.designMargin}%`);
        html += row('AC Voltage', `${config.acVoltage} V`);
        html += `</div>`;

        return html;
    },

    renderLoadTab(aggregation) {
        return `
            <div class="results-section">
                <div class="result-row">
                    <span class="result-label">Total Real Power</span>
                    <span class="result-value">${aggregation.totalRealPowerW} W</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Total Apparent Power</span>
                    <span class="result-value">${aggregation.totalApparentPowerVA} VA</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Peak Simultaneous Load</span>
                    <span class="result-value">${aggregation.peakSimultaneousVA} VA</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Highest Surge</span>
                    <span class="result-value">${aggregation.highestSurgeVA} VA</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Daily Energy</span>
                    <span class="result-value">${aggregation.dailyEnergyWh} Wh</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Daytime Energy</span>
                    <span class="result-value">${aggregation.daytimeEnergyWh} Wh</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Nighttime Energy</span>
                    <span class="result-value">${aggregation.nighttimeEnergyWh} Wh</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Design Continuous (with margin)</span>
                    <span class="result-value">${aggregation.designContinuousVA} VA</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Design Surge (with margin)</span>
                    <span class="result-value">${aggregation.designSurgeVA} VA</span>
                </div>
            </div>
        `;
    },

    renderInverterTab(inverter) {
        const config = this.getConfig();
        const surgeMultiplier = config.inverterSurgeMultiplier || 2.0;
        const surgeCap = Math.round(inverter.recommendedSizeVA * surgeMultiplier);
        const surgeOk = surgeCap >= inverter.surgeVARequired;

        let html = `<div class="results-section">`;

        // Manual override indicator
        if (inverter.isManualOverride) {
            html += `
                <div class="alert alert-info" style="margin-bottom: 12px;">
                    <span class="alert-icon">&#128295;</span>
                    <div class="alert-content">
                        <strong>Manual Override Active</strong><br>
                        Your input: <strong>${inverter.recommendedSizeVA} VA</strong> |
                        Auto-suggested: <strong>${inverter.autoSuggestedSizeVA} VA</strong>
                        ${inverter.recommendedSizeVA < inverter.autoSuggestedSizeVA
                            ? ' <span style="color: var(--warning-color);">(undersized vs recommendation)</span>'
                            : inverter.recommendedSizeVA > inverter.autoSuggestedSizeVA
                            ? ' <span style="color: var(--success-color);">(has extra headroom)</span>'
                            : ' <span style="color: var(--success-color);">(matches recommendation)</span>'}
                    </div>
                </div>`;

            // ===== MANUAL MODE: Three-Tier Verification Grid =====
            // Show conservative/recommended/optimized with tick/cross against user's entry
            const userVA = inverter.recommendedSizeVA; // user's manual value
            const conservativeVA = inverter.autoSuggestedSizeVA || 0;
            const recommendedVA = inverter.recommendedBalancedSizeVA || conservativeVA;
            const optimizedVA = inverter.staggeredSizeVA || conservativeVA;
            const userSurgeCap = Math.round(userVA * surgeMultiplier);
            const hasMotors = (inverter.motorCount || 0) >= 2;

            const tierCheck = (userVal, tierVal) => {
                if (userVal >= tierVal) return { icon: '\u2714', color: 'var(--success-color)', label: 'PASS' };
                if (userVal >= tierVal * 0.9) return { icon: '\u26A0', color: 'var(--warning-color)', label: 'CLOSE' };
                return { icon: '\u2718', color: 'var(--error-color)', label: 'FAIL' };
            };
            const conservChk = tierCheck(userVA, conservativeVA);
            const recChk = tierCheck(userVA, recommendedVA);
            const optChk = tierCheck(userVA, optimizedVA);
            // Surge check against full worst-case surge
            const surgeChk = tierCheck(userSurgeCap, inverter.surgeVARequired);

            html += `
                <div style="margin-bottom: 14px;">
                    <div style="font-size: 0.82rem; font-weight: 600; color: var(--text-color); margin-bottom: 6px;">Verification Against Auto-Calculated Tiers</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr ${hasMotors ? '1fr' : ''}; gap: 6px;">
                        <!-- CONSERVATIVE -->
                        <div style="padding: 8px; border-radius: 8px; border: 2px solid ${conservChk.color}; background: var(--bg-color); text-align: center;">
                            <div style="font-size: 0.68rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Conservative</div>
                            <div style="font-size: 1rem; font-weight: 700; color: var(--text-color);">${InverterSizingEngine.formatMarketRange(conservativeVA)}</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">All motors start together</div>
                            <div style="font-size: 1.2rem; margin-top: 4px; color: ${conservChk.color};" title="${conservChk.label}">${conservChk.icon}</div>
                            <div style="font-size: 0.65rem; color: ${conservChk.color}; font-weight: 600;">${conservChk.label}</div>
                        </div>
                        <!-- RECOMMENDED -->
                        <div style="padding: 8px; border-radius: 8px; border: 2px solid ${recChk.color}; background: var(--bg-color); text-align: center;">
                            <div style="font-size: 0.68rem; color: var(--primary-color); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;">Recommended</div>
                            <div style="font-size: 1rem; font-weight: 700; color: var(--primary-color);">${InverterSizingEngine.formatMarketRange(recommendedVA)}</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">+${inverter.motorBufferPct || 10}% buffer</div>
                            <div style="font-size: 1.2rem; margin-top: 4px; color: ${recChk.color};" title="${recChk.label}">${recChk.icon}</div>
                            <div style="font-size: 0.65rem; color: ${recChk.color}; font-weight: 600;">${recChk.label}</div>
                        </div>
                        ${hasMotors ? `
                        <!-- OPTIMIZED (staggered) -->
                        <div style="padding: 8px; border-radius: 8px; border: 2px solid ${optChk.color}; background: var(--bg-color); text-align: center;">
                            <div style="font-size: 0.68rem; color: var(--success-color); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;">Optimized</div>
                            <div style="font-size: 1rem; font-weight: 700; color: var(--success-color);">${InverterSizingEngine.formatMarketRange(optimizedVA)}</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">Stagger starts (30s+)</div>
                            <div style="font-size: 1.2rem; margin-top: 4px; color: ${optChk.color};" title="${optChk.label}">${optChk.icon}</div>
                            <div style="font-size: 0.65rem; color: ${optChk.color}; font-weight: 600;">${optChk.label}</div>
                        </div>` : ''}
                        <!-- SURGE CHECK -->
                        <div style="padding: 8px; border-radius: 8px; border: 2px solid ${surgeChk.color}; background: var(--bg-color); text-align: center;">
                            <div style="font-size: 0.68rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Surge Capacity</div>
                            <div style="font-size: 1rem; font-weight: 700; color: var(--text-color);">${userSurgeCap} VA</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">Need: ${Math.round(inverter.surgeVARequired)} VA</div>
                            <div style="font-size: 1.2rem; margin-top: 4px; color: ${surgeChk.color};" title="${surgeChk.label}">${surgeChk.icon}</div>
                            <div style="font-size: 0.65rem; color: ${surgeChk.color}; font-weight: 600;">${surgeChk.label}</div>
                        </div>
                    </div>
                    ${userVA < recommendedVA ? `
                    <div style="margin-top: 8px; padding: 6px 10px; border-radius: 6px; background: rgba(239,68,68,0.06); border-left: 3px solid var(--error-color); font-size: 0.78rem;">
                        <strong style="color: var(--error-color);">Advice:</strong> Your ${userVA} VA inverter does not meet the recommended ${InverterSizingEngine.formatMarketRange(recommendedVA)} tier.
                        ${userVA >= optimizedVA && hasMotors
                            ? ' It passes the Optimized tier — but <em>only if you strictly stagger motor starts</em> (never start two motors simultaneously).'
                            : userVA >= inverter.continuousVARequired
                            ? ' It handles the continuous load but may trip on motor starting surges.'
                            : ' It cannot even handle the continuous load — upgrade is required.'}
                    </div>` : userVA >= conservativeVA ? `
                    <div style="margin-top: 8px; padding: 6px 10px; border-radius: 6px; background: rgba(34,197,94,0.06); border-left: 3px solid var(--success-color); font-size: 0.78rem;">
                        <strong style="color: var(--success-color);">Excellent:</strong> Your ${userVA} VA inverter meets or exceeds the conservative (worst-case) tier. All motors can start simultaneously without risk.
                    </div>` : ''}
                </div>`;
        }

        // Stagger mode indicator
        if (inverter.isStaggerMode) {
            html += `
                <div class="alert alert-info" style="margin-bottom: 12px; border-color: var(--success-color); background: rgba(34,197,94,0.05);">
                    <span class="alert-icon">&#9889;</span>
                    <div class="alert-content">
                        <strong style="color: var(--success-color);">Staggered Motor Start Active</strong><br>
                        Using: <strong>${InverterSizingEngine.formatMarketRange(inverter.recommendedSizeVA)}</strong> (Optimized) |
                        Recommended: <strong>${InverterSizingEngine.formatMarketRange(inverter.recommendedBalancedSizeVA || inverter.safeRecommendedSizeVA)}</strong> |
                        Conservative: <strong>${InverterSizingEngine.formatMarketRange(inverter.safeRecommendedSizeVA)}</strong>
                        <span style="color: var(--warning-color);"> (ensure you never start two motors simultaneously)</span>
                    </div>
                </div>`;
        }

        html += `
                <div class="result-row">
                    <span class="result-label">Continuous VA Required</span>
                    <span class="result-value">${inverter.continuousVARequired} VA</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Surge VA Required</span>
                    <span class="result-value">${inverter.surgeVARequired} VA</span>
                </div>`;

        // STAGGER MOTOR SECTION
        const safeSize = inverter.isStaggerMode ? inverter.safeRecommendedSizeVA : inverter.recommendedSizeVA;
        // Show stagger option when 2+ motors AND staggering gives a smaller inverter or at least 5% surge reduction
        const hasStaggerBenefit = !inverter.isManualOverride && inverter.motorCount >= 2 &&
            (inverter.staggeredSizeVA < safeSize ||
             inverter.staggeredSurgeVA < inverter.surgeVARequired * 0.95);
        const staggeredSurgeCap = hasStaggerBenefit ? Math.round(inverter.staggeredSizeVA * surgeMultiplier) : 0;
        const surgeReduction = hasStaggerBenefit ? Math.round((1 - inverter.staggeredSurgeVA / inverter.surgeVARequired) * 100) : 0;

        // Market range formatting
        const mainMarketRange = InverterSizingEngine.formatMarketRange(inverter.recommendedSizeVA);

        html += `
                <div class="result-row" style="background: var(--bg-color); font-weight: bold;">
                    <span class="result-label">${inverter.isManualOverride ? 'Your Inverter Size' : 'Recommended Inverter Size'}</span>
                    <span class="result-value">${mainMarketRange}</span>
                </div>`;

        // Surge capacity block
        html += `
                <div class="result-row" style="border-left: 3px solid ${surgeOk ? 'var(--success-color)' : 'var(--error-color)'}; padding-left: 12px;">
                    <span class="result-label">Surge Capacity (${surgeMultiplier}x for 3-10 sec)</span>
                    <span class="result-value">${surgeCap} VA ${surgeOk ? '&#10003;' : '&#10007;'}</span>
                </div>
                <div style="padding: 8px 16px; font-size: 0.85rem; color: var(--text-muted); background: var(--bg-color); border-radius: 6px; margin: 4px 0 8px 0;">
                    ${mainMarketRange} × ${surgeMultiplier}x = <strong>${surgeCap} VA</strong> surge capacity
                    ${surgeOk
                        ? ` &gt; ${Math.round(inverter.surgeVARequired)} VA required <span style="color: var(--success-color); font-weight: bold;">&#10003; OK</span><br>
                            <em>Most inverters can handle ${surgeMultiplier}x their rated capacity for 3-10 seconds during motor startup.</em>`
                        : ` &lt; ${Math.round(inverter.surgeVARequired)} VA required <span style="color: var(--error-color); font-weight: bold;">&#10007; INSUFFICIENT</span><br>
                            <em>Consider a larger inverter or adding soft-start devices to high-surge appliances.</em>`}
                </div>`;

        // Motor-aware sizing section with three tiers
        if (hasStaggerBenefit) {
            const recSize = inverter.recommendedBalancedSizeVA || inverter.recommendedSizeVA;
            const recSurgeCap = Math.round(recSize * surgeMultiplier);

            html += `
                <div style="margin: 12px 0; padding: 14px; border: 2px solid var(--primary-color); border-radius: 10px; background: rgba(37,99,235,0.03);">
                    <div style="font-weight: 600; font-size: 0.95rem; margin-bottom: 10px; color: var(--primary-color);">
                        Inverter Sizing Options (${inverter.motorCount} motors detected)
                    </div>

                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.88rem;">
                            <input type="checkbox" id="staggerMotorStarts" ${this._staggerMotorStarts ? 'checked' : ''} onchange="PVCalculator.onStaggerToggle()" style="width: 16px; height: 16px; accent-color: var(--success-color);">
                            I will stagger all motor starts (no two heavy motors at the same time)
                        </label>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                        <div style="padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-color); text-align: center;">
                            <div style="font-size: 0.72rem; color: var(--text-muted); margin-bottom: 3px; text-transform: uppercase; letter-spacing: 0.5px;">Conservative</div>
                            <div style="font-size: 1.1rem; font-weight: 700; color: var(--text-color);">${InverterSizingEngine.formatMarketRange(safeSize)}</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">All motors start together</div>
                            <div style="font-size: 0.68rem; color: var(--text-muted); margin-top: 2px;">Surge: ${Math.round(safeSize * surgeMultiplier)} VA</div>
                        </div>
                        <div style="padding: 10px; border-radius: 8px; border: 2px solid var(--primary-color); background: rgba(37,99,235,0.06); text-align: center;">
                            <div style="font-size: 0.72rem; color: var(--primary-color); margin-bottom: 3px; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;">Recommended</div>
                            <div style="font-size: 1.1rem; font-weight: 700; color: var(--primary-color);">${InverterSizingEngine.formatMarketRange(recSize)}</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">+${inverter.motorBufferPct || 10}% buffer${inverter.complianceBuffer ? ' (incl. compliance)' : ''}</div>
                            <div style="font-size: 0.68rem; color: var(--text-muted); margin-top: 2px;">Surge: ${recSurgeCap} VA</div>
                            ${inverter.industrialMinVA ? '<div style="font-size: 0.65rem; color: var(--warning-color); margin-top: 2px;">Industrial min: ' + InverterSizingEngine.formatMarketRange(inverter.industrialMinVA) + '</div>' : ''}
                        </div>
                        <div style="padding: 10px; border-radius: 8px; border: ${this._staggerMotorStarts ? '2px solid var(--success-color)' : '1px solid var(--border-color)'}; background: ${this._staggerMotorStarts ? 'rgba(34,197,94,0.08)' : 'var(--bg-color)'}; text-align: center;">
                            <div style="font-size: 0.72rem; color: var(--success-color); margin-bottom: 3px; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;">Optimized</div>
                            <div style="font-size: 1.1rem; font-weight: 700; color: var(--success-color);">${InverterSizingEngine.formatMarketRange(inverter.staggeredSizeVA)}</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">Surge reduced ~${surgeReduction}%</div>
                            <div style="font-size: 0.68rem; color: var(--text-muted); margin-top: 2px;">Surge: ${staggeredSurgeCap} VA</div>
                        </div>
                    </div>`;

            if (inverter.dominantMotor) {
                html += `
                    <div style="padding: 8px 12px; border-radius: 6px; background: rgba(245,158,11,0.08); border-left: 3px solid var(--warning-color); font-size: 0.82rem; margin-bottom: 8px;">
                        <strong>Biggest surge source:</strong> ${inverter.dominantMotor.name} (${inverter.dominantMotor.watt}W, ${inverter.dominantMotor.surgeFactor}x surge = ~${inverter.dominantMotor.surgeVA} VA peak)<br>
                        <em>Staggering this motor alone drops surge by ~${surgeReduction}%. Consider soft-start or VFD to further reduce to ~2.5x.</em>
                    </div>`;
            }

            if (this._staggerMotorStarts) {
                html += `
                    <div style="padding: 8px 12px; border-radius: 6px; background: rgba(34,197,94,0.06); border-left: 3px solid var(--success-color); font-size: 0.8rem;">
                        <strong style="color: var(--success-color);">Stagger mode active:</strong> Using ${InverterSizingEngine.formatMarketRange(inverter.staggeredSizeVA)}.
                        Start the biggest motor first, wait 30+ seconds, then add others one by one.
                    </div>`;
            } else {
                html += `
                    <div style="padding: 8px 12px; border-radius: 6px; background: rgba(239,68,68,0.04); border-left: 3px solid var(--error-color); font-size: 0.8rem; color: var(--text-muted);">
                        <strong style="color: var(--error-color);">Caution:</strong> The Optimized size (${InverterSizingEngine.formatMarketRange(inverter.staggeredSizeVA)}) requires strict motor staggering.
                        Check the box above only if you commit to never starting two motors simultaneously.
                    </div>`;
            }

            // ── Industrial intelligence section ──
            if (inverter.complianceRisk && inverter.complianceRisk !== 'low') {
                const riskColor = inverter.complianceRisk === 'high' ? 'var(--error-color)' : 'var(--warning-color)';
                const riskBg = inverter.complianceRisk === 'high' ? 'rgba(239,68,68,0.06)' : 'rgba(245,158,11,0.06)';
                const riskLabel = inverter.complianceRisk === 'high' ? 'HIGH' : 'MEDIUM';
                html += `
                    <div style="padding: 10px 12px; border-radius: 6px; background: ${riskBg}; border-left: 3px solid ${riskColor}; font-size: 0.82rem; margin: 8px 0;">
                        <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                            <span style="background: ${riskColor}; color: white; padding: 1px 6px; border-radius: 3px; font-size: 0.7rem; font-weight: 700; letter-spacing: 0.5px;">${riskLabel} COMPLIANCE RISK</span>
                        </div>
                        <div>${inverter.complianceNote}</div>
                        <div style="margin-top: 4px; font-size: 0.78rem; color: var(--text-muted);">
                            The <strong>Recommended</strong> tier already includes a +${inverter.complianceBuffer || 0}% compliance buffer.
                            Some clients will not follow staggering rules — this sizing absorbs that risk without oversizing.
                        </div>
                    </div>`;
            }

            // Servo upgrade advice
            if (inverter.servoUpgradeAdvice) {
                const adv = inverter.servoUpgradeAdvice;
                html += `
                    <div style="padding: 10px 12px; border-radius: 6px; background: rgba(34,197,94,0.06); border-left: 3px solid var(--success-color); font-size: 0.82rem; margin: 8px 0;">
                        <div style="font-weight: 600; color: var(--success-color); margin-bottom: 3px;">Servo Motor Upgrade Opportunity</div>
                        <div>${adv.message}</div>
                    </div>`;
            }

            // Practical rules for industrial setups
            if (inverter.hasIndustrialSewing) {
                html += `
                    <div style="padding: 10px 12px; border-radius: 6px; background: rgba(37,99,235,0.04); border-left: 3px solid var(--primary-color); font-size: 0.8rem; margin: 8px 0;">
                        <div style="font-weight: 600; color: var(--primary-color); margin-bottom: 4px;">Practical Rules for This Setup</div>
                        <ul style="margin: 0; padding-left: 16px; line-height: 1.6;">
                            <li>Never start sewing machine and freezer together — wait 45-60 seconds</li>
                            <li>Run sewing during peak sun (10am-4pm) — draws from panels, saves battery</li>
                            ${inverter.hasCompressor ? '<li>Freezer runs 24/7 — its surge is the real danger (5-7x for 1-2 sec)</li>' : ''}
                            <li>If adding any other motor (pump, AC, bigger fan) later — upgrade to 5kVA</li>
                        </ul>
                    </div>`;
            }

            html += `</div>`;
        } else if (inverter.motorCount >= 2) {
            html += `
                <div style="margin: 8px 0; padding: 10px; font-size: 0.82rem; color: var(--text-muted); border-radius: 6px; background: var(--bg-color);">
                    <strong>Motor note:</strong> You have ${inverter.motorCount} motors. The recommended inverter already handles their combined surge comfortably.
                </div>`;
        }

        // ── Industrial intelligence for single-motor setups (not shown in stagger section) ──
        if (!hasStaggerBenefit && inverter.hasIndustrialSewing) {
            html += `
                <div style="margin: 10px 0; padding: 12px; border: 2px solid var(--warning-color); border-radius: 10px; background: rgba(245,158,11,0.04);">
                    <div style="font-weight: 600; font-size: 0.92rem; margin-bottom: 6px; color: var(--warning-color);">
                        Industrial Sewing Machine Detected
                    </div>`;

            if (inverter.complianceRisk && inverter.complianceRisk !== 'low') {
                html += `
                    <div style="padding: 8px 10px; border-radius: 6px; background: rgba(239,68,68,0.05); border-left: 3px solid var(--error-color); font-size: 0.82rem; margin-bottom: 8px;">
                        <span style="background: var(--error-color); color: white; padding: 1px 6px; border-radius: 3px; font-size: 0.7rem; font-weight: 700;">COMPLIANCE BUFFER APPLIED</span>
                        <div style="margin-top: 4px;">${inverter.complianceNote}</div>
                    </div>`;
            }

            if (inverter.servoUpgradeAdvice) {
                html += `
                    <div style="padding: 8px 10px; border-radius: 6px; background: rgba(34,197,94,0.06); border-left: 3px solid var(--success-color); font-size: 0.82rem; margin-bottom: 8px;">
                        <div style="font-weight: 600; color: var(--success-color); margin-bottom: 2px;">Servo Upgrade Opportunity</div>
                        ${inverter.servoUpgradeAdvice.message}
                    </div>`;
            }

            html += `
                    <div style="padding: 8px 10px; border-radius: 6px; background: rgba(37,99,235,0.04); border-left: 3px solid var(--primary-color); font-size: 0.8rem;">
                        <div style="font-weight: 600; color: var(--primary-color); margin-bottom: 3px;">Practical Rules</div>
                        <ul style="margin: 0; padding-left: 16px; line-height: 1.5;">
                            <li>Never start sewing machine and freezer together — wait 45-60 seconds</li>
                            <li>Run sewing during peak sun (10am-4pm) — draws from panels, saves battery</li>
                            <li>If adding any other motor later — upgrade to 5kVA inverter</li>
                        </ul>
                    </div>
                </div>`;
        }

        // Servo upgrade note for non-industrial setups with clutch motors
        if (!inverter.hasIndustrialSewing && inverter.servoUpgradeAdvice) {
            html += `
                <div style="margin: 8px 0; padding: 10px 12px; border-radius: 6px; background: rgba(34,197,94,0.06); border-left: 3px solid var(--success-color); font-size: 0.82rem;">
                    <div style="font-weight: 600; color: var(--success-color); margin-bottom: 2px;">Servo Motor Upgrade Opportunity</div>
                    ${inverter.servoUpgradeAdvice.message}
                </div>`;
        }

        html += `
                <div class="result-row">
                    <span class="result-label">DC Bus Voltage</span>
                    <span class="result-value">${inverter.dcBusVoltage} V</span>
                </div>
                <div class="result-row">
                    <span class="result-label">DC Input Current (Continuous)</span>
                    <span class="result-value">${inverter.dcInputCurrentContinuous} A</span>
                </div>
                <div class="result-row">
                    <span class="result-label">DC Input Current (Surge)</span>
                    <span class="result-value">${inverter.dcInputCurrentSurge} A</span>
                </div>
            </div>`;

        return html;
    },

    renderBatteryTab(battery) {
        let html = `<div class="results-section">`;

        // Manual override indicator
        if (battery.isManualOverride) {
            html += `
                <div class="alert alert-info" style="margin-bottom: 12px;">
                    <span class="alert-icon">&#128295;</span>
                    <div class="alert-content">
                        <strong>Manual Override Active</strong><br>
                        Your input: <strong>${battery.totalCapacityAh} Ah</strong> |
                        Auto-suggested: <strong>${battery.autoSuggestedAh} Ah</strong>
                        ${battery.totalCapacityAh < battery.autoSuggestedAh
                            ? ` <span style="color: var(--warning-color);">(${Math.round((1 - battery.totalCapacityAh / battery.autoSuggestedAh) * 100)}% less than recommended)</span>`
                            : battery.totalCapacityAh > battery.autoSuggestedAh
                            ? ` <span style="color: var(--success-color);">(extra capacity for longer autonomy)</span>`
                            : ` <span style="color: var(--success-color);">(matches recommendation)</span>`}
                    </div>
                </div>`;
        }

        html += `
                <div class="result-row">
                    <span class="result-label">Chemistry</span>
                    <span class="result-value">${battery.chemistryName}</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Usable Capacity</span>
                    <span class="result-value">${battery.usableCapacityWh} Wh</span>
                </div>
                <div class="result-row" style="background: var(--bg-color); font-weight: bold;">
                    <span class="result-label">${battery.isManualOverride ? 'Your Battery Size' : 'Total Capacity'}</span>
                    <span class="result-value">${battery.totalCapacityAh} Ah @ ${battery.bankVoltage}V</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Total Wh</span>
                    <span class="result-value">${battery.totalCapacityWh} Wh</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Configuration</span>
                    <span class="result-value">${battery.cellsInSeries}S${battery.stringsInParallel}P (${battery.totalCells} cells)</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Recommended Cell Rating</span>
                    <span class="result-value">${battery.recommendedAhPerCell} Ah</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Max Discharge Current</span>
                    <span class="result-value">${battery.maxDischargeCurrent} A</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Max Charge Current</span>
                    <span class="result-value">${battery.maxChargeCurrent} A</span>
                </div>
            </div>`;

        // Required Nominal + Design Basis (engineering transparency)
        if (battery.designBasis && !battery.isManualOverride) {
            const db = battery.designBasis;
            html += `<div style="margin-top: 16px; padding: 12px 14px; border-radius: 8px; background: rgba(37,99,235,0.05); border: 1px solid rgba(37,99,235,0.15);">
                <div style="display: flex; align-items: baseline; gap: 8px; margin-bottom: 6px;">
                    <span style="font-size: 0.78rem; color: var(--text-muted);">Required Nominal Battery Capacity:</span>
                    <span style="font-size: 1.3rem; font-weight: 700; color: var(--primary-color);">${db.requiredNominalKWh} kWh</span>
                </div>
                <div style="font-size: 0.72rem; color: var(--text-muted); line-height: 1.5;">
                    Basis: ${db.dailyLoadWh} Wh/day \u00D7 ${db.autonomyDays} day${db.autonomyDays > 1 ? 's' : ''} autonomy \u00F7 (${Math.round(db.dod * 100)}% DoD \u00D7 ${Math.round(db.dischargeEfficiency * 100)}% eff) \u00D7 ${db.designMargin}% margin
                    <br>Effective usable factor: ${db.effectiveUsableFactor} &mdash; <em>changes automatically with autonomy/DoD/margin settings</em>
                </div>
            </div>`;
        }

        // Module recommendation (lithium only) — driven by required nominal
        if (battery.moduleMatch && battery.isLithium && !battery.isManualOverride) {
            const mm = battery.moduleMatch;
            html += `<div style="margin-top: 10px; padding: 12px 14px; border-radius: 8px; background: rgba(37,99,235,0.06); border: 1px solid rgba(37,99,235,0.2);">
                <div style="font-size: 0.85rem; font-weight: 700; color: var(--primary-color); margin-bottom: 4px;">Recommended Module: ${mm.label}</div>
                <div style="font-size: 0.75rem; color: var(--text-muted);">${mm.note}</div>
                ${mm.stackCount > 1 ? `<div style="font-size: 0.75rem; color: var(--primary-color); margin-top: 3px; font-weight: 600;">${mm.stackCount} units stacked &mdash; standard rack/parallel configuration</div>` : ''}
                <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 3px;">Standard: 51.2V nominal (16S \u00D7 3.2V LiFePO4)</div>
            </div>`;
        }

        // Tiered recommendations (Economy / Balanced / Expansion Ready)
        if (battery.tiers && !battery.isManualOverride) {
            const t = battery.tiers;
            html += `<div style="margin-top: 12px; padding: 14px; border: 1px solid var(--border-color); border-radius: 10px; background: var(--card-bg);">
                <div style="font-weight: 700; font-size: 0.95rem; margin-bottom: 10px; color: var(--text-color);">Battery Sizing Tiers</div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">`;

            const tierData = [
                { tier: t.economy, color: '#d97706', bg: 'rgba(217,119,6,0.08)', border: '#d97706' },
                { tier: t.balanced, color: '#2563eb', bg: 'rgba(37,99,235,0.08)', border: '#2563eb' },
                { tier: t.expansion, color: '#16a34a', bg: 'rgba(22,163,74,0.08)', border: '#16a34a' }
            ];

            tierData.forEach(({ tier, color, bg, border }) => {
                html += `<div style="padding: 10px; border-radius: 8px; border: 2px solid ${tier === t.balanced ? border : 'var(--border-color)'}; background: ${tier === t.balanced ? bg : 'var(--bg-color)'}; text-align: center;">
                    <div style="font-size: 0.68rem; color: ${color}; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 700;">${tier.label}</div>
                    <div style="font-size: 0.82rem; color: var(--text-muted); margin-bottom: 2px;">Nominal: ${tier.nominalKWh} kWh</div>
                    <div style="font-size: 1.15rem; font-weight: 700; color: ${color};">${tier.kWh} kWh</div>
                    <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 3px;">${tier.note}</div>
                    ${tier.module ? `<div style="font-size: 0.72rem; color: ${color}; margin-top: 4px; font-weight: 600;">${tier.module.stackCount > 1 ? tier.module.stackCount + '\u00D7 ' + tier.module.stackUnit.label : tier.module.label}</div>` : ''}
                </div>`;
            });

            html += `</div></div>`;

            // Capacity range bar
            if (battery.capacityRange) {
                const cr = battery.capacityRange;
                html += `<div style="margin-top: 10px; padding: 10px 14px; border-radius: 8px; background: var(--bg-color); border: 1px solid var(--border-color);">
                    <div style="font-size: 0.78rem; color: var(--text-muted); margin-bottom: 6px;">Module Range: ${cr.minKWh} — ${cr.balancedKWh} — ${cr.maxKWh} kWh</div>
                    <div style="height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden; position: relative;">
                        <div style="height: 100%; width: ${Math.min(100, (cr.balanced / cr.max) * 100)}%; background: linear-gradient(90deg, #d97706 0%, #2563eb 60%, #16a34a 100%); border-radius: 4px;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: var(--text-muted); margin-top: 3px;">
                        <span>${cr.minKWh} kWh (Economy)</span>
                        <span>${cr.balancedKWh} kWh (Balanced)</span>
                        <span>${cr.maxKWh} kWh (Expansion)</span>
                    </div>
                </div>`;
            }
        }

        return html;
    },

    renderBatteryConfigTab(battery) {
        const specs = DEFAULTS.BATTERY_SPECS[battery.chemistry] || DEFAULTS.BATTERY_SPECS.lifepo4;

        // Flexible battery unit approach
        const unitVoltage = this.getBatteryUnitVoltage();
        const batteriesInSeries = Math.max(1, Math.round(battery.bankVoltage / unitVoltage));
        const isLithiumConfig = battery.chemistry === 'lifepo4';
        // For lithium: merge cell ratings + module Ah values, dedupe and sort
        const availableAh = isLithiumConfig
            ? [...new Set([...DEFAULTS.LIFEPO4_CELL_RATINGS, ...DEFAULTS.LITHIUM_MODULES.catalog.map(m => m.ah)])].sort((a, b) => a - b)
            : [100, 200, 220, 230];
        // Priority: button click > form dropdown > auto-pick
        const formAh = this.getBatteryUnitAh(null);
        const selectedAh = this._selectedBatteryUnitAh || formAh || this.pickClosestAh(battery.totalCapacityAh, availableAh);
        this._selectedBatteryUnitAh = selectedAh;
        const parallelStrings = Math.ceil(battery.totalCapacityAh / selectedAh);
        const totalBatteries = batteriesInSeries * parallelStrings;
        const actualBankAh = parallelStrings * selectedAh;
        const actualBankWh = actualBankAh * battery.bankVoltage;

        let html = '<div class="results-section">';

        // Module Quick-Pick for LiFePO4 — clickable market modules
        if (isLithiumConfig) {
            const modules = DEFAULTS.LITHIUM_MODULES.catalog;
            const isModuleAh = modules.some(m => m.ah === selectedAh);
            html += `
                <div style="margin-bottom: 12px; padding: 14px; background: rgba(37,99,235,0.04); border: 1px solid rgba(37,99,235,0.15); border-radius: 8px;">
                    <div style="font-weight: 700; font-size: 0.85rem; color: var(--primary-color); margin-bottom: 8px;">Module Quick-Pick (51.2V LiFePO4)</div>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        ${modules.map(m => {
                            const active = m.ah === selectedAh && unitVoltage === 51.2;
                            return `<button onclick="PVCalculator.selectBatteryUnitAh(${m.ah});PVCalculator.selectBatteryUnitVoltage(51.2)"
                                style="padding: 6px 10px; border: 2px solid ${active ? 'var(--primary-color)' : 'var(--border-color)'}; border-radius: 6px; background: ${active ? 'var(--primary-color)' : 'var(--card-bg)'}; color: ${active ? '#fff' : 'var(--text-color)'}; cursor: pointer; font-size: 0.78rem; transition: all 0.15s; line-height: 1.3; text-align: center;">
                                <strong>${m.kWh}kWh</strong><br><span style="font-size: 0.7rem; opacity: 0.8;">${m.ah}Ah</span>
                            </button>`;
                        }).join('')}
                    </div>
                    <div style="font-size: 0.72rem; color: var(--text-muted); margin-top: 6px;">Click a module to auto-set Ah + 51.2V. Use Ah/Voltage rows below for custom configs.</div>
                </div>`;
        }

        // Battery unit quick-select controls (Ah + Voltage) — fully interactive
        const isCustomAh = !availableAh.includes(selectedAh) && !(isLithiumConfig && DEFAULTS.LITHIUM_MODULES.catalog.some(m => m.ah === selectedAh));
        const commonVolts = isLithiumConfig ? [12, 24, 48, 51.2] : [6, 12, 24, 48];
        const isCustomV = !commonVolts.includes(unitVoltage);
        html += `
            <div style="margin-bottom: 16px; padding: 14px; background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap; margin-bottom: 10px;">
                    <label style="font-weight: 600; white-space: nowrap; min-width: 60px;">Ah:</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap; align-items: center;">
                        ${availableAh.map(ah => `
                            <button onclick="PVCalculator.selectBatteryUnitAh(${ah})"
                                style="padding: 6px 14px; border: 2px solid ${ah === selectedAh ? 'var(--primary-color)' : 'var(--border-color)'}; border-radius: 6px; background: ${ah === selectedAh ? 'var(--primary-color)' : 'var(--card-bg)'}; color: ${ah === selectedAh ? '#fff' : 'var(--text-color)'}; cursor: pointer; font-weight: ${ah === selectedAh ? '700' : '400'}; font-size: 0.88rem; transition: all 0.15s;">
                                ${ah}
                            </button>
                        `).join('')}
                        <div style="display: flex; align-items: center; gap: 4px; margin-left: 4px;">
                            <input type="number" id="battConfigCustomAh" placeholder="Custom" min="10" max="2000" step="1"
                                value="${isCustomAh ? selectedAh : ''}"
                                style="width: 72px; padding: 6px 8px; border: 2px solid ${isCustomAh ? 'var(--primary-color)' : 'var(--border-color)'}; border-radius: 6px; font-size: 0.88rem; background: ${isCustomAh ? 'var(--primary-color)' : 'var(--card-bg)'}; color: ${isCustomAh ? '#fff' : 'var(--text-color)'}; text-align: center;"
                                oninput="if(this.value>0) PVCalculator.selectBatteryUnitAh(parseInt(this.value))"
                                onfocus="this.select()">
                            <span style="font-size: 0.82rem; color: var(--text-muted);">Ah</span>
                        </div>
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap; margin-bottom: 10px;">
                    <label style="font-weight: 600; white-space: nowrap; min-width: 60px;">Voltage:</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap; align-items: center;">
                        ${commonVolts.map(v => `
                            <button onclick="PVCalculator.selectBatteryUnitVoltage(${v})"
                                style="padding: 6px 14px; border: 2px solid ${v === unitVoltage ? '#2563eb' : 'var(--border-color)'}; border-radius: 6px; background: ${v === unitVoltage ? '#2563eb' : 'var(--card-bg)'}; color: ${v === unitVoltage ? '#fff' : 'var(--text-color)'}; cursor: pointer; font-weight: ${v === unitVoltage ? '700' : '400'}; font-size: 0.88rem; transition: all 0.15s;">
                                ${v}V
                            </button>
                        `).join('')}
                        <div style="display: flex; align-items: center; gap: 4px; margin-left: 4px;">
                            <input type="number" id="battConfigCustomV" placeholder="Custom" min="1" max="60" step="0.1"
                                value="${isCustomV ? unitVoltage : ''}"
                                style="width: 72px; padding: 6px 8px; border: 2px solid ${isCustomV ? '#2563eb' : 'var(--border-color)'}; border-radius: 6px; font-size: 0.88rem; background: ${isCustomV ? '#2563eb' : 'var(--card-bg)'}; color: ${isCustomV ? '#fff' : 'var(--text-color)'}; text-align: center;"
                                oninput="if(this.value>0) PVCalculator.selectBatteryUnitVoltage(parseFloat(this.value))"
                                onfocus="this.select()">
                            <span style="font-size: 0.82rem; color: var(--text-muted);">V</span>
                        </div>
                    </div>
                </div>
                <div style="font-size: 0.82rem; color: var(--text-muted); padding-top: 4px; border-top: 1px solid var(--border-color);">
                    Active: <strong>${unitVoltage}V / ${selectedAh}Ah</strong> per unit &bull;
                    ${batteriesInSeries}S &times; ${parallelStrings}P = ${totalBatteries} units &bull;
                    Bank: ${battery.bankVoltage}V / ${actualBankAh}Ah
                </div>
            </div>
        `;

        // Header summary
        html += `
            <div class="result-row" style="background: var(--bg-color); font-weight: bold;">
                <span class="result-label">Bank Configuration</span>
                <span class="result-value">${batteriesInSeries}S x ${parallelStrings}P = ${totalBatteries} batteries</span>
            </div>
            <div class="result-row" style="background: var(--bg-color); font-weight: bold;">
                <span class="result-label">Total Bank Capacity</span>
                <span class="result-value">${actualBankAh}Ah @ ${battery.bankVoltage}V (${actualBankWh.toLocaleString()} Wh)</span>
            </div>
        `;

        // Battery-level specs
        html += `
            <div class="result-row">
                <span class="result-label">Chemistry</span>
                <span class="result-value">${battery.chemistryName}</span>
            </div>
            <div class="result-row">
                <span class="result-label">Each Battery Unit</span>
                <span class="result-value">${unitVoltage}V / ${selectedAh}Ah</span>
            </div>
            <div class="result-row">
                <span class="result-label">Units in Series</span>
                <span class="result-value">${batteriesInSeries} (${batteriesInSeries} x ${unitVoltage}V = ${batteriesInSeries * unitVoltage}V)</span>
            </div>
            <div class="result-row">
                <span class="result-label">Parallel Strings</span>
                <span class="result-value">${parallelStrings} (${parallelStrings} x ${selectedAh}Ah = ${actualBankAh}Ah)</span>
            </div>
            <div class="result-row">
                <span class="result-label">Total Units to Buy</span>
                <span class="result-value"><strong>${totalBatteries}</strong> x ${unitVoltage}V ${selectedAh}Ah</span>
            </div>
        `;

        // Capacity check vs requirement
        const requiredAh = battery.totalCapacityAh;
        const capacityMatch = actualBankAh >= requiredAh;
        const surplus = actualBankAh - requiredAh;
        html += `
            <div class="result-row" style="background: ${capacityMatch ? 'rgba(34,197,94,0.08)' : 'rgba(239,68,68,0.08)'};">
                <span class="result-label">Required vs Actual</span>
                <span class="result-value" style="color: ${capacityMatch ? 'var(--success-color)' : 'var(--error-color)'};">
                    Need ${requiredAh}Ah — Have ${actualBankAh}Ah
                    ${surplus > 0 ? `(+${Math.round(surplus)}Ah surplus)` : surplus === 0 ? '(exact match)' : `(${Math.round(surplus)}Ah short)`}
                </span>
            </div>
        `;

        // Charge/discharge specs
        html += `
            <div class="result-row">
                <span class="result-label">Max Charge Rate</span>
                <span class="result-value">${(specs.maxChargeRate * 100).toFixed(0)}% C-rate = ${battery.maxChargeCurrent}A</span>
            </div>
            <div class="result-row">
                <span class="result-label">Max Discharge Rate</span>
                <span class="result-value">${(specs.maxDischargeRate * 100).toFixed(0)}% C-rate = ${battery.maxDischargeCurrent}A</span>
            </div>
            <div class="result-row">
                <span class="result-label">Max Depth of Discharge</span>
                <span class="result-value">${(specs.maxDoD * 100).toFixed(0)}%</span>
            </div>
            <div class="result-row">
                <span class="result-label">Usable Capacity</span>
                <span class="result-value">${Math.round(actualBankWh * specs.maxDoD)} Wh (${(specs.maxDoD * 100).toFixed(0)}% of ${actualBankWh.toLocaleString()} Wh)</span>
            </div>
            <div class="result-row">
                <span class="result-label">Expected Cycle Life</span>
                <span class="result-value">${specs.cycleLife.toLocaleString()} cycles</span>
            </div>
            <div class="result-row">
                <span class="result-label">Round-trip Efficiency</span>
                <span class="result-value">${(specs.chargeEfficiency * specs.dischargeEfficiency * 100).toFixed(1)}%</span>
            </div>
        `;

        // SVG Diagram
        html += `
            <h3 style="margin-top: 20px;">Battery Wiring Diagram</h3>
            <small style="color: var(--text-muted); display: block; margin-bottom: 8px;">
                Each box represents one ${unitVoltage}V/${selectedAh}Ah battery unit.
                Batteries in a row are wired in series (+ to \u2212) for voltage.
                Rows are wired in parallel (+ to +, \u2212 to \u2212) for capacity.
            </small>
        `;

        html += this.renderBatteryConfigSVG(batteriesInSeries, parallelStrings, battery.bankVoltage, selectedAh, actualBankAh, unitVoltage);

        // Wiring notes
        html += `
            <div style="margin-top: 16px; padding: 12px; background: var(--card-bg); border-radius: 6px; border-left: 3px solid var(--primary-color); font-size: 0.85em;">
                <strong>Wiring Notes:</strong>
                <ul style="margin: 6px 0 0 0; padding-left: 18px;">
                    <li><strong>Series:</strong> Connect + terminal of one battery to \u2212 terminal of the next. ${batteriesInSeries} batteries x ${unitVoltage}V = ${battery.bankVoltage}V</li>
                    ${parallelStrings > 1 ? `<li><strong>Parallel:</strong> Join all string + terminals together and all string \u2212 terminals together. ${parallelStrings} strings x ${selectedAh}Ah = ${actualBankAh}Ah</li>` : ''}
                    <li><strong>Balancing:</strong> ${battery.chemistry === 'lifepo4' ? 'Use a BMS (Battery Management System) with cell balancing for LiFePO4' : 'Use identical batteries (same brand, age, and Ah). Charge equally before first parallel connection'}</li>
                    ${parallelStrings > 1 ? '<li><strong>Fusing:</strong> Install a fuse on each parallel string for short-circuit protection</li>' : ''}
                    <li><strong>Cables:</strong> Use equal-length cables for all parallel connections to ensure balanced current sharing</li>
                </ul>
            </div>
        `;

        html += '</div>';
        return html;
    },

    /**
     * Pick the closest standard Ah that meets capacity with fewest batteries
     */
    pickClosestAh(requiredAh, availableAh) {
        // Try each size, pick the one that needs fewest total batteries while meeting capacity
        let best = availableAh[availableAh.length - 1];
        let bestStrings = Infinity;
        for (const ah of availableAh) {
            const strings = Math.ceil(requiredAh / ah);
            if (strings <= bestStrings) {
                bestStrings = strings;
                best = ah;
            }
        }
        return best;
    },

    /**
     * Handle battery unit Ah selection change — re-renders the Batt Config tab
     */
    selectBatteryUnitAh(ah) {
        this._selectedBatteryUnitAh = ah;
        // Sync the form dropdown so it matches
        const sel = document.getElementById('batteryUnitAh');
        if (sel) {
            const match = [...sel.options].find(o => o.value === String(ah));
            if (match) {
                sel.value = String(ah);
                const customInput = document.getElementById('batteryUnitAhCustom');
                if (customInput) customInput.style.display = 'none';
            } else {
                sel.value = 'custom';
                const customInput = document.getElementById('batteryUnitAhCustom');
                if (customInput) { customInput.style.display = 'block'; customInput.value = ah; }
            }
        }
        this._refreshBatteryTabs();
    },

    selectBatteryUnitVoltage(v) {
        this._selectedBatteryUnitVoltage = v;
        // Sync the form dropdown
        const sel = document.getElementById('batteryUnitVoltage');
        if (sel) {
            const match = [...sel.options].find(o => o.value === String(v));
            if (match) {
                sel.value = String(v);
                const customInput = document.getElementById('batteryUnitVoltageCustom');
                if (customInput) customInput.style.display = 'none';
            } else {
                sel.value = 'custom';
                const customInput = document.getElementById('batteryUnitVoltageCustom');
                if (customInput) { customInput.style.display = 'block'; customInput.value = v; }
            }
        }
        this._refreshBatteryTabs();
    },

    // Get the effective battery unit voltage from the form
    getBatteryUnitVoltage() {
        const sel = document.getElementById('batteryUnitVoltage');
        if (!sel) return this._selectedBatteryUnitVoltage || 12;
        if (sel.value === 'custom') {
            const custom = parseFloat(document.getElementById('batteryUnitVoltageCustom')?.value);
            return (custom && custom > 0) ? custom : (this._selectedBatteryUnitVoltage || 12);
        }
        return parseFloat(sel.value) || 12;
    },

    // Get the effective battery unit Ah from the form
    getBatteryUnitAh(fallbackAh) {
        const sel = document.getElementById('batteryUnitAh');
        if (!sel) return this._selectedBatteryUnitAh || fallbackAh || 200;
        if (sel.value === 'auto') return null; // auto mode
        if (sel.value === 'custom') {
            const custom = parseInt(document.getElementById('batteryUnitAhCustom')?.value);
            return (custom && custom > 0) ? custom : (this._selectedBatteryUnitAh || fallbackAh || 200);
        }
        return parseInt(sel.value) || 200;
    },

    onBatteryUnitAhChange() {
        const sel = document.getElementById('batteryUnitAh');
        const customInput = document.getElementById('batteryUnitAhCustom');
        if (sel && customInput) {
            customInput.style.display = sel.value === 'custom' ? 'block' : 'none';
        }
        if (sel && sel.value !== 'custom' && sel.value !== 'auto') {
            this._selectedBatteryUnitAh = parseInt(sel.value);
            this._refreshBatteryTabs();
        } else if (sel && sel.value === 'auto') {
            this._selectedBatteryUnitAh = null;
            this._refreshBatteryTabs();
        }
    },

    onBatteryCustomAhInput() {
        const val = parseInt(document.getElementById('batteryUnitAhCustom')?.value);
        if (val && val > 0) {
            this._selectedBatteryUnitAh = val;
            this._refreshBatteryTabs();
        }
    },

    onBatteryUnitVoltageChange() {
        const sel = document.getElementById('batteryUnitVoltage');
        const customInput = document.getElementById('batteryUnitVoltageCustom');
        if (sel && customInput) {
            customInput.style.display = sel.value === 'custom' ? 'block' : 'none';
        }
        if (sel && sel.value !== 'custom') {
            this._selectedBatteryUnitVoltage = parseFloat(sel.value);
            this._refreshBatteryTabs();
        }
    },

    onBatteryCustomVoltageInput() {
        const val = parseFloat(document.getElementById('batteryUnitVoltageCustom')?.value);
        if (val && val > 0) {
            this._selectedBatteryUnitVoltage = val;
            this._refreshBatteryTabs();
        }
    },

    _refreshBatteryTabs() {
        if (this.results && this.results.battery) {
            const battConfig = document.getElementById('tab-battconfig');
            if (battConfig) battConfig.innerHTML = this.renderBatteryConfigTab(this.results.battery);
            const overview = document.getElementById('tab-overview');
            if (overview) overview.innerHTML = this.renderOverviewTab(this.results);
        }
    },

    onBatteryChemistryChange() {
        const chem = document.getElementById('batteryChemistry')?.value;
        const kwhSection = document.getElementById('lithiumKwhSection');
        if (kwhSection) {
            kwhSection.style.display = (chem === 'lifepo4') ? 'flex' : 'none';
        }
        // Clear kWh field when switching away from lithium
        if (chem !== 'lifepo4') {
            const kwhInput = document.getElementById('batteryKwhInput');
            if (kwhInput) kwhInput.value = '';
            const resultDiv = document.getElementById('batteryKwhToAhResult');
            if (resultDiv) resultDiv.textContent = '\u2014';
        }
    },

    onBatteryKwhInput() {
        const kwhVal = parseFloat(document.getElementById('batteryKwhInput')?.value);
        const resultDiv = document.getElementById('batteryKwhToAhResult');
        if (!kwhVal || kwhVal <= 0) {
            if (resultDiv) resultDiv.textContent = '\u2014';
            return;
        }
        // Calculate Ah from kWh using bank voltage (from config or default 48V for lithium)
        const config = this.getConfig();
        const bankVoltage = config.batteryBankVoltage || 48;
        const ah = Math.round((kwhVal * 1000) / bankVoltage);
        if (resultDiv) resultDiv.textContent = `${ah} Ah (at ${bankVoltage}V bank)`;

        // Auto-set the Ah field to match
        const ahSelect = document.getElementById('batteryUnitAh');
        const ahCustom = document.getElementById('batteryUnitAhCustom');
        if (ahSelect) {
            // Check if this matches a standard option
            const unitV = this.getBatteryUnitVoltage();
            const unitsInSeries = Math.max(1, Math.round(bankVoltage / unitV));
            const perUnitAh = ah; // bank Ah = per-unit Ah (parallel strings handle the rest)
            const standardOpts = [100, 200, 220, 230];
            const match = standardOpts.find(o => o === perUnitAh);
            if (match) {
                ahSelect.value = String(match);
                if (ahCustom) ahCustom.style.display = 'none';
            } else {
                ahSelect.value = 'custom';
                if (ahCustom) {
                    ahCustom.style.display = 'block';
                    ahCustom.value = perUnitAh;
                }
            }
            this._selectedBatteryUnitAh = perUnitAh;
            this._refreshBatteryTabs();
        }
    },

    /**
     * Generate SVG diagram of battery bank using real 12V battery units
     */
    renderBatteryConfigSVG(seriesCount, parallelCount, bankVoltage, unitAh, totalAh, unitVoltage) {
        unitVoltage = unitVoltage || 12;
        const battW = 100;
        const battH = 56;
        const gapX = 20;
        const gapY = 24;
        const padX = 48;
        const padY = 44;

        const svgW = padX * 2 + seriesCount * battW + (seriesCount - 1) * gapX;
        const svgH = padY + parallelCount * battH + (parallelCount - 1) * gapY + 56;

        let svg = `<svg viewBox="0 0 ${svgW} ${svgH}" style="width: 100%; max-width: ${Math.min(svgW, 580)}px; height: auto; background: #f0fdf4; border: 2px solid #22c55e; border-radius: 8px; margin: 8px auto; display: block;">`;

        // Title
        svg += `<text x="${svgW/2}" y="22" text-anchor="middle" font-size="12" font-weight="bold" fill="#15803d">${seriesCount}S x ${parallelCount}P = ${seriesCount * parallelCount} Batteries | ${bankVoltage}V / ${totalAh}Ah</text>`;

        const startY = padY;

        // Draw battery rows
        for (let row = 0; row < parallelCount; row++) {
            const y = startY + row * (battH + gapY);

            // String label on far left
            if (parallelCount > 1) {
                svg += `<text x="6" y="${y + battH/2 + 4}" font-size="9" fill="#666" font-weight="bold">String ${row + 1}</text>`;
            }

            for (let col = 0; col < seriesCount; col++) {
                const x = padX + col * (battW + gapX);

                // Battery body — rounded rect
                svg += `<rect x="${x}" y="${y}" width="${battW}" height="${battH}" rx="6" fill="#dcfce7" stroke="#16a34a" stroke-width="2"/>`;

                // Battery terminal bumps (+ left, - right)
                svg += `<rect x="${x - 3}" y="${y + battH/2 - 6}" width="6" height="12" rx="2" fill="#dc2626"/>`;
                svg += `<rect x="${x + battW - 3}" y="${y + battH/2 - 6}" width="6" height="12" rx="2" fill="#2563eb"/>`;

                // Labels inside battery
                svg += `<text x="${x + battW/2}" y="${y + 20}" text-anchor="middle" font-size="13" fill="#15803d" font-weight="bold">${unitVoltage}V</text>`;
                svg += `<text x="${x + battW/2}" y="${y + 36}" text-anchor="middle" font-size="11" fill="#555">${unitAh}Ah</text>`;
                svg += `<text x="${x + battW/2}" y="${y + 50}" text-anchor="middle" font-size="8" fill="#999">B${row * seriesCount + col + 1}</text>`;

                // Terminal labels
                svg += `<text x="${x + 1}" y="${y + battH/2 - 10}" text-anchor="middle" font-size="9" fill="#dc2626" font-weight="bold">+</text>`;
                svg += `<text x="${x + battW - 1}" y="${y + battH/2 - 10}" text-anchor="middle" font-size="9" fill="#2563eb" font-weight="bold">\u2212</text>`;

                // Series connection wire (between batteries in same row)
                if (col < seriesCount - 1) {
                    const x1 = x + battW + 3;
                    const x2 = x + battW + gapX - 3;
                    const lineY = y + battH / 2;
                    svg += `<line x1="${x1}" y1="${lineY}" x2="${x2}" y2="${lineY}" stroke="#f59e0b" stroke-width="3" stroke-linecap="round"/>`;
                }
            }
        }

        // Parallel bus bars (if more than 1 string)
        if (parallelCount > 1) {
            const busLeftX = padX - 14;
            const busRightX = padX + (seriesCount - 1) * (battW + gapX) + battW + 14;
            const topY = startY + battH / 2;
            const bottomY = startY + (parallelCount - 1) * (battH + gapY) + battH / 2;

            // Positive bus (left side)
            svg += `<line x1="${busLeftX}" y1="${topY}" x2="${busLeftX}" y2="${bottomY}" stroke="#dc2626" stroke-width="4" stroke-linecap="round"/>`;
            for (let row = 0; row < parallelCount; row++) {
                const y = startY + row * (battH + gapY) + battH / 2;
                svg += `<line x1="${busLeftX}" y1="${y}" x2="${padX - 3}" y2="${y}" stroke="#dc2626" stroke-width="2.5" stroke-linecap="round"/>`;
            }

            // Negative bus (right side)
            svg += `<line x1="${busRightX}" y1="${topY}" x2="${busRightX}" y2="${bottomY}" stroke="#2563eb" stroke-width="4" stroke-linecap="round"/>`;
            for (let row = 0; row < parallelCount; row++) {
                const y = startY + row * (battH + gapY) + battH / 2;
                const lastBattRight = padX + (seriesCount - 1) * (battW + gapX) + battW + 3;
                svg += `<line x1="${lastBattRight}" y1="${y}" x2="${busRightX}" y2="${y}" stroke="#2563eb" stroke-width="2.5" stroke-linecap="round"/>`;
            }

            // Bus labels
            svg += `<text x="${busLeftX}" y="${bottomY + 18}" text-anchor="middle" font-size="9" fill="#dc2626" font-weight="bold">+ BUS</text>`;
            svg += `<text x="${busRightX}" y="${bottomY + 18}" text-anchor="middle" font-size="9" fill="#2563eb" font-weight="bold">\u2212 BUS</text>`;
        }

        // Bottom summary
        svg += `<text x="${svgW/2}" y="${svgH - 8}" text-anchor="middle" font-size="10" fill="#555">`;
        svg += `${seriesCount} in series = ${bankVoltage}V`;
        if (parallelCount > 1) svg += `  |  ${parallelCount} parallel = ${totalAh}Ah`;
        svg += `</text>`;

        svg += '</svg>';
        return svg;
    },

    renderPVTab(pvArray) {
        let html = `
            <div class="results-section">
                <div class="result-row" style="background: var(--bg-color); font-weight: bold;">
                    <span class="result-label">Array Configuration</span>
                    <span class="result-value">${pvArray.panelsInSeries}S x ${pvArray.stringsInParallel}P = ${pvArray.totalPanels} panels</span>
                </div>
                <div class="result-row" style="background: var(--bg-color); font-weight: bold;">
                    <span class="result-label">Total Array Wattage</span>
                    <span class="result-value">${pvArray.arrayWattage} Wp</span>
                </div>
                <div class="result-row">
                    <span class="result-label">String Vmp</span>
                    <span class="result-value">${pvArray.stringVmp} V</span>
                </div>
                <div class="result-row">
                    <span class="result-label">String Voc</span>
                    <span class="result-value">${pvArray.stringVoc} V</span>
                </div>
                <div class="result-row">
                    <span class="result-label">String Voc (Cold)</span>
                    <span class="result-value">${pvArray.stringVocCold} V</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Array Imp</span>
                    <span class="result-value">${pvArray.arrayImp} A</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Array Isc</span>
                    <span class="result-value">${pvArray.arrayIsc} A</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Derated Output (Hot)</span>
                    <span class="result-value">${pvArray.deratedOutput} W</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Daily Energy Production</span>
                    <span class="result-value">${pvArray.dailyEnergyWh} Wh</span>
                </div>`;

        // ── Dynamic charge & daytime load analysis ──
        const psh = this.results?.config?.avgPSH || 4.5;
        const realisticPVOutput = pvArray.arrayWattage * 0.80; // realistic derated output
        const battBankVoltage = this.results?.battery?.bankVoltage || 48;
        const battCapacityAh = this.results?.battery?.totalCapacityAh || 100;
        const battUsableWh = this.results?.battery?.usableCapacityWh || (battCapacityAh * battBankVoltage * 0.5);
        const chargeEfficiency = 0.92; // battery charge efficiency

        if (pvArray.pvAccountForDaytimeLoad && pvArray.daytimeLoadWh > 0) {
            // Calculate: what power goes to loads vs charging during peak sun
            const avgDaytimeLoadW = pvArray.daytimeLoadWh / psh;
            const netChargePowerW = Math.max(realisticPVOutput - avgDaytimeLoadW, 0);
            const netChargeCurrentA = netChargePowerW / battBankVoltage;
            const chargeTimeFromEmpty = battCapacityAh / (netChargeCurrentA * chargeEfficiency);
            const dailyChargeWh = netChargePowerW * psh * chargeEfficiency;
            const canFullChargeInDay = chargeTimeFromEmpty <= psh;
            const pvUtilization = Math.round(avgDaytimeLoadW / realisticPVOutput * 100);

            html += `
                <div class="result-row" style="border-left: 3px solid var(--primary-color); padding-left: 12px;">
                    <span class="result-label">Includes Daytime Load</span>
                    <span class="result-value">${pvArray.daytimeLoadWh} Wh</span>
                </div>
                <div style="margin: 8px 0; padding: 12px; border-radius: 8px; border: 1px solid var(--primary-color); background: rgba(37,99,235,0.03); font-size: 0.82rem;">
                    <div style="font-weight: 600; color: var(--primary-color); margin-bottom: 6px;">PV Power Split During Peak Sun (${psh}h)</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                        <div style="text-align: center; padding: 6px; background: rgba(37,99,235,0.06); border-radius: 6px;">
                            <div style="font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase;">PV Output</div>
                            <div style="font-size: 1rem; font-weight: 700; color: var(--primary-color);">~${Math.round(realisticPVOutput)}W</div>
                        </div>
                        <div style="text-align: center; padding: 6px; background: rgba(245,158,11,0.06); border-radius: 6px;">
                            <div style="font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase;">To Loads</div>
                            <div style="font-size: 1rem; font-weight: 700; color: var(--warning-color);">~${Math.round(avgDaytimeLoadW)}W</div>
                            <div style="font-size: 0.65rem; color: var(--text-muted);">${pvUtilization}% of PV</div>
                        </div>
                        <div style="text-align: center; padding: 6px; background: rgba(34,197,94,0.06); border-radius: 6px;">
                            <div style="font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase;">To Battery</div>
                            <div style="font-size: 1rem; font-weight: 700; color: var(--success-color);">~${Math.round(netChargePowerW)}W</div>
                            <div style="font-size: 0.65rem; color: var(--text-muted);">${Math.round(netChargeCurrentA)}A @ ${battBankVoltage}V</div>
                        </div>
                    </div>
                    <div style="font-size: 0.8rem; line-height: 1.5;">
                        ${netChargePowerW > 50
                            ? `<strong style="color: var(--success-color);">Simultaneous charging confirmed.</strong>
                               PV can power daytime loads <strong>and</strong> send ~${Math.round(netChargePowerW)}W to the battery.
                               <br>Estimated charge time from empty: <strong>${chargeTimeFromEmpty.toFixed(1)} hours</strong> of peak sun.
                               ${canFullChargeInDay
                                   ? ` With ${psh}h peak sun available — <strong style="color: var(--success-color);">battery can fully recharge in a single sunny day.</strong>`
                                   : ` With only ${psh}h peak sun — <strong style="color: var(--warning-color);">may need ${Math.ceil(chargeTimeFromEmpty / psh)} sunny days</strong> for full recharge from empty. Keep heavy loads off until battery is above 60%.`}
                               <br>Daily charge delivery: ~${Math.round(dailyChargeWh)} Wh (${Math.round(dailyChargeWh / battUsableWh * 100)}% of usable battery capacity).`
                            : `<strong style="color: var(--error-color);">Warning: PV barely covers daytime loads.</strong>
                               Net charging power is only ~${Math.round(netChargePowerW)}W — battery will charge very slowly during sun hours.
                               <br><strong>Reduce daytime loads</strong> or <strong>add more panels</strong> to ensure proper charging.
                               Estimated charge time from empty: <strong>${chargeTimeFromEmpty > 100 ? '10+ days' : chargeTimeFromEmpty.toFixed(1) + ' hours'}</strong> — unacceptable for reliable operation.`}
                    </div>
                </div>`;
        } else if (!pvArray.pvAccountForDaytimeLoad) {
            // Checkbox unchecked — panels only charge batteries
            const chargeOnlyPowerW = realisticPVOutput;
            const chargeOnlyCurrentA = chargeOnlyPowerW / battBankVoltage;
            const chargeOnlyTime = battCapacityAh / (chargeOnlyCurrentA * chargeEfficiency);
            const canChargeInDay = chargeOnlyTime <= psh;
            const dailyChargeWh = chargeOnlyPowerW * psh * chargeEfficiency;

            // But what happens if loads actually run during the day?
            const avgDaytimeLoadW = (this.results?.aggregation?.daytimeEnergyWh || 0) / psh;
            const netIfLoadsRun = Math.max(chargeOnlyPowerW - avgDaytimeLoadW, 0);
            const actualChargeTime = avgDaytimeLoadW > 0 ? battCapacityAh / ((netIfLoadsRun / battBankVoltage) * chargeEfficiency) : chargeOnlyTime;

            html += `
                <div style="margin: 8px 0; padding: 12px; border-radius: 8px; border: 2px solid var(--warning-color); background: rgba(245,158,11,0.04); font-size: 0.82rem;">
                    <div style="font-weight: 600; color: var(--warning-color); margin-bottom: 6px;">Daytime Load NOT Included in PV Sizing</div>
                    <div style="margin-bottom: 8px;">
                        Panels are sized <strong>only for battery charging</strong> — all ${Math.round(realisticPVOutput)}W goes to battery.
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                        <div style="padding: 8px; background: rgba(34,197,94,0.06); border-radius: 6px; text-align: center;">
                            <div style="font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase;">Charge Only (No Loads)</div>
                            <div style="font-size: 1rem; font-weight: 700; color: var(--success-color);">${chargeOnlyTime.toFixed(1)}h</div>
                            <div style="font-size: 0.68rem; color: var(--text-muted);">${Math.round(chargeOnlyCurrentA)}A @ ${battBankVoltage}V</div>
                            <div style="font-size: 0.65rem; color: var(--text-muted);">${canChargeInDay ? 'Full charge in 1 sunny day' : Math.ceil(chargeOnlyTime / psh) + ' sunny days needed'}</div>
                        </div>
                        <div style="padding: 8px; background: rgba(239,68,68,0.06); border-radius: 6px; text-align: center;">
                            <div style="font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase;">Reality (Loads Running)</div>
                            <div style="font-size: 1rem; font-weight: 700; color: var(--error-color);">${actualChargeTime > 100 ? '10+' : actualChargeTime.toFixed(1)}h</div>
                            <div style="font-size: 0.68rem; color: var(--text-muted);">Loads steal ~${Math.round(avgDaytimeLoadW)}W from PV</div>
                            <div style="font-size: 0.65rem; color: var(--error-color);">${avgDaytimeLoadW > realisticPVOutput * 0.8 ? 'Battery may drain DURING sun!' : 'Slow charge — battery at risk'}</div>
                        </div>
                    </div>
                    <div style="font-size: 0.8rem; line-height: 1.5; color: var(--text-color);">
                        <strong style="color: var(--error-color);">Problem:</strong> If you run appliances during sunshine, they draw from the battery <em>and</em> steal PV power meant for charging.
                        Your array wasn't sized for this — charge time stretches from <strong>${chargeOnlyTime.toFixed(1)}h</strong> to <strong>${actualChargeTime > 100 ? '10+' : actualChargeTime.toFixed(1)}h</strong>.
                        <br><strong>Recommendation:</strong> Enable "Size PV array to also power daytime loads" for reliable daily recharge, or strictly avoid heavy loads during sun hours.
                    </div>
                </div>`;
        }

        html += `</div>`;
        return html;
    },

    renderCablesTab(cables) {
        const renderCableRun = (run, showBorder) => {
            const parallelLabel = run.parallelCables > 1 ? ` × ${run.parallelCables} runs` : '';

            // Primary display: market-standard size with range
            const marketSize = run.marketMm2 || run.recommendedMm2;
            const computedSize = run.recommendedMm2;
            const isSame = marketSize === computedSize;
            const marketAmp = run.marketAmpacity || 0;
            const ampBadge = marketAmp > 0 ? ` <span style="font-size: 0.85em; opacity: 0.75;">(${marketAmp}A rated)</span>` : '';

            // Build size display: range format when computed differs from market
            let sizeDisplay;
            if (isSame) {
                sizeDisplay = `<strong>${marketSize}mm²</strong> (${run.recommendedAWG} AWG)${parallelLabel}`;
            } else {
                sizeDisplay = `<strong>${computedSize} – ${marketSize}mm²</strong> (${run.recommendedAWG} AWG)${parallelLabel}`;
            }

            const borderStyle = showBorder ? 'border-bottom: 1px solid var(--border-color);' : '';
            return `
                <div style="margin-bottom: 12px; padding-bottom: 12px; ${borderStyle}">
                    <strong>${run.name}</strong>
                    <div class="result-row">
                        <span class="result-label">Cable Size</span>
                        <span class="result-value">${sizeDisplay}</span>
                    </div>
                    <div class="result-row">
                        <span class="result-label">Buy</span>
                        <span class="result-value"><strong>${marketSize}mm²</strong> metric cable${ampBadge}</span>
                    </div>
                    <div class="result-row">
                        <span class="result-label">Operating Current</span>
                        <span class="result-value">${run.current} A</span>
                    </div>
                    <div class="result-row">
                        <span class="result-label">Voltage Drop</span>
                        <span class="result-value">${run.actualVoltageDropPercent}%${run.voltageDropOK ? '' : ' <span style="color: var(--danger-color);">⚠ Exceeds target</span>'}</span>
                    </div>
                    ${run.warnings.length > 0 ? `<div style="margin-top: 4px; font-size: 0.85em; color: var(--warning-color);">${run.warnings.join('; ')}</div>` : ''}
                </div>
            `;
        };

        let html = '<h3>DC Cables</h3><div class="results-section">';
        for (let i = 0; i < cables.dcRuns.length; i++) {
            html += renderCableRun(cables.dcRuns[i], i < cables.dcRuns.length - 1);
        }

        html += '</div><h3>AC Cables</h3><div class="results-section">';
        for (let i = 0; i < cables.acRuns.length; i++) {
            html += renderCableRun(cables.acRuns[i], i < cables.acRuns.length - 1);
        }

        html += `
            </div>
            <div class="results-section" style="margin-top: 16px;">
                <h4 style="margin: 0 0 8px 0; opacity: 0.8;">Cable Summary</h4>
                <div class="result-row">
                    <span class="result-label">Total Cable Length</span>
                    <span class="result-value">${cables.totalCopperLengthM} m</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Estimated Copper Weight</span>
                    <span class="result-value">${cables.estimatedCopperKg} kg</span>
                </div>
            </div>
            <div style="margin-top: 12px; padding: 10px; background: var(--card-bg); border-radius: 6px; border-left: 3px solid var(--primary-color); font-size: 0.85em; opacity: 0.9;">
                <strong>Note:</strong> Cable sizes shown as market-standard metric sizes available in stores.
                Calculated minimum cross-section (from voltage drop and ampacity) shown in brackets where it differs.
                Always purchase the market-standard size shown in bold — it meets or exceeds the calculated requirement.
            </div>
        `;

        return html;
    },

    /**
     * Generate SVG diagram of a panel configuration
     */
    renderPVConfigSVG(cfg, panel, isRecommended, isUserConfig) {
        const panelW = 58;
        const panelH = 36;
        const gapX = 6;
        const gapY = 14;
        const padX = 40;
        const padY = 50;
        const s = cfg.series;
        const p = cfg.parallel;

        const svgW = padX * 2 + s * (panelW + gapX);
        const svgH = padY * 2 + p * (panelH + gapY) + 30;
        const borderColor = !cfg.valid ? '#ef4444' : isRecommended ? '#22c55e' : '#3b82f6';
        const bgColor = !cfg.valid ? '#fef2f2' : isRecommended ? '#f0fdf4' : '#eff6ff';

        let svg = `<svg viewBox="0 0 ${svgW} ${svgH}" style="width: 100%; max-width: ${Math.min(svgW, 700)}px; height: auto; background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 8px; margin: 8px 0;">`;

        // Title
        const titleText = isUserConfig ? `Your Config: ${cfg.label}` : isRecommended ? `Recommended: ${cfg.label}` : cfg.label;
        const validMark = cfg.valid ? ' &#10003;' : ' &#10007; INVALID';
        svg += `<text x="${svgW/2}" y="20" text-anchor="middle" font-size="13" font-weight="bold" fill="${borderColor}">${titleText}${validMark}</text>`;

        // Draw panels
        for (let row = 0; row < p; row++) {
            for (let col = 0; col < s; col++) {
                const x = padX + col * (panelW + gapX);
                const y = padY + row * (panelH + gapY);

                // Panel rectangle
                svg += `<rect x="${x}" y="${y}" width="${panelW}" height="${panelH}" rx="3" fill="${cfg.valid ? '#f8fafc' : '#fee2e2'}" stroke="${borderColor}" stroke-width="1.5"/>`;
                // Panel label
                svg += `<text x="${x + panelW/2}" y="${y + panelH/2 + 4}" text-anchor="middle" font-size="9" fill="#334155">${panel.wattage}W</text>`;

                // Series connection line
                if (col < s - 1) {
                    svg += `<line x1="${x + panelW}" y1="${y + panelH/2}" x2="${x + panelW + gapX}" y2="${y + panelH/2}" stroke="#f59e0b" stroke-width="2"/>`;
                }
            }

            // String label on right
            const stringEndX = padX + s * (panelW + gapX) + 2;
            const stringY = padY + row * (panelH + gapY) + panelH / 2 + 3;
            svg += `<text x="${stringEndX}" y="${stringY}" font-size="8" fill="#64748b">String ${row + 1}</text>`;

            // Parallel connection lines
            if (row < p - 1) {
                const lineX = padX + 10;
                const y1 = padY + row * (panelH + gapY) + panelH;
                const y2 = padY + (row + 1) * (panelH + gapY);
                svg += `<line x1="${lineX}" y1="${y1}" x2="${lineX}" y2="${y2}" stroke="#3b82f6" stroke-width="1.5" stroke-dasharray="4"/>`;
                const lineX2 = padX + s * (panelW + gapX) - gapX - 10;
                svg += `<line x1="${lineX2}" y1="${y1}" x2="${lineX2}" y2="${y2}" stroke="#ef4444" stroke-width="1.5" stroke-dasharray="4"/>`;
            }
        }

        // Labels at bottom
        const labelsY = padY + p * (panelH + gapY) + 10;
        svg += `<text x="${padX}" y="${labelsY}" font-size="10" fill="#475569">Vmp: ${cfg.stringVmp}V | Voc(cold): ${cfg.stringVocCold}V</text>`;
        svg += `<text x="${padX}" y="${labelsY + 14}" font-size="10" fill="#475569">Isc: ${cfg.arrayIsc}A${cfg.arrayIscTol ? ' (tol: ' + cfg.arrayIscTol + 'A)' : ''} | Power: ${cfg.totalPower}W</text>`;

        svg += '</svg>';
        return svg;
    },

    /**
     * Render PV Configuration Comparison tab
     */
    renderConfigTab(configComparison, panel, multiMPPTResult) {
        if (!configComparison || !configComparison.configurations || configComparison.configurations.length === 0) {
            return '<div class="results-section"><p>No configuration data available. Add panels and run calculation.</p></div>';
        }

        const mppt = this.getMPPT();
        const configs = configComparison.configurations;
        const validConfigs = configs.filter(c => c.valid);
        const bestValid = validConfigs.length > 0 ? validConfigs[0] : null;
        let html = '<div class="results-section">';

        // Multi-MPPT Distribution Results (shown prominently when active)
        if (multiMPPTResult && multiMPPTResult.distributions && multiMPPTResult.distributions.length > 0) {
            html += this.renderMultiMPPTSection(multiMPPTResult, panel, mppt);
            html += '<hr style="margin: 20px 0; border-color: var(--border-color);">';
            html += '<h3 style="color: var(--text-muted);">Single-MPPT Analysis (for reference)</h3>';
            html += '<small style="color: var(--text-muted); display: block; margin-bottom: 12px;">Below shows what would happen if all panels were on a single MPPT input. With multi-MPPT, refer to the distribution above.</small>';
        }

        // User config validation (if manual mode)
        if (configComparison.userConfig) {
            const uc = configComparison.userConfig;
            html += `<h3 style="margin-bottom: 8px;">Your Configuration: ${uc.label}</h3>`;
            html += this.renderPVConfigSVG(uc, panel, false, true);

            if (uc.valid) {
                html += '<div class="alert alert-info" style="margin: 8px 0;"><span class="alert-icon">&#10003;</span><div class="alert-content"><strong>Configuration is VALID</strong> — All electrical limits satisfied.</div></div>';
            } else {
                // Determine if power-only violation (acceptable clipping scenario)
                const powerOnlyViolation = !uc.checks.powerOk && uc.checks.vocOk && uc.checks.currentOk &&
                    (uc.checks.vmpMinOk !== false) && (uc.checks.vmpMaxOk !== false) && (uc.checks.startupOk !== false);
                const powerOverPercent = uc.totalPower > 0 && mppt.maxPower > 0 ?
                    Math.round((uc.totalPower - mppt.maxPower) / mppt.maxPower * 100) : 0;

                if (powerOnlyViolation && powerOverPercent <= 15) {
                    // Acceptable clipping — power slightly over but everything else is fine
                    html += `<div class="alert alert-warning" style="margin: 8px 0;"><span class="alert-icon">&#9888;</span><div class="alert-content"><strong>Configuration EXCEEDS power limit by ${powerOverPercent}% — Acceptable Clipping</strong><br>Your ${uc.totalPower}W array exceeds the ${mppt.maxPower}W max input by ${uc.totalPower - mppt.maxPower}W. The inverter will simply clip (limit) the excess power — this is NOT dangerous and does NOT damage equipment. You lose a small amount of energy during peak sun but gain better morning/evening and cloudy-day performance. Many installers intentionally oversize by 10-15% for this reason.</div></div>`;
                } else {
                    html += '<div class="alert alert-error" style="margin: 8px 0;"><span class="alert-icon">&#9888;</span><div class="alert-content"><strong>Configuration has VIOLATIONS</strong></div></div>';
                    (uc.blocks || []).forEach(b => {
                        html += `<div class="alert alert-error" style="margin: 4px 0;"><div class="alert-content">${b}</div></div>`;
                    });
                }

                // Show best valid alternative prominently when user config is invalid
                if (bestValid) {
                    html += `
                        <div class="alert alert-info" style="margin: 10px 0; padding: 12px;">
                            <span class="alert-icon">&#128161;</span>
                            <div class="alert-content">
                                <strong>Best Valid Alternative: ${bestValid.label} (${bestValid.totalPanels} panels)</strong><br>
                                Vmp: ${bestValid.stringVmp}V | Voc(cold): ${bestValid.stringVocCold}V | Isc: ${bestValid.arrayIsc}A | Power: ${bestValid.totalPower}W<br>
                                <span style="font-size: 0.85rem; color: var(--text-muted);">Voc margin: ${bestValid.margins.vocMargin}% | Current margin: ${bestValid.margins.currentMargin}% | Power util: ${bestValid.margins.powerUtil}%</span>
                            </div>
                        </div>`;
                } else {
                    // No valid config exists at all — find the least-bad one
                    const leastBad = configs[0]; // already sorted by score
                    const violations = [];
                    if (!leastBad.checks.vocOk) violations.push('Voc exceeds limit');
                    if (!leastBad.checks.currentOk) violations.push('Current exceeds limit');
                    if (!leastBad.checks.powerOk) violations.push(`Power ${leastBad.totalPower}W > ${mppt.maxPower}W`);
                    if (!leastBad.checks.vmpMaxOk) violations.push('Vmp exceeds operating range');
                    if (!leastBad.checks.vmpMinOk) violations.push('Vmp below min startup');

                    // Check if the least-bad is power-only violation
                    const lbPowerOnly = !leastBad.checks.powerOk && leastBad.checks.vocOk && leastBad.checks.currentOk &&
                        (leastBad.checks.vmpMinOk !== false) && (leastBad.checks.vmpMaxOk !== false);
                    const lbOverPct = Math.round((leastBad.totalPower - mppt.maxPower) / mppt.maxPower * 100);

                    html += '<div class="alert alert-warning" style="margin: 10px 0; padding: 12px;"><span class="alert-icon">&#128161;</span><div class="alert-content">';
                    html += '<strong>No fully valid configuration exists for this panel count and MPPT specs.</strong><br>';

                    if (lbPowerOnly && lbOverPct <= 20) {
                        html += `<br>The closest option is <strong>${leastBad.label}</strong> — only violates power limit by ${lbOverPct}% (${leastBad.totalPower}W vs ${mppt.maxPower}W max). The inverter will clip the excess, which is common practice and NOT harmful. This is your best available option.`;
                    } else {
                        html += `<br>The closest option is <strong>${leastBad.label}</strong> but it has ${violations.length} violation(s): ${violations.join(', ')}. Consider: (1) Reducing panel count, (2) Using an MPPT/inverter with higher input specs, or (3) Splitting panels across multiple MPPT inputs if available.`;
                    }
                    html += '</div></div>';

                    // Show nearby valid alternatives
                    html += this.renderNearbyValidConfigs(configComparison.nearbyValid);
                }
            }

            (uc.warnings || []).forEach(w => {
                html += `<div class="alert alert-warning" style="margin: 4px 0;"><div class="alert-content">${w}</div></div>`;
            });

            // Validation table
            html += `
                <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 0.9rem;">
                    <tr style="background: var(--bg-color);">
                        <th style="padding: 6px; text-align: left; border: 1px solid var(--border-color);">Check</th>
                        <th style="padding: 6px; text-align: left; border: 1px solid var(--border-color);">Value</th>
                        <th style="padding: 6px; text-align: left; border: 1px solid var(--border-color);">Limit</th>
                        <th style="padding: 6px; text-align: center; border: 1px solid var(--border-color);">Status</th>
                    </tr>
                    <tr><td style="padding:5px; border:1px solid var(--border-color);">String Voc (cold)</td><td style="padding:5px; border:1px solid var(--border-color);">${uc.stringVocCold}V</td><td style="padding:5px; border:1px solid var(--border-color);">&lt; ${mppt.maxVoltage}V</td><td style="padding:5px; border:1px solid var(--border-color); text-align:center; color:${uc.checks.vocOk ? 'var(--success-color)' : 'var(--error-color)'};">${uc.checks.vocOk ? '&#10003; OK' : '&#10007; FAIL'}</td></tr>
                    <tr><td style="padding:5px; border:1px solid var(--border-color);">String Vmp range</td><td style="padding:5px; border:1px solid var(--border-color);">${uc.stringVmp}V</td><td style="padding:5px; border:1px solid var(--border-color);">${mppt.minVoltage}-${mppt.maxOperatingVoltage}V</td><td style="padding:5px; border:1px solid var(--border-color); text-align:center; color:${uc.checks.vmpMinOk && uc.checks.vmpMaxOk ? 'var(--success-color)' : 'var(--error-color)'};">${uc.checks.vmpMinOk && uc.checks.vmpMaxOk ? '&#10003; OK' : '&#10007; FAIL'}</td></tr>
                    <tr><td style="padding:5px; border:1px solid var(--border-color);">Array Isc (+4% tol)</td><td style="padding:5px; border:1px solid var(--border-color);">${uc.arrayIscTol}A</td><td style="padding:5px; border:1px solid var(--border-color);">&lt; ${mppt.maxCurrent}A</td><td style="padding:5px; border:1px solid var(--border-color); text-align:center; color:${uc.checks.currentOk ? 'var(--success-color)' : 'var(--error-color)'};">${uc.checks.currentOk ? '&#10003; OK' : '&#10007; FAIL'}</td></tr>
                    <tr><td style="padding:5px; border:1px solid var(--border-color);">Total Power</td><td style="padding:5px; border:1px solid var(--border-color);">${uc.totalPower}W</td><td style="padding:5px; border:1px solid var(--border-color);">&lt; ${mppt.maxPower}W</td><td style="padding:5px; border:1px solid var(--border-color); text-align:center; color:${uc.checks.powerOk ? 'var(--success-color)' : 'var(--error-color)'};">${uc.checks.powerOk ? '&#10003; OK' : '&#10007; FAIL'}</td></tr>
                    <tr><td style="padding:5px; border:1px solid var(--border-color);">Startup Voltage</td><td style="padding:5px; border:1px solid var(--border-color);">${uc.stringVmp}V</td><td style="padding:5px; border:1px solid var(--border-color);">&gt; ${mppt.minVoltage}V</td><td style="padding:5px; border:1px solid var(--border-color); text-align:center; color:${uc.checks.startupOk ? 'var(--success-color)' : 'var(--error-color)'};">${uc.checks.startupOk ? '&#10003; OK' : '&#10007; FAIL'}</td></tr>
                </table>
            `;
            html += '<hr style="margin: 16px 0; border-color: var(--border-color);">';
        }

        // Configuration conclusion summary for auto mode (no user config)
        if (!configComparison.userConfig) {
            if (bestValid) {
                html += `<div class="alert alert-info" style="margin-bottom: 12px;"><span class="alert-icon">&#10003;</span><div class="alert-content"><strong>Recommended: ${bestValid.label}</strong> — ${bestValid.totalPanels} panels, ${bestValid.totalPower}W. All electrical limits satisfied with comfortable margins.</div></div>`;
            } else {
                // No valid configs in auto mode
                const leastBad = configs[0];
                const lbPowerOnly = leastBad && !leastBad.checks.powerOk && leastBad.checks.vocOk && leastBad.checks.currentOk &&
                    (leastBad.checks.vmpMinOk !== false) && (leastBad.checks.vmpMaxOk !== false);
                const lbOverPct = leastBad ? Math.round((leastBad.totalPower - mppt.maxPower) / mppt.maxPower * 100) : 0;

                if (lbPowerOnly && lbOverPct <= 20) {
                    html += `<div class="alert alert-warning" style="margin-bottom: 12px;"><span class="alert-icon">&#9888;</span><div class="alert-content"><strong>Best Option: ${leastBad.label}</strong> — Exceeds power limit by only ${lbOverPct}% (${leastBad.totalPower}W vs ${mppt.maxPower}W). The inverter clips the excess safely. This is acceptable and common practice — you get better performance in low light. All other electrical limits (voltage, current) are satisfied.</div></div>`;
                } else if (leastBad) {
                    html += `<div class="alert alert-error" style="margin-bottom: 12px;"><span class="alert-icon">&#9888;</span><div class="alert-content"><strong>No valid configuration found for ${configs[0] ? configs[0].totalPanels : '?'} panels</strong> — All options violate one or more electrical limits.</div></div>`;
                    // Show nearby valid alternatives
                    html += this.renderNearbyValidConfigs(configComparison.nearbyValid);
                }
            }
        }

        // Alternative configurations
        html += '<h3>All Possible Configurations</h3>';
        html += '<small style="color: var(--text-muted); display: block; margin-bottom: 10px;">Sorted by suitability. Green = recommended, Blue = valid, Red = invalid.</small>';

        const showMax = Math.min(configs.length, 6);

        for (let i = 0; i < showMax; i++) {
            const c = configs[i];
            const isRec = c.recommended;

            // Check if this is an "acceptable clipping" case
            const isPowerOnlyViolation = !c.valid && !c.checks.powerOk && c.checks.vocOk && c.checks.currentOk &&
                (c.checks.vmpMinOk !== false) && (c.checks.vmpMaxOk !== false) && (c.checks.startupOk !== false);
            const overPct = isPowerOnlyViolation ? Math.round((c.totalPower - mppt.maxPower) / mppt.maxPower * 100) : 0;
            const isAcceptableClip = isPowerOnlyViolation && overPct <= 15;

            const borderStyle = isAcceptableClip ? 'var(--warning-color)' : !c.valid ? 'var(--error-color)' : isRec ? 'var(--success-color)' : 'var(--border-color)';
            const bgStyle = isAcceptableClip ? 'rgba(245,158,11,0.05)' : !c.valid ? 'rgba(239,68,68,0.05)' : isRec ? 'rgba(34,197,94,0.05)' : 'var(--card-bg)';
            const statusLabel = isAcceptableClip ? ` &#9889; CLIPPING OK (+${overPct}%)` : !c.valid ? ' &#10007; INVALID' : '';

            html += `
                <div style="margin-bottom: 16px; padding: 12px; border: 2px solid ${borderStyle}; border-radius: 8px; background: ${bgStyle};">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; flex-wrap: wrap; gap: 8px;">
                        <strong style="font-size: 1.05rem;">${c.label} (${c.totalPanels} panels)${isRec ? ' &#11088; RECOMMENDED' : ''}${statusLabel}</strong>
                        <span style="font-size: 0.8rem; color: var(--text-muted);">Voc margin: ${c.margins.vocMargin}% | Current margin: ${c.margins.currentMargin}% | Power util: ${c.margins.powerUtil}%</span>
                    </div>
                    ${this.renderPVConfigSVG(c, panel, isRec, false)}
                    ${isAcceptableClip ? '<div style="font-size: 0.85rem; color: var(--warning-color); margin: 6px 0;">Inverter will clip excess power safely. Not harmful — common practice for better low-light performance.</div>' : ''}
                    <div style="display: flex; gap: 16px; margin-top: 8px; font-size: 0.85rem; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 200px;">
                            <strong style="color: var(--success-color);">Advantages:</strong>
                            <ul style="margin: 4px 0; padding-left: 18px;">${c.pros.map(pro => '<li>' + pro + '</li>').join('')}</ul>
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <strong style="color: ${c.valid || isAcceptableClip ? 'var(--warning-color)' : 'var(--error-color)'};">Disadvantages:</strong>
                            <ul style="margin: 4px 0; padding-left: 18px;">${c.cons.map(con => '<li>' + con + '</li>').join('')}</ul>
                        </div>
                    </div>
                </div>
            `;
        }

        if (configs.length > showMax) {
            html += `<p style="color: var(--text-muted); font-size: 0.85rem;">${configs.length - showMax} more configuration(s) possible but less optimal.</p>`;
        }

        html += '</div>';
        return html;
    },

    /**
     * Render nearby valid configurations found by searching adjacent panel counts
     */
    renderNearbyValidConfigs(nearbyValid) {
        if (!nearbyValid || nearbyValid.length === 0) return '';

        let html = `
            <div style="margin: 12px 0; padding: 14px; border: 2px solid var(--success-color); border-radius: 8px; background: rgba(34,197,94,0.05);">
                <h3 style="color: var(--success-color); margin-bottom: 10px;">&#128161; Valid Configurations With Different Panel Counts</h3>
                <small style="color: var(--text-muted); display: block; margin-bottom: 10px;">These configurations work within all your MPPT/inverter limits. Adjust your panel count to use one of these.</small>
                <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                    <tr style="background: var(--bg-color);">
                        <th style="padding: 8px; text-align: left; border: 1px solid var(--border-color);">Config</th>
                        <th style="padding: 8px; text-align: center; border: 1px solid var(--border-color);">Panels</th>
                        <th style="padding: 8px; text-align: right; border: 1px solid var(--border-color);">Vmp</th>
                        <th style="padding: 8px; text-align: right; border: 1px solid var(--border-color);">Voc (cold)</th>
                        <th style="padding: 8px; text-align: right; border: 1px solid var(--border-color);">Isc (tol)</th>
                        <th style="padding: 8px; text-align: right; border: 1px solid var(--border-color);">Power</th>
                        <th style="padding: 8px; text-align: center; border: 1px solid var(--border-color);">Margins</th>
                    </tr>`;

        nearbyValid.forEach((nv, idx) => {
            const bg = idx === 0 ? 'rgba(34,197,94,0.08)' : 'var(--card-bg)';
            const badge = idx === 0 ? ' <strong style="color: var(--success-color);">BEST</strong>' : '';
            const deltaLabel = nv.delta > 0 ? `+${nv.delta}` : `${nv.delta}`;

            html += `
                <tr style="background: ${bg};">
                    <td style="padding: 8px; border: 1px solid var(--border-color);"><strong>${nv.label}</strong>${badge}</td>
                    <td style="padding: 8px; text-align: center; border: 1px solid var(--border-color);">${nv.totalPanels} <span style="font-size: 0.8rem; color: var(--text-muted);">(${deltaLabel})</span></td>
                    <td style="padding: 8px; text-align: right; border: 1px solid var(--border-color);">${nv.stringVmp}V</td>
                    <td style="padding: 8px; text-align: right; border: 1px solid var(--border-color);">${nv.stringVocCold}V</td>
                    <td style="padding: 8px; text-align: right; border: 1px solid var(--border-color);">${nv.arrayIscTol}A</td>
                    <td style="padding: 8px; text-align: right; border: 1px solid var(--border-color);">${nv.totalPower}W</td>
                    <td style="padding: 8px; text-align: center; border: 1px solid var(--border-color); font-size: 0.8rem;">Voc: ${nv.vocMargin}% | I: ${nv.currentMargin}%</td>
                </tr>`;
        });

        html += '</table>';

        // Practical recommendation
        const best = nearbyValid[0];
        if (best.delta < 0) {
            html += `<div style="margin-top: 10px; font-size: 0.9rem; padding: 8px; background: rgba(34,197,94,0.05); border-radius: 4px;"><strong>Recommendation:</strong> Use <strong>${best.totalPanels} panels in ${best.label}</strong> configuration. This means removing ${Math.abs(best.delta)} panel(s) from your plan. All electrical limits are satisfied with safe margins (Voc margin: ${best.vocMargin}%, Current margin: ${best.currentMargin}%).</div>`;
        } else if (best.delta > 0) {
            html += `<div style="margin-top: 10px; font-size: 0.9rem; padding: 8px; background: rgba(34,197,94,0.05); border-radius: 4px;"><strong>Recommendation:</strong> Use <strong>${best.totalPanels} panels in ${best.label}</strong> configuration. This means adding ${best.delta} panel(s) to your plan. All electrical limits are satisfied with safe margins (Voc margin: ${best.vocMargin}%, Current margin: ${best.currentMargin}%).</div>`;
        }

        html += '</div>';
        return html;
    },

    /**
     * Render Multi-MPPT Distribution section
     */
    renderMultiMPPTSection(multiMPPTResult, panel, mppt) {
        let html = '';
        const dists = multiMPPTResult.distributions;
        const recIdx = multiMPPTResult.recommended;

        html += `<h3 style="color: var(--primary-color); margin-bottom: 6px;">Multi-MPPT Panel Distribution (${multiMPPTResult.mpptCount} MPPT Inputs)</h3>`;
        html += `<small style="color: var(--text-muted); display: block; margin-bottom: 12px;">Panels are distributed across your ${multiMPPTResult.mpptCount} MPPT inputs. Each MPPT is validated independently against its own specs.</small>`;

        // Show top distributions (max 4)
        const showMax = Math.min(dists.length, 4);
        for (let d = 0; d < showMax; d++) {
            const dist = dists[d];
            const isRec = dist.recommended;
            const borderColor = !dist.allValid ? 'var(--error-color)' : isRec ? 'var(--success-color)' : 'var(--primary-color)';
            const bgColor = !dist.allValid ? 'rgba(239,68,68,0.04)' : isRec ? 'rgba(34,197,94,0.04)' : 'rgba(37,99,235,0.03)';

            html += `<div style="margin-bottom: 16px; padding: 14px; border: 2px solid ${borderColor}; border-radius: 10px; background: ${bgColor};">`;
            html += `<div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;">`;
            html += `<strong style="font-size: 1.05rem;">${isRec ? '&#11088; RECOMMENDED — ' : ''}${dist.label}</strong>`;
            html += `<span style="font-size: 0.85rem; padding: 3px 10px; border-radius: 12px; background: ${dist.allValid ? 'var(--success-color)' : 'var(--error-color)'}; color: white; font-weight: 600;">${dist.allValid ? 'ALL VALID' : 'HAS VIOLATIONS'}</span>`;
            html += `</div>`;

            // Show total panels info
            if (dist.panelDeviation > 0) {
                html += `<div style="font-size: 0.85rem; color: var(--warning-color); margin-bottom: 8px;">Uses ${dist.totalActualPanels} panels (requested ${dist.requestedPanels}, difference: ${dist.panelDeviation > 0 ? (dist.totalActualPanels > dist.requestedPanels ? '+' : '-') : ''}${dist.panelDeviation})</div>`;
            } else {
                html += `<div style="font-size: 0.85rem; color: var(--success-color); margin-bottom: 8px;">Uses exactly ${dist.totalActualPanels} panels as requested</div>`;
            }

            // Per-MPPT breakdown table
            html += `<table style="width: 100%; border-collapse: collapse; font-size: 0.88rem; margin-bottom: 8px;">`;
            html += `<tr style="background: var(--bg-color);">
                <th style="padding: 6px 8px; text-align: left; border: 1px solid var(--border-color);">MPPT Input</th>
                <th style="padding: 6px 8px; text-align: center; border: 1px solid var(--border-color);">Config</th>
                <th style="padding: 6px 8px; text-align: center; border: 1px solid var(--border-color);">Panels</th>
                <th style="padding: 6px 8px; text-align: center; border: 1px solid var(--border-color);">Vmp (V)</th>
                <th style="padding: 6px 8px; text-align: center; border: 1px solid var(--border-color);">Voc cold (V)</th>
                <th style="padding: 6px 8px; text-align: center; border: 1px solid var(--border-color);">Isc (A)</th>
                <th style="padding: 6px 8px; text-align: center; border: 1px solid var(--border-color);">Power (W)</th>
                <th style="padding: 6px 8px; text-align: center; border: 1px solid var(--border-color);">Status</th>
            </tr>`;

            for (const assign of dist.mpptAssignments) {
                if (assign.unused) {
                    html += `<tr style="opacity: 0.5;">
                        <td style="padding: 5px 8px; border: 1px solid var(--border-color);">${assign.mpptLabel}</td>
                        <td colspan="6" style="padding: 5px 8px; border: 1px solid var(--border-color); text-align: center; font-style: italic;">Unused (0 panels assigned)</td>
                        <td style="padding: 5px 8px; border: 1px solid var(--border-color); text-align: center;">—</td>
                    </tr>`;
                    continue;
                }

                const cfg = assign.config;
                const mpptSpec = mppt.allMPPTs[assign.mpptIndex];
                const statusColor = assign.valid ? 'var(--success-color)' : 'var(--error-color)';
                const statusIcon = assign.valid ? '&#10003;' : '&#10007;';

                html += `<tr>
                    <td style="padding: 5px 8px; border: 1px solid var(--border-color); font-weight: 600;">${assign.mpptLabel}<br><span style="font-size: 0.75rem; font-weight: normal; color: var(--text-muted);">Max: ${mpptSpec.maxPower}W / ${mpptSpec.maxCurrent}A</span></td>
                    <td style="padding: 5px 8px; border: 1px solid var(--border-color); text-align: center; font-weight: 600;">${cfg ? cfg.label : '—'}</td>
                    <td style="padding: 5px 8px; border: 1px solid var(--border-color); text-align: center;">${assign.panels}</td>
                    <td style="padding: 5px 8px; border: 1px solid var(--border-color); text-align: center;">${cfg ? cfg.stringVmp : '—'}</td>
                    <td style="padding: 5px 8px; border: 1px solid var(--border-color); text-align: center;">${cfg ? cfg.stringVocCold : '—'}</td>
                    <td style="padding: 5px 8px; border: 1px solid var(--border-color); text-align: center;">${cfg ? cfg.arrayIscTol : '—'}</td>
                    <td style="padding: 5px 8px; border: 1px solid var(--border-color); text-align: center;">${cfg ? cfg.totalPower : '—'}</td>
                    <td style="padding: 5px 8px; border: 1px solid var(--border-color); text-align: center; color: ${statusColor}; font-weight: bold;">${statusIcon} ${assign.valid ? 'OK' : 'FAIL'}</td>
                </tr>`;

                // Show violations for failed MPPTs
                if (!assign.valid && assign.violations) {
                    html += `<tr><td colspan="8" style="padding: 4px 8px 8px 30px; border: 1px solid var(--border-color); color: var(--error-color); font-size: 0.82rem;">
                        ${assign.violations.map(v => '&#10007; ' + v).join('<br>')}
                    </td></tr>`;
                }
            }
            html += '</table>';

            // SVG diagrams for each MPPT in recommended distribution
            if (isRec) {
                html += '<div style="display: flex; gap: 12px; flex-wrap: wrap; margin-top: 8px;">';
                for (const assign of dist.mpptAssignments) {
                    if (assign.unused || !assign.config) continue;
                    html += `<div style="flex: 1; min-width: 250px;">`;
                    html += `<div style="text-align: center; font-size: 0.85rem; font-weight: 600; color: var(--primary-color); margin-bottom: 4px;">${assign.mpptLabel}</div>`;
                    html += this.renderPVConfigSVG(assign.config, panel, true, false);
                    html += `</div>`;
                }
                html += '</div>';

                // Practical wiring guidance
                html += `<div style="margin-top: 10px; padding: 10px; background: rgba(37,99,235,0.04); border-radius: 6px; font-size: 0.88rem;">`;
                html += `<strong style="color: var(--primary-color);">Wiring Guide:</strong><ul style="margin: 6px 0 0; padding-left: 18px;">`;

                for (const assign of dist.mpptAssignments) {
                    if (assign.unused || !assign.config) continue;
                    const cfg = assign.config;
                    html += `<li>${assign.mpptLabel}: Wire ${cfg.series} panels in series${cfg.parallel > 1 ? `, then combine ${cfg.parallel} strings in parallel` : ''} → connect to ${assign.mpptLabel} input terminals</li>`;
                }

                html += `<li>Each MPPT input should have its own PV DC isolator/breaker</li>`;
                html += `<li>Do NOT mix panels from different MPPT inputs into the same string</li>`;
                html += `</ul></div>`;
            }

            html += '</div>';
        }

        return html;
    },

    /**
     * Render Upgrade Path tab
     */
    renderUpgradeTab(upgradePaths) {
        if (!upgradePaths || upgradePaths.length === 0) {
            return '<div class="results-section"><p>Upgrade analysis not available. Run calculation first.</p></div>';
        }

        let html = '<div class="results-section">';
        html += '<small style="color: var(--text-muted); display: block; margin-bottom: 14px;">Explore how your system can grow. Each category shows what is possible with your current equipment and what requires new components.</small>';

        for (const path of upgradePaths) {
            html += `
                <div style="margin-bottom: 20px; border: 1px solid var(--border-color); border-radius: 10px; overflow: hidden;">
                    <div style="padding: 12px 16px; background: var(--bg-color); border-bottom: 1px solid var(--border-color);">
                        <h3 style="margin: 0; font-size: 1.05rem;">${path.icon} ${path.category}</h3>
                        <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 3px;">Current: ${path.current}</div>
                    </div>
                    <div style="padding: 12px 16px;">`;

            for (const opt of path.options) {
                const borderLeft = opt.feasible ? '3px solid var(--success-color)' : '3px solid var(--error-color)';
                const bgColor = opt.feasible ? 'rgba(34,197,94,0.03)' : 'rgba(239,68,68,0.03)';
                const statusBadge = opt.feasible ?
                    '<span style="font-size: 0.75rem; padding: 2px 8px; border-radius: 10px; background: var(--success-color); color: white; font-weight: 600;">FEASIBLE</span>' :
                    '<span style="font-size: 0.75rem; padding: 2px 8px; border-radius: 10px; background: var(--error-color); color: white; font-weight: 600;">BLOCKED</span>';

                html += `
                    <div style="margin-bottom: 10px; padding: 10px 12px; border-left: ${borderLeft}; background: ${bgColor}; border-radius: 0 6px 6px 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 6px;">
                            <strong style="font-size: 0.95rem;">${opt.label}</strong>
                            ${statusBadge}
                        </div>
                        <div style="font-size: 0.88rem; color: var(--text-color); margin-top: 5px;">${opt.detail}</div>
                        <div style="font-size: 0.85rem; color: var(--primary-color); margin-top: 3px;">${opt.impact}</div>
                        ${opt.notes ? `<div style="font-size: 0.82rem; color: var(--warning-color); margin-top: 4px; font-style: italic;">${opt.notes}</div>` : ''}
                    </div>`;
            }

            html += '</div></div>';
        }

        html += '</div>';
        return html;
    },

    /**
     * Render Smart Advisory tab
     */
    renderAdvisoryTab(advisories) {
        if (!advisories || advisories.length === 0) {
            return '<div class="results-section"><p>No specific advisories for this system configuration.</p></div>';
        }

        const categories = {};
        advisories.forEach(a => {
            if (!categories[a.category]) categories[a.category] = [];
            categories[a.category].push(a);
        });

        const severityIcon = { critical: '&#9888;', warning: '&#9888;', info: '&#128161;' };
        const severityClass = { critical: 'alert-error', warning: 'alert-warning', info: 'alert-info' };

        let html = '<div class="results-section">';
        html += '<small style="color: var(--text-muted); display: block; margin-bottom: 12px;">Practical usage guidelines based on your specific system. Follow these for optimal battery life and system performance.</small>';

        for (const [cat, items] of Object.entries(categories)) {
            html += `<h3 style="margin-top: 16px; margin-bottom: 8px;">${cat}</h3>`;
            items.forEach(item => {
                html += `
                    <div class="alert ${severityClass[item.severity] || 'alert-info'}" style="margin-bottom: 8px;">
                        <span class="alert-icon">${severityIcon[item.severity] || '&#128161;'}</span>
                        <div class="alert-content">
                            <div class="alert-title">${item.title}</div>
                            <p style="margin: 4px 0 0 0; font-size: 0.9rem;">${item.message}</p>
                        </div>
                    </div>
                `;
            });
        }

        html += '</div>';
        return html;
    },

    renderProtectionTab(protection) {
        let html = '';

        const renderDevices = (devices, title) => {
            html += `<h3>${title}</h3><ul class="equipment-list">`;
            for (const device of devices) {
                html += `
                    <li>
                        <span class="equipment-name">${device.name}</span>
                        ${device.mandatory ? ' <span style="color: var(--error-color);">(Required)</span>' : ' <span style="color: var(--text-muted);">(Recommended)</span>'}
                        ${device.isManual ? ' <span style="color: var(--warning-color); font-size: 0.8rem;">&#128295; Manual</span>' : ''}
                        <div class="equipment-spec">${device.type}: ${device.rating}</div>
                        ${device.isManual && device.autoSuggested ? `<div class="equipment-spec" style="color: var(--text-muted);">Auto-suggested: ${device.autoSuggested}A</div>` : ''}
                        <div class="equipment-spec">Location: ${device.location}</div>
                        <div class="equipment-spec">Purpose: ${device.purpose}</div>
                        ${device.notes ? `<div class="equipment-spec" style="color: var(--primary-color); font-style: italic; margin-top: 3px;">Note: ${device.notes}</div>` : ''}
                    </li>
                `;
            }
            html += '</ul>';
        };

        renderDevices(protection.pvSide, 'PV Side Protection');
        renderDevices(protection.batterySide, 'Battery Side Protection');
        renderDevices(protection.acSide, 'AC Side Protection');
        renderDevices(protection.earthing, 'Earthing');

        // Protection warnings
        if (protection.warnings && protection.warnings.length > 0) {
            html += '<h3>Protection Warnings</h3>';
            protection.warnings.forEach(w => {
                html += `<div class="alert alert-warning" style="margin: 4px 0;"><span class="alert-icon">&#9888;</span><div class="alert-content">${w}</div></div>`;
            });
        }

        return html;
    },

    renderLossesTab(losses) {
        return `
            <div class="results-section">
                <h3>Component Efficiencies</h3>
                <div class="result-row">
                    <span class="result-label">Inverter Efficiency</span>
                    <span class="result-value">${losses.inverterEfficiency}%</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Battery Round-Trip</span>
                    <span class="result-value">${losses.batteryRoundTripEfficiency}%</span>
                </div>
                <div class="result-row">
                    <span class="result-label">MPPT Efficiency</span>
                    <span class="result-value">${losses.mpptEfficiency}%</span>
                </div>

                <h3>System Losses</h3>
                <div class="result-row">
                    <span class="result-label">PV Temperature Derating</span>
                    <span class="result-value">${losses.pvTempDerating}%</span>
                </div>
                <div class="result-row">
                    <span class="result-label">PV Soiling Loss</span>
                    <span class="result-value">${losses.pvSoilingLoss}%</span>
                </div>
                <div class="result-row">
                    <span class="result-label">PV Mismatch Loss</span>
                    <span class="result-value">${losses.pvMismatchLoss}%</span>
                </div>
                <div class="result-row">
                    <span class="result-label">DC Cable Loss</span>
                    <span class="result-value">${losses.dcCableLoss}%</span>
                </div>
                <div class="result-row">
                    <span class="result-label">AC Cable Loss</span>
                    <span class="result-value">${losses.acCableLoss}%</span>
                </div>

                <h3>Totals</h3>
                <div class="result-row">
                    <span class="result-label">Total DC Losses</span>
                    <span class="result-value">${losses.totalDCLosses}%</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Total AC Losses</span>
                    <span class="result-value">${losses.totalACLosses}%</span>
                </div>
                <div class="result-row" style="background: var(--bg-color); font-weight: bold;">
                    <span class="result-label">Overall System Efficiency</span>
                    <span class="result-value">${losses.overallSystemEfficiency}%</span>
                </div>

                <h3>Energy Balance</h3>
                <div class="result-row">
                    <span class="result-label">Gross PV Energy</span>
                    <span class="result-value">${losses.grossPVEnergyDaily} Wh/day</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Net Available Energy</span>
                    <span class="result-value">${losses.netAvailableEnergyDaily} Wh/day</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Load Requirement</span>
                    <span class="result-value">${losses.loadRequirementDaily} Wh/day</span>
                </div>
                <div class="result-row" style="background: ${losses.energyMarginPercent >= 0 ? '#dcfce7' : '#fee2e2'}; font-weight: bold;">
                    <span class="result-label">Energy Margin</span>
                    <span class="result-value">${losses.energyMarginPercent > 0 ? '+' : ''}${losses.energyMarginPercent}%</span>
                </div>
            </div>
        `;
    },

    /**
     * Switch between tabs
     */
    showTab(tabName) {
        // Hide all tab contents
        document.querySelectorAll('.tab-content').forEach(el => {
            el.classList.remove('active');
        });

        // Deactivate all tabs
        document.querySelectorAll('.tab').forEach(el => {
            el.classList.remove('active');
        });

        // Show selected tab content
        document.getElementById(`tab-${tabName}`).classList.add('active');

        // Activate selected tab
        event.target.classList.add('active');
    },

    /**
     * Export results as JSON
     */
    exportJSON() {
        if (!this.results) {
            alert('No results to export. Please calculate first.');
            return;
        }

        const report = OutputGenerator.generateReport(this.results);
        const json = JSON.stringify(report, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `pv_system_design_${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
};

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
    PVCalculator.initTheme();
    PVCalculator.applyLocationDefaults();
    PVCalculator.updateLoadTypeDefaults();
    PVCalculator.validatePanelSpecs();
    PVCalculator.checkAutoSave();
    PVCalculator.onSystemTypeChange();
    PVCalculator.onBatteryChemistryChange();

    // Add input validation listeners for real-time feedback
    const numericInputs = document.querySelectorAll('input[type="number"]');
    numericInputs.forEach(input => {
        input.addEventListener('input', function() {
            const min = parseFloat(this.min);
            const max = parseFloat(this.max);
            const val = parseFloat(this.value);

            if (this.value === '' || isNaN(val)) {
                this.classList.remove('valid', 'invalid');
                return;
            }

            if (!isNaN(min) && val < min) {
                this.classList.add('invalid');
                this.classList.remove('valid');
            } else if (!isNaN(max) && val > max) {
                this.classList.add('invalid');
                this.classList.remove('valid');
            } else {
                this.classList.add('valid');
                this.classList.remove('invalid');
            }
        });
    });
});

    </script>

    <!-- ========================================================================
         FOOTER — Dynamic copyright, version, disclaimer
         ======================================================================== -->
    <footer style="
        margin-top: 40px;
        padding: 24px 16px 18px;
        border-top: 2px solid var(--border-color);
        background: var(--card-bg);
        text-align: center;
        font-size: 0.82em;
        color: var(--text-muted);
        line-height: 1.7;
    ">
        <div style="max-width: 800px; margin: 0 auto;">
            <p style="margin: 0 0 6px; font-weight: 600; color: var(--text-color);">
                Advanced Photovoltaic Estimation &nbsp;|&nbsp; v2.3.0
            </p>
            <p style="margin: 0 0 6px;">
                &copy; <span id="footerYear"></span> <strong>Leebartea</strong> &mdash; For engineering use.
            </p>
            <p style="margin: 0 0 10px; font-size: 0.92em;">
                Licensed under the <a href="LICENSE.txt" style="color: var(--primary-color); text-decoration: underline;">MIT License</a>.
            </p>
            <p style="margin: 0; font-size: 0.85em; max-width: 600px; margin: 0 auto; color: var(--text-muted);">
                <strong>Disclaimer:</strong> This tool is for estimation and planning purposes only.
                Final system designs must be validated by a qualified solar engineer or electrician
                in accordance with local electrical codes and standards. The author assumes no liability
                for installations based on these calculations.
            </p>
        </div>
    </footer>
    <script>document.getElementById('footerYear').textContent = new Date().getFullYear();</script>

    <!-- PDF Export Spinner -->
    <div class="pdf-spinner-overlay" id="pdfSpinnerOverlay">
        <div class="pdf-spinner-ring"></div>
        <div class="pdf-spinner-text">Generating PDF...</div>
    </div>

    <!-- Coping Score Modal -->
    <div class="coping-modal-overlay" id="copingModalOverlay" onclick="if(event.target===this)PVCalculator.closeCopingModal()">
        <div class="coping-modal">
            <div class="coping-modal-header">
                <h3 id="copingModalTitle">Coping Score Breakdown</h3>
                <button class="coping-modal-close" onclick="PVCalculator.closeCopingModal()" title="Close">&times;</button>
            </div>
            <div class="coping-modal-body" id="copingModalBody"></div>
        </div>
    </div>
</body>
</html>
